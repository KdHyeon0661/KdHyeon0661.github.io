---
layout: post
title: MFC - 타이머와 작업 예약
date: 2025-09-06 18:25:23 +0900
category: MFC
---
# 타이머(윈도우/대기 가능한 타이머)와 작업 예약 완전 가이드

(MFC/Win32: `SetTimer/WM_TIMER`, Waitable Timer, Timer Queue, Thread-Pool Timer, 예약 스케줄 패턴)

이 글은 Windows/MFC에서 **시간 기반 동작**을 안정적으로 구현하기 위한 실전 가이드입니다.
핵심 API(**윈도우 타이머**/`WM_TIMER`, **Waitable Timer**(`CreateWaitableTimer`), **타이머 큐**(`CreateTimerQueueTimer`), **스레드풀 타이머**(`CreateThreadpoolTimer`)를 **원리→장단점→사용법→취소/정밀도/전력/재진입**까지 예제로 정리**했습니다.
또한 “매일 9:00 실행” 같은 **작업 예약 스케줄러 패턴**, **절전/슬립 복귀**, **DST/타임존**, **하이레졸루션/정밀도**와 **디버깅 팁**까지 포함합니다.

> 대상: Win32/MFC(Feature Pack 포함), C++17+, x64, 유니코드
> 키워드: GUI 타이머, 대기 가능한 타이머, APC/콜백, 메시지 펌프 연계, 스케줄 반복, 저전력/절전, 정밀도, 재진입, 동기화

---

## 한 장 요약

| 분류 | 대표 API | 스레드/컨텍스트 | 정밀도/지터 | 장점 | 유의점/권장 용도 |
|---|---|---|---|---|---|
| **윈도우 타이머** | `SetTimer` + `WM_TIMER` | **윈도우 소유 UI 스레드** (메시지 펌프) | 보통(수십 ms+), 메시지 혼잡 시 지연 | 가장 간단, UI와 자연스럽게 연동 | **UI 작업**/Light 주기 동작/프로그레스 갱신 |
| **Waitable Timer** | `CreateWaitableTimer(Ex)` + `SetWaitableTimer` | **임의 스레드** (`WaitFor…`) | 우수(모드에 따라 높은 정밀도) | 대기/동기화 조합, 절전 복귀 시각 지정 가능 | Worker에서 대기, **정확한 실행 시점** |
| **타이머 큐** | `CreateTimerQueueTimer` | **시스템 워커**(콜백) | 우수 | 해제 단순, 다수 타이머에 적합 | 콜백 재진입 주의, 취소 순서 명확화 |
| **스레드풀 타이머** | `CreateThreadpoolTimer` | **Thread Pool 콜백** | 우수, 대량/고성능 | 고급/강력(슬랙 조절 등) | 수명/참조 카운팅 주의 |
| **멀티미디어 타이머** | `timeSetEvent` (고정밀) | 콜백(APC) | 매우 높음 | (과거) 오디오/게임 | **권장 X**: 전력/시스템 전체 타이머 분해능 하향(주의) |

> **실무 기본 원칙**
> 1) **UI 업데이트**: `SetTimer/WM_TIMER`
> 2) **Worker 대기/정밀 스케줄**: **Waitable Timer** 또는 **스레드풀 타이머**
> 3) **타이머 다수/관리 편의**: **타이머 큐** or **스레드풀 타이머**
> 4) **하이레졸루션 강제**(글로벌 타이머 분해능 변경)는 **전력·시스템 영향** 큼 → 가능하면 **지양**

---

## — UI와 가장 친함

### 1-1. 기본 사용 (MFC `CWnd::SetTimer`)

```cpp
// 대화상자/뷰 클래스 멤버
UINT_PTR m_idBlink = 1;

// 시작
BOOL CMainDlg::OnInitDialog() {
    CDialogEx::OnInitDialog();
    SetTimer(m_idBlink, 500 /*ms*/, nullptr); // 0.5초마다
    return TRUE;
}

// 종료/정리
void CMainDlg::OnDestroy() {
    KillTimer(m_idBlink);
    CDialogEx::OnDestroy();
}

// 처리기
BEGIN_MESSAGE_MAP(CMainDlg, CDialogEx)
    ON_WM_TIMER()
END_MESSAGE_MAP()

void CMainDlg::OnTimer(UINT_PTR id) {
    if (id == m_idBlink) {
        // UI 갱신: 깜빡이는 아이콘 등
        Invalidate(FALSE);
    } else {
        CDialogEx::OnTimer(id);
    }
}
```

**특징**
- 메시지 루프가 **바쁠 때 지연** 가능(밀림).
- **스레드 안전**: 타이머 콜백은 **해당 윈도우의 UI 스레드** 컨텍스트에서 `WM_TIMER`로 들어온다.
- **정밀도**: 일반적으로 수십 ms 이상의 지터. **정밀한 시각**엔 부적합.
- **장점**: 간단/안전/메시지 기반 UI 동기화 불필요.

**팁**
- **많은 타이머**를 하나의 `WM_TIMER`로 묶고, 내부에서 차등 스케줄링(예: next due time 계산)하면 **WM_TIMER 폭주** 방지.
- 비싼 작업은 **PostMessage로 Worker에 위임**하고, UI는 진행률/상태만 갱신.

---

## Waitable Timer — 대기 가능한 고정밀 예약

### 2-1. 절대/상대 예약 & 주기 반복

```cpp
// 1) 생성
HANDLE hTimer = CreateWaitableTimerW(nullptr, FALSE/*manual-reset?*/, nullptr);

// 2) 최초 만기 시각 지정: 절대(UTC 기반 FILETIME 100ns) 또는 상대(음수)
LARGE_INTEGER duetime{};
// 상대 2초 뒤: 100ns 단위, 음수 = 상대
duetime.QuadPart = - (LONGLONG)2 * 10'000'000;

// 3) 주기: 밀리초 단위(0이면 1회)
LONG periodMs = 1000;

// 4) APC 콜백은 nullptr(일반 대기 모드)
SetWaitableTimer(hTimer, &duetime, periodMs, nullptr, nullptr, FALSE);

// 5) 대기 (Worker 스레드)
for (;;) {
    DWORD rc = WaitForSingleObject(hTimer, INFINITE);
    if (rc == WAIT_OBJECT_0) {
        // 타임아웃 발생(주기마다)
        DoPeriodicWork();
    }
}
```

**장점**
- **정확한 시각**을 지정 가능(절대/상대).
- **절전(S3)에서 깨어날 시각** 지정(`SetWaitableTimer`의 마지막 `fResume=TRUE`로 허용되는 하드웨어에서 가능).
- **Worker 스레드에서 자연스럽게 대기**, `WaitForMultipleObjects`와 결합 쉬움(취소 이벤트와 OR 대기).

**주의**
- 콜백(APC) 모드로 사용 시 **ALERTABLE 대기**(`WaitForSingleObjectEx(..., TRUE)` 등) 필요.
- **DST/타임존** 고려: 절대 시각(UTC FILETIME)을 써야 안전. “매일 9시”는 **다음 절대 시각**을 계산.

### 모드 예제

```cpp
VOID CALLBACK OnTimerApc(LPVOID, DWORD, DWORD) {
    // APC 컨텍스트에서 실행됨 (주의: 재진입/스레드 컨텍스트)
    DoPeriodicWorkAPC();
}

void StartApcTimer() {
    HANDLE t = CreateWaitableTimerW(nullptr, FALSE, nullptr);
    LARGE_INTEGER dt{}; dt.QuadPart = -10'000'000; // 1초 뒤
    SetWaitableTimer(t, &dt, 1000, &OnTimerApc, nullptr, FALSE);

    for(;;) {
        // APC 실행을 허용해야 콜백이 호출됨
        SleepEx(INFINITE, TRUE); // alertable wait
    }
}
```

---

## — 콜백 기반, 관리 편리

```cpp
HANDLE g_timer = nullptr;
HANDLE g_queue = CreateTimerQueue(); // 공유 큐 (NULL도 가능: 시스템 디폴트)

VOID CALLBACK OnTimerQueue(PVOID ctx, BOOLEAN) {
    auto self = static_cast<MyCtx*>(ctx);
    self->Tick(); // 콜백: 스레드풀 워커에서 실행
}

void StartTimerQueue(MyCtx* c) {
    // due=1000ms, period=500ms, 콜백은 스레드풀 워커 스레드
    CreateTimerQueueTimer(&g_timer, g_queue, OnTimerQueue, c, 1000, 500, WT_EXECUTEDEFAULT);
}

void StopTimerQueue() {
    if (g_timer) {
        // 콜백 종료를 기다리며 삭제
        DeleteTimerQueueTimer(g_queue, g_timer, INVALID_HANDLE_VALUE /*Wait*/);
        g_timer = nullptr;
    }
    if (g_queue) {
        // 큐 내 모든 타이머 제거
        DeleteTimerQueueEx(g_queue, INVALID_HANDLE_VALUE);
        g_queue = nullptr;
    }
}
```

**장점**
- 시작/중지/삭제 패턴이 간단, **다수 타이머**를 하나의 큐로 관리.
- **콜백은 스레드풀** → UI와 분리, CPU 활용에 유리.

**유의**
- 콜백에서 **재진입/중복 실행 방지**(긴 실행 중 다음 틱 진입). 원자 플래그/세마포어/뮤텍스 사용.
- 삭제 시 `DeleteTimerQueueTimer/Ex`의 **대기 핸들**로 종료 안전 확보.

---

## — 고급/고성능

```cpp
PTP_TIMER g_tp = nullptr;
TP_CALLBACK_ENVIRON env;

VOID CALLBACK OnTpTimer(PTP_CALLBACK_INSTANCE, PVOID ctx, PTP_TIMER timer) {
    auto self = static_cast<MyCtx*>(ctx);
    self->Tick(); // 스레드풀에서 실행
}

void StartTpTimer(MyCtx* c) {
    InitializeThreadpoolEnvironment(&env);
    g_tp = CreateThreadpoolTimer(OnTpTimer, c, &env);

    // 최초 만기: 2초 뒤 (FILETIME 100ns, relative는 음수)
    FILETIME ft; ULARGE_INTEGER ui;
    ui.QuadPart = (ULONGLONG)(-2 * 10'000'000LL); // relative
    ft.dwLowDateTime = ui.LowPart; ft.dwHighDateTime = ui.HighPart;

    // 주기: 1000ms, 슬랙: 0(즉시) 또는 TpSetTimer에서 coalescing 슬랙 지정 가능(Win10+)
    SetThreadpoolTimer(g_tp, &ft, 1000, 0);
}

void StopTpTimer() {
    if (g_tp) {
        WaitForThreadpoolTimerCallbacks(g_tp, TRUE); // 콜백 완료 대기
        CloseThreadpoolTimer(g_tp);
        g_tp = nullptr;
        DestroyThreadpoolEnvironment(&env);
    }
}
```

**강점**
- **정밀/대량 타이머**에 적합, 스레드풀의 부하 관리/슬랙(윈도우가 배터리/전력 최적화 위해 타이머 묶기) 옵션.
- **수명 제어 API**가 풍부(대기/취소/클린업).

**주의**
- 콜백 **재진입** 방지 로직(원자 플래그/세마포어) 필요.
- 컨텍스트(객체) **수명 보장**: 종료 시 `WaitForThreadpoolTimerCallbacks` 필수.

---

## 정확도·정밀도·전력 — 현실적인 기대치와 선택

- Windows는 기본적으로 **타이머 분해능**(tick)을 운영체제 전역 정책으로 관리.
- `timeBeginPeriod`로 **글로벌 분해능**을 낮추면 **전체 시스템 전력 소모 증가**, 노트북 배터리에 악영향.
- **대부분의 앱은** 타이머 분해능 조작 없이:
  - UI → `WM_TIMER`
  - 실시간/정밀 주기 → **스레드풀/Waitable**
- 시간 측정/모션 보간은 **`QueryPerformanceCounter`(QPC)** 사용 (단, 타이머 만기와는 별개).

```cpp
LARGE_INTEGER f; QueryPerformanceFrequency(&f);
LARGE_INTEGER t0; QueryPerformanceCounter(&t0);
// ...
LARGE_INTEGER t1; QueryPerformanceCounter(&t1);
double ms = (t1.QuadPart - t0.QuadPart) * 1000.0 / f.QuadPart;
```

---

## 재진입/중복 실행 방지 — 흔한 버그와 패턴

콜백 시간이 주기보다 길면 **오버랩 실행** 가능(특히 타이머 큐/TP).
→ 간단한 **스핀 플래그** 또는 세마포어로 보호.

```cpp
std::atomic<bool> g_busy{false};

void OnTick() {
    bool expected = false;
    if (!g_busy.compare_exchange_strong(expected, true)) {
        // 이미 실행 중 → 중복 실행 건너뜀(혹은 스케줄)
        return;
    }
    // 실제 작업
    DoWork();

    g_busy.store(false);
}
```

또는 **세마포어**로 “동시 실행 1개” 보장:

```cpp
CSemaphore gate(1,1); // MFC
void OnTick() {
    if (gate.Lock(0) != WAIT_OBJECT_0) return; // 이미 실행 중
    __try { DoWork(); } __finally { gate.Unlock(); }
}
```

---

## “매일 09:00에 실행” — 스케줄 패턴(타임존/DST 안전)

**문제**: 단순 `period = 24h`는 **DST 전후**에 23/25시간이 될 수 있음.
**해법**: **매번 다음 절대 시각(UTC)** 을 계산하여 **Waitable/TP 타이머**에 설정.

```cpp
FILETIME LocalTimeToUtcFiletime(SYSTEMTIME local) {
    SYSTEMTIME stUtc{};
    TzSpecificLocalTimeToSystemTime(nullptr, &local, &stUtc);
    FILETIME ftUtc{}; SystemTimeToFileTime(&stUtc, &ftUtc);
    return ftUtc;
}

void ScheduleDaily0900(PTP_TIMER tp) {
    // 1) 로컬 타임으로 다음 09:00 계산
    SYSTEMTIME nowLocal; GetLocalTime(&nowLocal);
    SYSTEMTIME dueLocal = nowLocal;
    dueLocal.wHour = 9; dueLocal.wMinute = 0; dueLocal.wSecond = 0; dueLocal.wMilliseconds = 0;
    if (CompareSystemTime(dueLocal, nowLocal) <= 0) {
        // 오늘 9시 지남 → 내일
        AddDays(dueLocal, 1);
    }

    // 2) UTC FILETIME으로 변환
    FILETIME ftUtc = LocalTimeToUtcFiletime(dueLocal);

    // 3) SetThreadpoolTimer (절대 시각)
    SetThreadpoolTimer(tp, &ftUtc, 0 /*one-shot*/, 60*1000 /*슬랙: 1분 coalescing*/);
}

// 콜백: 실행 후 "다음 09:00" 다시 스케줄
VOID CALLBACK OnDaily(PTP_CALLBACK_INSTANCE, PVOID ctx, PTP_TIMER tp) {
    RunJob();
    ScheduleDaily0900(tp); // 재설정
}
```

**포인트**
- **매회 다음 절대 시각**을 재계산 → DST/월말/윤년 모두 자동 대응.
- **슬랙(coalescing)**을 적절히 주면 배터리/전력에 유리(1~5분 권장, 중요 작업은 0).

---

## 슬립/절전/시계 변경 대응

- 시스템이 **절전(S3)** 에 들어가면 일반 타이머 만기가 **지연**.
- **Resume 타이머**(`SetWaitableTimer(..., fResume=TRUE)`)는 일부 하드웨어에서 **깨움** 가능.
- 깨어난 뒤 **현재 시각**과 **마지막 실행 시각**을 비교하여 **밀린 작업 보정**:

```cpp
void OnWakeOrTick() {
    auto now = NowUtcFileTime();
    if (now - g_lastRun > kMaxSkew) {
        // 장시간 슬립/정체 → 보정(즉시 1회 실행 또는 누락된 N회 처리)
    }
    g_lastRun = now;
}
```

- **시간대/수동 시계 변경** 이벤트는 `WM_TIMECHANGE` (UI 스레드에서 수신) 등으로 캐치 가능 → **다음 스케줄 재계산**.

---

## UI + 타이머 아키텍처 — 끊김 없는 화면/진행률

- UI는 **화면 갱신/애니메이션**만 → `SetTimer/WM_TIMER` (16~33ms 정도)
- 무거운 연산/IO/네트워크는 **Worker/타이머 큐/TP**로.
- Worker → UI는 **`PostMessage`** 로 진행률/상태 보고(동기 `SendMessage` 금지).
- 긴 루프는 **MsgWaitForMultipleObjects**로 UI 펌프와 대기 병행.

```cpp
DWORD PumpWait(HANDLE h, DWORD timeout) {
    for (;;) {
        DWORD rc = MsgWaitForMultipleObjects(1, &h, FALSE, timeout, QS_ALLINPUT);
        if (rc == WAIT_OBJECT_0) return rc;     // 타깃 신호
        if (rc == WAIT_OBJECT_0+1) {
            MSG msg; while (PeekMessage(&msg,nullptr,0,0,PM_REMOVE)) {
                TranslateMessage(&msg); DispatchMessage(&msg);
            }
        } else if (rc == WAIT_TIMEOUT) return rc;
    }
}
```

---

## 안전한 해제/취소 순서 — 흔한 리소스 유출/크래시 방지

### 10-1. 타이머 큐

```cpp
// 올바른 순서
DeleteTimerQueueTimer(queue, timer, INVALID_HANDLE_VALUE); // 콜백 종료 대기
DeleteTimerQueueEx(queue, INVALID_HANDLE_VALUE);
```

### 10-2. TP 타이머

```cpp
SetThreadpoolTimer(tp, nullptr, 0, 0);                   // 중지
WaitForThreadpoolTimerCallbacks(tp, TRUE);               // 콜백 완료 대기
CloseThreadpoolTimer(tp);
```

### 10-3. Waitable

```cpp
CancelWaitableTimer(h);  // 선택 (주기 중지)
CloseHandle(h);
```

**주의**
- 콜백 내부에서 **자신을 파괴**하면 **UAF(Use-After-Free)** 위험.
- “정지 → 콜백 완료 대기 → 핸들 해제”의 **3단계**를 일관되게.

---

## 미니 프레임워크” — 코드 템플릿

### 11-1. 스케줄 표현

```cpp
enum class ScheduleKind { OnceUtc, EveryMs, DailyAtLocal, WeeklyAtLocal };

struct Schedule {
    ScheduleKind kind{};
    FILETIME     onceUtc{};        // OnceUtc
    DWORD        periodMs{};       // EveryMs
    int          dailyHour=0, dailyMin=0; // DailyAtLocal
    int          weeklyDow=1;      // 0=Sun..6=Sat
    int          weeklyHour=0, weeklyMin=0;
};
```

### 11-2. 다음 만기 계산기

```cpp
FILETIME NextDueUtc(const Schedule& s, FILETIME nowUtc);

FILETIME NextDueUtc(const Schedule& s, FILETIME nowUtc) {
    switch (s.kind) {
        case ScheduleKind::OnceUtc:  return s.onceUtc;
        case ScheduleKind::EveryMs: {
            ULARGE_INTEGER n; n.LowPart=nowUtc.dwLowDateTime; n.HighPart=nowUtc.dwHighDateTime;
            n.QuadPart += (ULONGLONG)s.periodMs * 10'000; // ms→100ns
            FILETIME ft{ n.LowPart, n.HighPart }; return ft;
        }
        case ScheduleKind::DailyAtLocal: {
            SYSTEMTIME nowL; FileTimeToSystemTime(&nowUtc, &nowL);
            SYSTEMTIME due = nowL; due.wHour = s.dailyHour; due.wMinute = s.dailyMin; due.wSecond=0; due.wMilliseconds=0;
            if (CompareSystemTime(due, nowL) <= 0) AddDays(due, 1);
            return LocalToUtc(due);
        }
        case ScheduleKind::WeeklyAtLocal: {
            SYSTEMTIME nowL; FileTimeToSystemTime(&nowUtc, &nowL);
            int today = (nowL.wDayOfWeek + 7) % 7;
            int delta = (s.weeklyDow - today + 7) % 7;
            SYSTEMTIME due = nowL; AddDays(due, delta);
            due.wHour=s.weeklyHour; due.wMinute=s.weeklyMin; due.wSecond=0; due.wMilliseconds=0;
            if (delta==0 && CompareSystemTime(due, nowL) <= 0) { AddDays(due, 7); }
            return LocalToUtc(due);
        }
    }
    return nowUtc;
}
```

### 11-3. 실행기(스레드풀 타이머 기반)

```cpp
struct Job {
    Schedule sch;
    std::function<void()> fn;
    PTP_TIMER tp{};
};

void RunJobNowAndReschedule(Job* j) {
    // 실행
    j->fn();
    // 다음 시각 계산
    FILETIME now = NowUtcFileTime();
    FILETIME nxt = NextDueUtc(j->sch, now);
    SetThreadpoolTimer(j->tp, &nxt, (j->sch.kind==ScheduleKind::EveryMs)? j->sch.periodMs : 0, 60'000); // 슬랙=1분
}

VOID CALLBACK OnJob(PTP_CALLBACK_INSTANCE, PVOID ctx, PTP_TIMER tp) {
    Job* j = static_cast<Job*>(ctx);
    RunJobNowAndReschedule(j);
}

void StartJob(Job& j) {
    j.tp = CreateThreadpoolTimer(OnJob, &j, nullptr);
    FILETIME now = NowUtcFileTime();
    FILETIME nxt = NextDueUtc(j.sch, now);
    SetThreadpoolTimer(j.tp, &nxt, (j.sch.kind==ScheduleKind::EveryMs)? j.sch.periodMs : 0, 60'000);
}

void StopJob(Job& j) {
    if (!j.tp) return;
    SetThreadpoolTimer(j.tp, nullptr, 0, 0);
    WaitForThreadpoolTimerCallbacks(j.tp, TRUE);
    CloseThreadpoolTimer(j.tp);
    j.tp = nullptr;
}
```

---

## 실전 팁 모음 (오답노트)

1) **UI 스레드에서 긴 콜백** 금지: `WM_TIMER` 처리에서 파일 IO/DB ↯ → 프리즈
2) **콜백 중복 실행** 방지: 주기보다 긴 작업은 **스킵/큐잉** 정책
3) **해제 순서** 엄격: “중지→콜백 완료 대기→핸들 닫기”
4) **타이머 폭주**: 한 틱에 수백 개 콜백 → **샘플링/배압** 설계(최근 값만 반영)
5) **전역 타이머 분해능 변경** 남용 금지: 배터리 소모 증가
6) **시간 계산은 UTC**: 로컬/DST는 **표시만** 로컬로
7) **절전 이후 보정**: 마지막 실행 시각과 현재 비교, 누락 처리
8) **예외/크래시 격리**: 콜백 내부 예외는 **잡아서 로깅** 후 안전 정리

---

## 디버깅/관찰

- **ETW/WPA**: 타이머 콜백 스케줄/지연 분석
- **로깅**: “예약시각/콜백시각/지연(ms)” 출력
- **현장 재현**: `SetSuspendState`로 슬립 진입/복귀 테스트, `WM_POWERBROADCAST` 처리
- **상태 버튼**: “지금 실행”, “다음 예약 갱신”, “정지/재개” UI 제공

```cpp
void LogTimer(const char* tag, FILETIME dueUtc) {
    SYSTEMTIME l; SystemTimeToTzSpecificLocalTime(nullptr, (SYSTEMTIME*)&dueUtc, &l);
    TRACE("%s next=%04d-%02d-%02d %02d:%02d:%02d\n", tag, l.wYear,l.wMonth,l.wDay,l.wHour,l.wMinute,l.wSecond);
}
```

---

## 보일러플레이트(복붙 세트)

### 14-1. UI 타이머 + 안전 위임

```cpp
void CMainDlg::OnTimer(UINT_PTR id) {
    if (id == 1) {
        // 비싼 일은 Worker로
        ::PostMessage(m_hWorkerWnd, WM_APP_TICK, 0, 0);
        m_prog.StepIt(); // UI만
    }
}
```

### 14-2. Waitable + 취소 이벤트

```cpp
HANDLE hTimer=CreateWaitableTimerW(nullptr,FALSE,nullptr);
HANDLE hCancel=CreateEventW(nullptr,TRUE,FALSE,nullptr);
LARGE_INTEGER dt{}; dt.QuadPart = -5*10'000'000LL; // 5초
SetWaitableTimer(hTimer,&dt,0,nullptr,nullptr,FALSE);

HANDLE hs[2]={hTimer,hCancel};
DWORD rc = WaitForMultipleObjects(2, hs, FALSE, INFINITE);
if (rc==WAIT_OBJECT_0) RunOnce();
```

### 14-3. 타이머 큐 — 주기/정지

```cpp
HANDLE q=CreateTimerQueue(), t=nullptr;
CreateTimerQueueTimer(&t,q,OnTimerQueue,ctx, 1000, 200, WT_EXECUTEDEFAULT);
// ...
DeleteTimerQueueTimer(q,t, INVALID_HANDLE_VALUE); // wait completion
DeleteTimerQueueEx(q, INVALID_HANDLE_VALUE);
```

### 14-4. TP 타이머 — Daily at 09:00

```cpp
PTP_TIMER tp = CreateThreadpoolTimer(OnDaily, ctx, nullptr);
ScheduleDaily0900(tp); // 위에서 정의한 함수
```

---

## FAQ

**Q. `SetTimer` 정확도가 부족해 보여요.**
A. UI 타이머는 메시지 루프 상태에 좌우됩니다. **Waitable/TP**로 옮기세요. UI는 결과만 반영.

**Q. 절전에서 깨어났더니 작업이 누락됐어요.**
A. 깨어난 시점에 **마지막 실행 시각**과 비교해 **보정**(즉시 1회 실행 또는 누락분 처리)하십시오.

**Q. 멀티미디어 타이머는 안 쓰나요?**
A. 시스템 전역 타이머 분해능을 낮춰 **전력 소모/발열**을 유발합니다. 특별한 실시간 요구(오디오 드라이버 등) 외에는 **지양**.

**Q. 10만 개 타이머가 필요해요.**
A. 개별 타이머 대신 **우선순위 힙 기반 시뮬레이터**(단일 타이머 + 다중 작업 스케줄)로 구현하세요.

---

## 최종 체크리스트

- [ ] UI는 `WM_TIMER`로 가볍게, **무거운 일은 Worker로 위임**
- [ ] **Waitable/TP/Timer Queue** 중 용도에 맞는 것을 선택
- [ ] 콜백 **재진입 방지**(원자 플래그/세마포어)
- [ ] **중지→콜백 완료 대기→핸들 닫기** 순서
- [ ] **UTC 기준 절대 시각**으로 스케줄, **다음 시각 재계산**
- [ ] **슬립/타임체인지** 후 **보정 로직**
- [ ] **전역 타이머 분해능 변경 지양**, 불가피하면 범위 최소/종료 시 복원
- [ ] **로깅**: 예약/실행/지연/오류 기록

---

### 마무리

타이머와 스케줄링은 **앱의 반응성/전력/신뢰성**을 좌우합니다.
**UI는 가볍게, 작업은 Worker로**, **UTC 절대 시각 기반 재스케줄**, **정지/해제 안전성**만 지키면
복잡한 반복/예약 요구도 **예측 가능하고 테스트 가능한** 구조로 안정적으로 구현할 수 있습니다.
