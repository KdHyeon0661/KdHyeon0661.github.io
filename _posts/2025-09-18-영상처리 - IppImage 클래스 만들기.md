---
layout: post
title: 영상처리 - IppImage 클래스
date: 2025-09-18 15:25:23 +0900
category: 영상처리
---
# IppImage 템플릿·RGBBYTE·IppDib 상호 변환·화면 출력

---

## 4.1 | IppImage 클래스 만들기: 요구사항 정리

**설계 포인트**
- **템플릿**: `IppImage<T, C>` — T: 샘플형(예: `uint8_t`, `uint16_t`, `float`), C: 채널 수(1/3/4)  
- **내부 규약**: Top-Down(행 증가 == y 증가), `strideBytes >= width * C * sizeof(T)`  
- **정렬(Align)**: 기본 32바이트 정렬(AVX2 친화), 필요 시 인자 변경  
- **ROI 뷰**: 비소유 참조 뷰(IppImageView)  
- **픽셀 접근**: `rowp(y)`, `ptr(x,y)`, `operator()(x,y,c)`  
- **유틸**: `fill`, `invert(정수형만)`, `linear(α·β)`, `infoString`, 비교/크기 맞추기 등  
- **연산자 재정의**: `operator bool`, `operator==`, 이동/복사 의미

**Stride 공식**

- 너비 \(W\), 채널 \(C\), 샘플 크기 \(S=\text{sizeof}(T)\), 정렬 \(A\) (바이트)일 때,
  
  $$
  \text{raw} = W \times C \times S,\qquad
  \text{stride} = \left\lceil \frac{\text{raw}}{A} \right\rceil \times A
  $$

---

## 4.2 | IppImage 클래스 추가(헤더·구현)

### 4.2.1 헤더: `IppImage.h`

```cpp
#pragma once
#include <cstdint>
#include <vector>
#include <string>
#include <type_traits>
#include <stdexcept>
#include <cstring>
#include <algorithm>
#include <cassert>

template<typename T, int C>
class IppImageView;

template<typename T, int C>
class IppImage {
    static_assert(C==1 || C==3 || C==4, "IppImage: channels must be 1/3/4");
public:
    using value_type = T;
    static constexpr int kChannels = C;

    IppImage() = default;
    IppImage(int w, int h, int alignBytes = 32) { create(w, h, alignBytes); }

    // 상태
    bool empty() const noexcept { return width_<=0 || height_<=0 || stride_<=0 || buf_.empty(); }
    explicit operator bool() const noexcept { return !empty(); }
    int  width()  const noexcept { return width_;  }
    int  height() const noexcept { return height_; }
    int  stride() const noexcept { return stride_; }              // bytes per row
    int  bytesPerPixel() const noexcept { return sizeof(T) * C; }
    T*       data()       noexcept { return reinterpret_cast<T*>(buf_.data()); }
    const T* data() const noexcept { return reinterpret_cast<const T*>(buf_.data()); }

    // 생성/소멸/리셋
    void create(int w, int h, int alignBytes = 32);
    void clear() { IppImage tmp; swap(tmp); }
    void swap(IppImage& o) noexcept {
        std::swap(width_, o.width_); std::swap(height_, o.height_);
        std::swap(stride_, o.stride_); buf_.swap(o.buf_);
    }

    // 행 포인터/픽셀 포인터
    T*       rowp(int y)       noexcept { return reinterpret_cast<T*>(buf_.data() + (size_t)y * stride_); }
    const T* rowp(int y) const noexcept { return reinterpret_cast<const T*>(buf_.data() + (size_t)y * stride_); }
    T*       ptr(int x, int y)       noexcept { return rowp(y) + (size_t)x * C; }
    const T* ptr(int x, int y) const noexcept { return rowp(y) + (size_t)x * C; }

    // 채널 단위 접근
    T&       operator()(int x, int y, int ch=0)       { assert(0<=ch && ch<C); return ptr(x,y)[ch]; }
    const T& operator()(int x, int y, int ch=0) const { assert(0<=ch && ch<C); return ptr(x,y)[ch]; }

    // ROI (비소유 뷰)
    IppImageView<T,C> roi(int x, int y, int w, int h);

    // 유틸
    void fill(const T (&v)[C]);        // 채널별 상수 채우기
    void fill(T scalar);               // Gray/전채널 동일 값
    void invert();                     // 정수형만: v -> max - v
    void linear(float a, float b);     // g = clamp(a*f + b)

    // 기타
    std::string infoString() const;
    bool sameShape(const IppImage& rhs) const noexcept { return width_==rhs.width_ && height_==rhs.height_ && bytesPerPixel()==rhs.bytesPerPixel(); }

    // 비교/대입(기본)
    bool operator==(const IppImage& rhs) const noexcept {
        return sameShape(rhs) && stride_==rhs.stride_ && buf_==rhs.buf_;
    }
    bool operator!=(const IppImage& rhs) const noexcept { return !(*this==rhs); }

private:
    int width_ = 0, height_ = 0;
    int stride_ = 0;
    std::vector<uint8_t> buf_;
};

// ===== IppImageView (비소유) =====
template<typename T, int C>
class IppImageView {
public:
    IppImageView() = default;
    IppImageView(int w,int h,int strideBytes,T* base)
        : w_(w), h_(h), stride_(strideBytes), base_(base) {}

    bool empty() const noexcept { return !base_ || w_<=0 || h_<=0; }
    int  width()  const noexcept { return w_; }
    int  height() const noexcept { return h_; }
    int  stride() const noexcept { return stride_; }
    T*       rowp(int y)       noexcept { return reinterpret_cast<T*>(reinterpret_cast<uint8_t*>(base_) + (size_t)y*stride_); }
    const T* rowp(int y) const noexcept { return reinterpret_cast<const T*>(reinterpret_cast<const uint8_t*>(base_) + (size_t)y*stride_); }
    T*       ptr(int x,int y)       noexcept { return rowp(y) + (size_t)x*C; }
    const T* ptr(int x,int y) const noexcept { return rowp(y) + (size_t)x*C; }
    T&       operator()(int x,int y,int ch=0)       { return ptr(x,y)[ch]; }
    const T& operator()(int x,int y,int ch=0) const { return ptr(x,y)[ch]; }
private:
    int w_=0, h_=0, stride_=0;
    T*  base_=nullptr;
};

template<typename T, int C>
inline IppImageView<T,C> IppImage<T,C>::roi(int x, int y, int w, int h) {
    if (x<0 || y<0 || x+w>width_ || y+h>height_) throw std::runtime_error("roi: out of bounds");
    return IppImageView<T,C>(w,h, stride_, ptr(x,y));
}
```

### 4.2.2 구현: `IppImage.cpp`

```cpp
#include "IppImage.h"
#include <cmath>

static inline int aligned_stride_bytes(size_t width, int channels, size_t elemSize, int alignBytes) {
    const size_t raw = width * channels * elemSize;
    const int rem = (int)(raw % alignBytes);
    return rem ? (int)(raw + (alignBytes - rem)) : (int)raw;
}

template<typename T, int C>
void IppImage<T,C>::create(int w, int h, int alignBytes) {
    if (w<=0 || h<=0) throw std::runtime_error("IppImage::create: invalid size");
    width_ = w; height_ = h;
    stride_ = aligned_stride_bytes((size_t)w, C, sizeof(T), alignBytes);
    buf_.assign((size_t)stride_ * h, 0);
}

template<typename T, int C>
void IppImage<T,C>::fill(const T (&v)[C]) {
    if (empty()) return;
    for (int y=0;y<height_;++y) {
        T* r = rowp(y);
        for (int x=0;x<width_;++x) {
            for (int ch=0; ch<C; ++ch) r[x*C + ch] = v[ch];
        }
    }
}

template<typename T, int C>
void IppImage<T,C>::fill(T scalar) {
    if constexpr (C==1) {
        for (int y=0;y<height_;++y) std::fill_n(rowp(y), width_, scalar);
    } else {
        T v[C]; for (int i=0;i<C;++i) v[i]=scalar; fill(v);
    }
}

template<typename T, int C>
void IppImage<T,C>::invert() {
    if (empty()) return;
    static_assert(std::is_integral<T>::value, "invert requires integral T");
    const T maxv = std::numeric_limits<T>::is_signed ? (T)((1u<< (sizeof(T)*8-1)) - 1) : (T)std::numeric_limits<T>::max();
    // 실제 영상에서는 8/16-bit unsigned가 일반적 → 그 경우 maxv=255/65535
    for (int y=0;y<height_;++y) {
        T* r = rowp(y);
        for (int x=0;x<width_*C;++x) r[x] = (T)(maxv - r[x]);
    }
}

template<typename T, int C>
static inline T clamp_cast(float v) {
    if constexpr (std::is_floating_point<T>::value) return (T)v;
    else {
        float lo = (float)std::numeric_limits<T>::min();
        float hi = (float)std::numeric_limits<T>::max();
        if (v < lo) v = lo; if (v > hi) v = hi;
        return (T)std::lrintf(v);
    }
}

template<typename T, int C>
void IppImage<T,C>::linear(float a, float b) {
    if (empty()) return;
    for (int y=0;y<height_;++y) {
        T* r = rowp(y);
        for (int i=0;i<width_*C;++i) {
            r[i] = clamp_cast<T,C>(a * (float)r[i] + b);
        }
    }
}

template<typename T, int C>
std::string IppImage<T,C>::infoString() const {
    char s[128];
    snprintf(s, sizeof(s), "%dx%d, stride=%d, elem=%zu, channels=%d",
             width_, height_, stride_, sizeof(T), C);
    return std::string(s);
}

// --- 명시적 인스턴스화(보통 .cpp에서) ---
template class IppImage<uint8_t,1>;
template class IppImage<uint8_t,3>;
template class IppImage<uint8_t,4>;
template class IppImage<uint16_t,1>;
template class IppImage<float,1>;
```

> **주의**: 템플릿 정의/구현을 한 파일에 두거나, `.tpp` 포함 방식으로 정리해도 됩니다. 여기서는 간결성을 위해 `.cpp`에 명시적 인스턴스화 예시를 넣었습니다.

---

## 4.3 | 기타 유용한 기능

- **연산자/비교**: `operator bool`, `operator==`, `sameShape`  
- **정보 제공**: `infoString()`으로 폭/높이/stride/자료형 정보를 문자열로 반환  
- **ROI**: `roi(x,y,w,h)`로 **복사 없이** 부분 영역 뷰 생성

작은 예:

```cpp
#include "IppImage.h"

using Gray8  = IppImage<uint8_t,1>;
using BGR24  = IppImage<uint8_t,3>;
using BGRA32 = IppImage<uint8_t,4>;

void example_basic() {
    Gray8 img(640,480);
    img.fill((uint8_t)128);
    img.linear(1.2f, -10.f);
    auto sub = img.roi(100,100, 200,150);
    sub(0,0) = 255; // ROI에 직접 쓰기
}
```

---

## 4.3.1 | RGBBYTE 클래스 정의

Windows/GDI와의 호환성을 고려해 **B, G, R** 순서의 3채널 구조체를 제공합니다.  
(템플릿 `IppImage<uint8_t,3>`는 **interleaved** B,G,R로 이미 적합하지만, 명시적 타입이 더 읽기 좋을 때가 있습니다.)

```cpp
#pragma once
#include <cstdint>

struct RGBBYTE {
    uint8_t b{0}, g{0}, r{0};
    RGBBYTE() = default;
    RGBBYTE(uint8_t _r, uint8_t _g, uint8_t _b) : b(_b), g(_g), r(_r) {}
    static RGBBYTE Gray(uint8_t v) { return RGBBYTE(v, v, v); }
};
```

> 필요하다면 `IppImage<RGBBYTE,1>` 같은 **구조체 기반** 템플릿으로도 설계할 수 있습니다.  
> 본 글에서는 **간단성**을 위해 `IppImage<uint8_t,3>`(BGR)로 진행하고, `RGBBYTE`는 **헬퍼/명시 타입**으로 사용합니다.

---

## 4.4 | IppDib와 IppImage 클래스 상호 변환

### 4.4.1 변환 정책

- **IppImage → IppDib** : 내부 표현을 **BGRA32 Top-Down**으로 변환해 `IppDib.update()` 또는 직접 복사  
- **IppDib → IppImage** : BGRA32에서 목적 포맷(Gray8/BGR24/BGRA32)으로 변환  
- **감마/가중치**: Gray 변환은 BT.601 \( Y = 0.299R + 0.587G + 0.114B \)

### 4.4.2 변환 인터페이스(헤더): `IppInterOp.h`

```cpp
#pragma once
#include "IppImage.h"
#include "IppDib.h"

// 별칭
using Gray8  = IppImage<uint8_t,1>;
using BGR24  = IppImage<uint8_t,3>;
using BGRA32 = IppImage<uint8_t,4>;

// IppImage -> IppDib
bool ToIppDib(const Gray8&  src, IppDib& dst, HDC refDC=nullptr);
bool ToIppDib(const BGR24&  src, IppDib& dst, HDC refDC=nullptr);
bool ToIppDib(const BGRA32& src, IppDib& dst, HDC refDC=nullptr);

// IppDib -> IppImage
bool FromIppDib(const IppDib& src, Gray8&  dst);
bool FromIppDib(const IppDib& src, BGR24&  dst);
bool FromIppDib(const IppDib& src, BGRA32& dst);
```

### 4.4.3 변환 구현: `IppInterOp.cpp`

```cpp
#include "IppInterOp.h"
#include <cmath>

static inline uint8_t clamp_u8(int v){ if(v<0) return 0; if(v>255) return 255; return (uint8_t)v; }

bool ToIppDib(const Gray8& src, IppDib& dst, HDC refDC) {
    if (!src) return false;
    if (!dst.create(refDC, src.width(), src.height(), true)) return false;
    for (int y=0;y<src.height();++y) {
        const uint8_t* s = src.rowp(y);
        auto* drow = (uint8_t*)dst.bits() + (size_t)y * dst.stride();
        for (int x=0;x<src.width();++x) {
            uint8_t g = s[x];
            uint8_t* p = &drow[x*4];
            p[0]=g; p[1]=g; p[2]=g; p[3]=255;
        }
    }
    return true;
}

bool ToIppDib(const BGR24& src, IppDib& dst, HDC refDC) {
    if (!src) return false;
    if (!dst.create(refDC, src.width(), src.height(), true)) return false;
    for (int y=0;y<src.height();++y) {
        const uint8_t* s = reinterpret_cast<const uint8_t*>(src.rowp(y));
        auto* drow = (uint8_t*)dst.bits() + (size_t)y * dst.stride();
        for (int x=0;x<src.width();++x) {
            const uint8_t* q = &s[x*3];
            uint8_t* p = &drow[x*4];
            p[0]=q[0]; p[1]=q[1]; p[2]=q[2]; p[3]=255;
        }
    }
    return true;
}

bool ToIppDib(const BGRA32& src, IppDib& dst, HDC refDC) {
    if (!src) return false;
    if (!dst.create(refDC, src.width(), src.height(), true)) return false;
    for (int y=0;y<src.height();++y) {
        const uint8_t* s = reinterpret_cast<const uint8_t*>(src.rowp(y));
        std::memcpy((uint8_t*)dst.bits() + (size_t)y*dst.stride(), s, (size_t)src.width()*4);
    }
    return true;
}

bool FromIppDib(const IppDib& src, Gray8& dst) {
    if (!src) return false;
    dst.create(src.width(), src.height());
    for (int y=0;y<src.height();++y) {
        const uint8_t* s = (const uint8_t*)src.bits() + (size_t)y*src.stride();
        uint8_t* d = dst.rowp(y);
        for (int x=0;x<src.width();++x) {
            const uint8_t* p = &s[x*4];
            int Y = int(0.299f*p[2] + 0.587f*p[1] + 0.114f*p[0] + 0.5f);
            d[x] = clamp_u8(Y);
        }
    }
    return true;
}

bool FromIppDib(const IppDib& src, BGR24& dst) {
    if (!src) return false;
    dst.create(src.width(), src.height());
    for (int y=0;y<src.height();++y) {
        const uint8_t* s = (const uint8_t*)src.bits() + (size_t)y*src.stride();
        uint8_t* d = reinterpret_cast<uint8_t*>(dst.rowp(y));
        for (int x=0;x<src.width();++x) {
            const uint8_t* p = &s[x*4];
            d[x*3+0]=p[0]; d[x*3+1]=p[1]; d[x*3+2]=p[2];
        }
    }
    return true;
}

bool FromIppDib(const IppDib& src, BGRA32& dst) {
    if (!src) return false;
    dst.create(src.width(), src.height());
    for (int y=0;y<src.height();++y) {
        const uint8_t* s = (const uint8_t*)src.bits() + (size_t)y*src.stride();
        uint8_t* d = reinterpret_cast<uint8_t*>(dst.rowp(y));
        std::memcpy(d, s, (size_t)src.width()*4);
    }
    return true;
}
```

---

## 4.5 | IppDib 클래스 사용하기 — BMP 파일 화면 출력

아래는 **최소 Win32 코드**로, `IppDib`을 이용해 BMP 파일을 **열고(드래그&드롭 / Ctrl+O)** **화면에 스케일링 출력**합니다.  
(앞 장의 `IppDib` 구현이 프로젝트에 포함되어 있어야 합니다.)

```cpp
#include <windows.h>
#include <commdlg.h>
#include <shellapi.h>
#include "IppDib.h"
#include "IppInterOp.h"

static HINSTANCE g_hInst;
static HWND      g_hWnd;
static IppDib    g_dib;

static void ShowError(const wchar_t* m){ MessageBoxW(g_hWnd,m,L"Error",MB_ICONERROR); }

static bool OpenBmp(std::wstring& out) {
    wchar_t buf[MAX_PATH]=L"";
    OPENFILENAMEW ofn{ sizeof(ofn) };
    ofn.hwndOwner=g_hWnd;
    ofn.lpstrFilter=L"BMP files (*.bmp)\0*.bmp\0";
    ofn.lpstrFile=buf; ofn.nMaxFile=MAX_PATH; ofn.Flags=OFN_FILEMUSTEXIST;
    ofn.lpstrTitle=L"Open BMP";
    if (GetOpenFileNameW(&ofn)) { out=buf; return true; }
    return false;
}

static void OnPaint(HWND h) {
    PAINTSTRUCT ps; HDC dc=BeginPaint(h,&ps);
    RECT rc; GetClientRect(h,&rc);
    if (g_dib) {
        // 비율 유지 레터박스
        double sx=(double)(rc.right-rc.left)/g_dib.width();
        double sy=(double)(rc.bottom-rc.top)/g_dib.height();
        double s = min(sx,sy);
        int dw=(int)(g_dib.width()*s), dh=(int)(g_dib.height()*s);
        RECT dst{ rc.left+(rc.right-rc.left-dw)/2, rc.top+(rc.bottom-rc.top-dh)/2,
                  0,0 }; dst.right=dst.left+dw; dst.bottom=dst.top+dh;
        g_dib.draw(dc, dst, SRCCOPY, HALFTONE);
    } else {
        const wchar_t* t=L"Ctrl+O 로 BMP 열기 / 이미지 드롭";
        TextOutW(dc, 10,10, t, lstrlenW(t));
    }
    EndPaint(h,&ps);
}

static void LoadAndShow(const std::wstring& path) {
    if (!g_dib.loadBMP(path)) ShowError(L"Load BMP failed");
    InvalidateRect(g_hWnd,nullptr,FALSE);
}

static void OnDropFiles(HDROP hDrop){
    wchar_t path[MAX_PATH]; DragQueryFileW(hDrop,0,path,MAX_PATH); DragFinish(hDrop);
    LoadAndShow(path);
}

static LRESULT CALLBACK WndProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    switch(m){
    case WM_CREATE: DragAcceptFiles(h, TRUE); return 0;
    case WM_PAINT:  OnPaint(h); return 0;
    case WM_DROPFILES: OnDropFiles((HDROP)w); return 0;
    case WM_KEYDOWN:
        if ((GetKeyState(VK_CONTROL)&0x8000) && w=='O') {
            std::wstring p; if (OpenBmp(p)) LoadAndShow(p); return 0;
        }
        if ((GetKeyState(VK_CONTROL)&0x8000) && w=='C') { g_dib.copyToClipboard(h); return 0; }
        if ((GetKeyState(VK_CONTROL)&0x8000) && w=='V') { if (g_dib.pasteFromClipboard(h)) InvalidateRect(h,nullptr,FALSE); return 0; }
        return 0;
    case WM_DESTROY: PostQuitMessage(0); return 0;
    default: return DefWindowProcW(h,m,w,l);
    }
}

int APIENTRY wWinMain(HINSTANCE hi,HINSTANCE,LPWSTR,int nCmdShow){
    g_hInst=hi;
    const wchar_t* CN=L"IppDibViewer";
    WNDCLASSEXW wc{ sizeof(wc) }; wc.lpfnWndProc=WndProc; wc.hInstance=hi; wc.hCursor=LoadCursor(nullptr,IDC_ARROW);
    wc.hbrBackground=(HBRUSH)(COLOR_WINDOW+1); wc.lpszClassName=CN;
    if (!RegisterClassExW(&wc)) return 0;
    g_hWnd=CreateWindowExW(0, CN, L"IppDib BMP Viewer", WS_OVERLAPPEDWINDOW|WS_VISIBLE,
                           CW_USEDEFAULT,CW_USEDEFAULT, 1024,768, nullptr,nullptr,hi,nullptr);
    if (!g_hWnd) return 0;
    ShowWindow(g_hWnd,nCmdShow); UpdateWindow(g_hWnd);
    MSG msg{}; while (GetMessageW(&msg,nullptr,0,0)){ TranslateMessage(&msg); DispatchMessageW(&msg); }
    return (int)msg.wParam;
}
```

---

## 4.6 | IppImage ←→ IppDib: 한 번에 확인하는 통합 예제

- **1)** Gray8 테스트 영상 생성 → **2)** `ToIppDib`으로 화면 출력 → **3)** `FromIppDib`으로 회수해 연산

```cpp
#include "IppImage.h"
#include "IppInterOp.h"
#include <cmath>

using Gray8 = IppImage<uint8_t,1>;

static Gray8 MakeDemo(int w,int h) {
    Gray8 img(w,h);
    for (int y=0;y<h;++y){
        uint8_t* r = img.rowp(y);
        for (int x=0;x<w;++x) {
            int checker = ((x/32) ^ (y/32)) & 1;
            float dx=x-w*0.5f, dy=y-h*0.5f;
            float rad = sqrtf(dx*dx+dy*dy);
            int g = (checker?200:80) + (int)std::lrintf(55.0f * cosf(rad*0.05f));
            r[x] = (uint8_t)std::clamp(g,0,255);
        }
    }
    return img;
}

void demo_interop(HWND hwnd) {
    Gray8 g = MakeDemo(640,480);
    IppDib dib;
    ToIppDib(g, dib, GetDC(hwnd));      // Gray8 → BGRA32
    dib.invert();                       // DIB에서 반전
    Gray8 back;
    FromIppDib(dib, back);              // 다시 Gray8로
    (void)back;                         // 이후 저장/처리 등
}
```

---

## 4.7 | 디버깅·안정성 체크리스트

- [ ] `stride` 정렬이 **요구 정렬**을 만족하는가? (`aligned_stride_bytes`)  
- [ ] `roi` 인수 범위 검사  
- [ ] `invert`는 **정수형**에서만 사용(템플릿 제약)  
- [ ] Gray 변환의 **채널 순서**(BGR) 착각 금지  
- [ ] IppDib은 **Top-Down BGRA32** — 파일 저장/클립보드 `CF_DIB`(Bottom-Up) 시 변환  
- [ ] 큰 영상에서 `(size_t)width*channels*sizeof(T)` **곱셈 오버플로** 주의

---

## 4.8 | 성능 팁

1. **정렬 32B** 유지: AVX2/AVX-512 로드/스토어 효율 증가  
2. **행 단위 병렬화**(OpenMP/TBB)로 `fill/linear/convert` 가속  
3. **타일링**: 캐시 지역성 향상을 위한 블록 처리  
4. **프리멀티플라이**: 알파 합성이 잦다면 한 번만 전처리  
5. **HALFTONE vs COLORONCOLOR**: UI에서 품질/속도 균형 선택

---

## 4.9 | 요약

- **IppImage<T,C>**: 템플릿 기반 영상 컨테이너(Top-Down, stride, ROI, 연산 포함)  
- **RGBBYTE**: 가독성 높은 BGR 3채널 구조체 헬퍼  
- **IppDib ⇄ IppImage 변환**: BGRA32 표준화로 출력/교환 경로 단순화  
- **IppDib 활용**: BMP 로드·출력, 클립보드 복사/붙여넣기까지 손쉽게