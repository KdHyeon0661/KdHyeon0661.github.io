---
layout: post
title: 컴퓨터시스템 - 네트워크
date: 2025-09-05 22:20:23 +0900
category: 컴퓨터시스템
---
# 네트워크(Network)

## 한눈에 보는 큰 그림

```
App (HTTP/gRPC/MQTT/DB) ──[TLS/QUIC/TCP/UDP]── 전송
                 └───[DNS]── 이름→IP
                      │
         인터넷(라우팅: BGP/OSPF/IS-IS, NAT/Anycast, CDN)
                      │
   링크(이더넷/Wi-Fi, VLAN/VXLAN, ARP/ND, 스위치/브리지)
                      │
                물리(UTP/Fiber/RF)
```

- **호스트**(OS, 프로세스) ↔ **NIC**(링크) ↔ **스위치**(L2) ↔ **라우터**(L3) ↔ **인터넷**
- 캡슐화/역캡슐화로 **프레임↔패킷↔세그먼트/데이터그램↔페이로드**가 오간다.

---

## 네트워크의 개념과 요소

### 핵심 요소 표

| 구성 요소 | 역할 | 예시/프로토콜 |
|---|---|---|
| 호스트(Host) | 송·수신, 애플리케이션 실행 | 서버, PC, 모바일, IoT |
| NIC | 호스트↔매체 인터페이스 | 1/10/25/40/100G 이더넷, Wi-Fi 6/7 |
| 스위치 | L2 프레임 스위칭/브리지 | VLAN(802.1Q), STP/RSTP, LACP |
| 라우터 | L3 경로 선택/포워딩 | OSPF/IS-IS, BGP, ECMP |
| 보안/중계 | 정책·분산·WAF/DDoS | 방화벽, 로드밸런서, CDN, 프록시 |
| 매체 | 전송로 | UTP, 광(싱글/멀티), 무선 |

### 물리/토폴로지

- **유선**: 스타(스위치 중심), 리프-스파인(DC), 링(특수)
- **무선**: CSMA/CA, BSS/ESS, AP-Roaming, OFDMA(MU), MIMO, 6GHz(6E), 320MHz 채널(Wi-Fi 7)

---

## 네트워크의 분류

| 분류 | 범위 | 예 |
|---|---|---|
| PAN | 개인 | BLE, 테더링 |
| LAN | 건물/층 | 사내 이더넷 |
| MAN | 도시 | 메트로 이더넷 |
| WAN | 국가/대륙 | ISP/백본, 인터넷 |

**연결 방식**: 유선(이더넷/파이버) / 무선(Wi-Fi/5G/위성)

---

## 계층 모델 — OSI 7 vs TCP/IP 4

### OSI 7계층

| 계층 | 역할 | 대표 예시 |
|---|---|---|
| 7 응용 | 사용자 서비스 | HTTP, SMTP, FTP |
| 6 표현 | 포맷/압축/암복호 | TLS(암호화), JPEG |
| 5 세션 | 연결 관리 | RPC 세션, gRPC 스트림 |
| 4 전송 | 종단간 전송 | **TCP**, **UDP**, QUIC(전송+보안 통합) |
| 3 네트워크 | 라우팅/논리주소 | **IP**, ICMP |
| 2 데이터링크 | 프레임/MAC | **Ethernet**, **Wi-Fi**, VLAN |
| 1 물리 | 비트 전송 | 케이블/파이버/RF |

### TCP/IP 4계층 매핑

| TCP/IP | OSI 대응 | 예시 |
|---|---|---|
| 응용 | 5~7 | HTTP/2·3, DNS, gRPC, MQTT |
| 전송 | 4 | TCP/UDP, QUIC |
| 인터넷 | 3 | IP, ICMP |
| 네트워크 액세스 | 1~2 | Ethernet/Wi-Fi, ARP/ND |

**PDU 이름**: L2=Frame, L3=Packet, L4=Segment(TCP)/Datagram(UDP)

---

## 주소 체계 — MAC, IPv4/IPv6, CIDR

### MAC 주소

- 48비트(EUI-48), NIC 고유. 스위치는 **MAC 학습**으로 포워딩.

### IPv4/IPv6 + CIDR

- IPv4: 32비트, CIDR로 가변길이 서브넷 `/n`
- IPv6: 128비트, 전역 유니캐스트 `2000::/3`, **ULA `fc00::/7`**, 링크로컬 `fe80::/10`

**서브넷 호스트 수(IPv4)**
$$ N_{\text{host}} \approx 2^{(32-\text{prefix})} $$

### 사설/특수 범위(요약)

- IPv4 **사설**: `10/8`, `172.16/12`, `192.168/16`
- **CGNAT**: `100.64/10` (통신사 NAT)
- IPv6 **ULA**: `fc00::/7`, **Loopback**: `::1`

### 주소 할당

- DHCPv4, SLAAC(RA)·DHCPv6, 수동
- IPv6 **프라이버시 확장**(임시 주소)로 추적 저감

---

## 이더넷·스위칭(L2) — VLAN/링크 집계/STP

- **VLAN(802.1Q)**: 논리 분리(Access/Trunk), 태그 VLAN ID(12bit)
- **LACP(802.1AX)**: 링크 집계(대역폭/리던던시)
- **STP/RSTP**: 루프 방지. DC는 **Leaf-Spine + ECMP**로 L3 CLOS 선호
- **ARP/ND**: IPv4 ARP, IPv6 Neighbor Discovery

---

## 라우팅(L3) — IGP/EGP, NAT, Anycast

### 정적/동적 라우팅

- **IGP**: OSPF, IS-IS(링크상태) / RIP(거리벡터)
- **ECMP**: 동가경로 부하분산(해시 기반)

### BGP(AS 경계, 인터넷)

- **ASN** 식별, 정책 기반 경로 선택, 인터넷 전역 라우팅 테이블
- **Anycast**: 같은 IP를 여러 POP에서 광고 ⇒ 가까운 POP로 유도(CDN, DNS)

### NAT

- PAT(Overload), Static NAT, **CGNAT**
- 포트 포워딩, Hairpin NAT, NAT-Traversal(STUN/TURN/ICE)

---

## 전송 — TCP/UDP/QUIC, 혼잡제어·핸드셰이크

### TCP

- **3-Way Handshake**: SYN → SYN/ACK → ACK
- **흐름제어**: 윈도우(수신 버퍼)
- **혼잡제어**: Reno/NewReno, **CUBIC(리눅스 기본)**, **BBR(지연 기반)**
- **RTT/재전송**: RTO, SACK
- **TFO**(Fast Open), **TLS 1.3**와 결합 시 1-RTT 핸드셰이크

**대역폭-지연곱(BDP)**
$$ \text{BDP} = \text{대역폭} \times \text{RTT} $$
예) 1 Gbps × 100 ms ≈ 12.5 MB ⇒ 이 정도 *in-flight* 데이터가 있어야 선로 포화

### UDP

- 비연결/비신뢰, 실시간·스트리밍·DNS, 자체 재전송/순서제어 필요

### QUIC(UDP 기반 전송+보안, HTTP/3의 기반)

- **0-RTT/1-RTT** 핸드셰이크, 커넥션 마이그레이션, HOLB 최소화(스트림 멀티플렉싱)
- HTTP/2의 헤더 압축(HPACK) → **QPACK**(HTTP/3)

---

## 애플리케이션 — HTTP, DNS, 메일, 메시징

### HTTP

- **1.1**: 지속연결/파이프라이닝(실전 한계)
- **2**: 단일 TCP 연결 멀티플렉스, 헤더 압축(HPACK), 서버푸시
- **3**: QUIC 위에서 멀티플렉스/QPACK, DSCP/혼잡제어 활용

### DNS

- **재귀/권한/캐시** 구조, 레코드: A/AAAA/CNAME/NS/TXT/MX/SRV
- **DNSSEC**(서명 검증), **DoT/DoH**(암호화)
- **역방향(PTR)**: IP→이름, 메일 신뢰에 중요

### 메시징/IoT

- MQTT, AMQP, WebSocket(SOCKS/프록시 고려)

---

## 무선 — Wi-Fi 6/6E/7, 5G

### Wi-Fi

- **802.11ax(6/6E)**: OFDMA, TWT, BSS Coloring, 6GHz 대역(6E)
- **802.11be(Wi-Fi 7)**: 320MHz 채널, MLO(다중 링크)
- **CSMA/CA**, Hidden/Exposed 노드, RTS/CTS

### 5G

- NSA/SA, UPF/AMF, 슬라이싱, URLLC/eMBB/mMTC
- **IPv6-only + NAT64/DNS64** 흔함(모바일)

---

## 전송 방식 — Uni/Multi/Broad/Anycast

| 방식 | 의미 | 예 |
|---|---|---|
| 유니캐스트 | 1→1 | 웹 브라우징 |
| 멀티캐스트 | 1→N(구독자) | IPTV, 실시간 중계(PIM-SM/IGMP, IPv6는 MLD) |
| 브로드캐스트 | 1→모두(세그먼트) | ARP 요청 |
| 애니캐스트 | 1→가까운 하나 | DNS, CDN POP |

---

## 성능 최적화 — MTU/PMTUD, 큐잉/혼잡, 버퍼블로트

- **MTU**: 보통 1500(이더넷), 터널/VPN은 오버헤드로 축소 필요
- **PMTUD**: 경로 MTU 탐색(필수 ICMP 허용 필요)
- **BDP** 기반 윈도우/버퍼 튜닝, **GSO/GRO/TSO** 오프로딩
- **버퍼블로트**: 지연 폭증 → **FQ-CoDel/CAKE** 같은 AQM 권장
- **측정 도구**: `iperf3`, `tc qdisc`, `ss -ti`(cwnd/RTT), `ethtool`

---

## 보안 — 암호화, 경계, 세그멘테이션, DDoS

- **TLS 1.3**, **IPsec(ESP)**, **WireGuard**(간결·고성능 VPN)
- **방화벽**: iptables/nftables, Cloud SG/NSG, WAF
- **세그멘테이션**: VLAN/VRF/SDN, 제로트러스트(ZTNA/SASE)
- **DDoS**: Anycast + 스크러빙, 레이트리밋, 업스트림 협업
- **BCP 38**: 출발지 스푸핑 차단(기관/사업자)

nftables 예시:
```bash
nft add table inet filter
nft add chain inet filter input { type filter hook input priority 0; }
nft add rule inet filter input ct state established,related accept
nft add rule inet filter input iif lo accept
nft add rule inet filter input tcp dport {22,80,443} accept
nft add rule inet filter input ip protocol icmp accept
nft add rule inet filter input ip6 nexthdr icmpv6 accept
nft add rule inet filter input counter drop
```

---

## 클라우드·데이터센터 — VPC/VXLAN/Leaf-Spine/K8s

### VPC (AWS/GCP/Azure 공통 개념)

- **서브넷**(프라이빗/퍼블릭), **라우팅 테이블**, **IGW/NAT GW**, **보안그룹/네트워크 ACL**
- **로드밸런서**: L4(NLB) / L7(ALB)
- **연결**: Peering, **Transit Gateway**, VPN/Direct Connect

### 데이터센터(DCN)

- **Leaf-Spine + ECMP**, **VXLAN(포트 4789)** 오버레이 + EVPN(Control Plane)
- **Underlay**: IP-Clos, IGP+BGP, Telemetry(Streaming)

### Kubernetes 네트워킹

- **CNI**: Pod↔Pod 네트워킹(Flannel/Calico/Cilium 등)
- **kube-proxy**: Service(VIP) 포워딩(iptables/ipvs)
- **Ingress**(L7), **Service Mesh**(Envoy/Istio: mTLS, 트래픽 정책)

---

## 진단·운영 도구 — 필수 커맨드/워크플로

| 목적 | 도구 | 예시 |
|---|---|---|
| 연결성 | `ping`, `traceroute`, `mtr` | `mtr -rwzbc100 example.com` |
| 대역폭 | `iperf3` | `iperf3 -c host -R`(reverse) |
| 캡처 | `tcpdump`, Wireshark | `tcpdump -i eth0 tcp port 443 -w out.pcap` |
| 소켓상태 | `ss`, `netstat` | `ss -ti dst :443` |
| 라우팅 | `ip route`, `route` | `ip route get 8.8.8.8` |
| 이름해결 | `dig`, `nslookup` | `dig +short A example.com` |
| HTTP | `curl`, `h2c`, `hq` | `curl -I --http3 https://…` |

Wireshark 디스플레이 필터 예:
```
tcp.flags.syn==1 && tcp.flags.ack==0
http2 || quic || tls
dns && (dns.flags.rcode != 0)
```

---

## 견고한 TCP 서버/클라이언트(C) — 부분 I/O/EINTR 처리

> 학습 포인트: **부분 읽기/쓰기(Short I/O)**, **EINTR 재시도**, **TIME_WAIT** 고려, **Nagle/Delay Ack** 조합, **SIGPIPE 억제**

### 공용 유틸 (readn/writen)

```c
// io.h
#pragma once
#include <unistd.h>
#include <errno.h>

static inline ssize_t readn(int fd, void *buf, size_t n){
    size_t left = n; char *p = buf;
    while (left > 0) {
        ssize_t r = read(fd, p, left);
        if (r > 0) { left -= r; p += r; }
        else if (r == 0) break;
        else if (errno == EINTR) continue;
        else return -1;
    }
    return (ssize_t)(n - left);
}
static inline ssize_t writen(int fd, const void *buf, size_t n){
    size_t left = n; const char *p = buf;
    while (left > 0) {
        ssize_t w = write(fd, p, left);
        if (w > 0) { left -= w; p += w; }
        else if (w < 0 && errno == EINTR) continue;
        else return -1;
    }
    return (ssize_t)n;
}
```

### 서버(단일 스레드 에코: 소량 트래픽용)

```c
// tcp_echo_server.c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <netinet/tcp.h>
#include "io.h"

#define PORT 8080
#define BUFSZ 8192

int main(void){
    int s = socket(AF_INET, SOCK_STREAM, 0);
    if (s < 0) { perror("socket"); return 1; }

    int on=1;
    setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &on, sizeof(on));
#ifdef SO_REUSEPORT

    setsockopt(s, SOL_SOCKET, SO_REUSEPORT, &on, sizeof(on));
#endif

    // SIGPIPE 억제(리눅스: MSG_NOSIGNAL로도 가능)
#ifdef SO_NOSIGPIPE

    setsockopt(s, SOL_SOCKET, SO_NOSIGPIPE, &on, sizeof(on));
#endif

    struct sockaddr_in addr = {0};
    addr.sin_family=AF_INET;
    addr.sin_addr.s_addr=htonl(INADDR_ANY);
    addr.sin_port=htons(PORT);
    if (bind(s,(struct sockaddr*)&addr,sizeof(addr))<0){perror("bind");return 1;}
    if (listen(s, 128)<0){perror("listen");return 1;}

    printf("listening on %d...\n", PORT);
    for(;;){
        struct sockaddr_in cli; socklen_t len=sizeof(cli);
        int c = accept(s,(struct sockaddr*)&cli,&len);
        if (c<0){ if(errno==EINTR) continue; perror("accept"); continue; }

        char host[INET_ADDRSTRLEN]; inet_ntop(AF_INET,&cli.sin_addr,host,sizeof(host));
        printf("conn from %s:%d\n", host, ntohs(cli.sin_port));

        char buf[BUFSZ];
        for(;;){
            ssize_t r = read(c, buf, sizeof(buf));
            if (r > 0) {
#ifdef MSG_NOSIGNAL

                // 리눅스: SIGPIPE 방지
                ssize_t w = send(c, buf, (size_t)r, MSG_NOSIGNAL);
#else

                ssize_t w = writen(c, buf, (size_t)r);
#endif

                if (w < 0) { perror("write"); break; }
            } else if (r == 0) {
                break; // EOF
            } else if (errno == EINTR) {
                continue;
            } else {
                perror("read");
                break;
            }
        }
        close(c);
    }
    close(s);
    return 0;
}
```

### 클라이언트(간단 송수신)

```c
// tcp_client.c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>
#include "io.h"
#define PORT 8080

int main(void){
    int s = socket(AF_INET, SOCK_STREAM, 0);
    struct sockaddr_in srv = {0};
    srv.sin_family = AF_INET; srv.sin_port = htons(PORT);
    inet_pton(AF_INET, "127.0.0.1", &srv.sin_addr);
    if (connect(s,(struct sockaddr*)&srv,sizeof(srv))<0){perror("connect");return 1;}
    const char *msg = "Hello over TCP\n";
    if (writen(s, msg, strlen(msg)) < 0) { perror("write"); }
    char buf[1024]={0};
    ssize_t n = read(s, buf, sizeof(buf)-1);
    if (n>0) write(STDOUT_FILENO, buf, (size_t)n);
    close(s);
    return 0;
}
```

> 더 큰 규모에선 **epoll/kqueue** 기반 다중 I/O, **스레드풀/코루틴**(io_uring/libuv)을 고려한다.

---

## 실습 — 체크리스트 & 시나리오

### 외부 접속 가능한 서버 띄우기(IPv4)

1) 서버에서 서비스 실행(예: TCP 8080)
2) 라우터에서 **포트 포워딩**(WAN:8080→LAN:8080)
3) 호스트 방화벽 허용(nftables/ufw)
4) 외부에서 접속 테스트: `nc -vz your.public.ip 8080`

### IPv6로 서비스 노출

1) `ip -6 addr` 로 글로벌 IPv6 확인
2) 방화벽에서 TCP/443 허용
3) DNS에 **AAAA** 레코드 추가
4) 외부에서 `curl -6 https://your.domain`

### MTU/PMTUD 점검

```bash
# DF 비트로 패스 MTU 탐색(IPv4)

ping -M do -s 1472 example.com  # 1472+20(IP)+8(ICMP)=1500
```

### 대역폭/지연·혼잡 측정

```bash
iperf3 -s                   # 서버
iperf3 -c server -P 4 -R    # 클라: 병렬+리버스
ss -ti 'dst :443'           # cwnd, rtt, rto 관찰
```

### 패킷 캡처/분석

```bash
tcpdump -i any -w trace.pcap 'tcp port 443 or udp port 443'
```
Wireshark로 **TCP 3-way**, TLS1.3 **ClientHello/ServerHello**, HTTP/2/3 스트림 확인

---

## 자주 틀리는 포인트(함정과 예방)

- **부분 I/O 무시**: `read`/`write`는 요청 바이트 전부 처리 안 할 수 있음 → 루프/래퍼 필수
- **ICMP 차단**: PMTUD 실패로 대용량 전송 멈춤 → ICMP 필요 트래픽 허용
- **NAT=보안?**: NAT는 주소 변환일 뿐. **상태기반 방화벽/정책**이 보안 핵심
- **DNS TTL 과소/과대**: 너무 짧으면 캐시 효율↓, 너무 길면 변경 전파 지연
- **Wi-Fi 채널 혼잡**: 자동 채널만 믿지 말고 현장 스캔/채널 계획
- **TCP Nagle + Delayed ACK**: 소량 메시지 지연 → `TCP_NODELAY` 또는 배치 전송

---

## 요약(핵심 키워드)

- **계층화**: 링크(L2)↔네트워크(L3)↔전송(L4)↔응용
- **주소**: MAC/IPv4/IPv6, CIDR, 사설·글로벌, ULA, SLAAC/DHCPv6
- **스위칭/라우팅**: VLAN/VXLAN, OSPF/IS-IS/BGP, Anycast
- **전송**: TCP(혼잡제어/흐름제어), UDP, **QUIC/HTTP3**
- **성능**: **BDP**, MTU/PMTUD, 오프로딩, AQM(FQ-CoDel/CAKE)
- **보안**: TLS1.3, WireGuard/IPsec, 세그멘테이션, DDoS/BCP38
- **클라우드/K8s**: VPC·LB·NAT·TGW, CNI·Service Mesh
- **실무**: `ping/mtr/iperf3/tcpdump/ss/dig/curl`로 **관측→분석→개선**

---

## 참고 수식·도식 모음

**이론적 최대 처리량(단순화)**
$$ \text{Throughput} \le \frac{\text{Window Size}}{\text{RTT}} $$

**큐잉 지연(리틀의 법칙 간단형)**
$$ L \approx \lambda \cdot W \quad (\text{대기 패킷 수} \approx \text{도착율}\times\text{평균 지연}) $$

**BDP 예**
$$ \text{BDP(MB)} = \frac{\text{Gbps} \times 10^3}{8} \times \text{RTT(ms)} / 10^3 $$

---

## 부록 — 추가 코드 스니펫

### UDP 에코(기본)

```c
#include <stdio.h>
#include <string.h>
#include <unistd.h>
#include <arpa/inet.h>

int main(void){
    int s = socket(AF_INET, SOCK_DGRAM, 0);
    struct sockaddr_in a={0}, cli; socklen_t len=sizeof(cli);
    a.sin_family=AF_INET; a.sin_addr.s_addr=htonl(INADDR_ANY); a.sin_port=htons(9090);
    bind(s,(struct sockaddr*)&a,sizeof(a));
    char buf[2048];
    for(;;){
        ssize_t n = recvfrom(s,buf,sizeof(buf),0,(struct sockaddr*)&cli,&len);
        if(n>0) sendto(s,buf,(size_t)n,0,(struct sockaddr*)&cli,len);
    }
}
```

### cURL로 HTTP/3 테스트

```bash
curl -I --http3 https://cloudflare.com/
```

---

**마무리**
네트워크는 **계층화된 추상화**와 **관측 가능한 성능/보안 특성** 위에서 돌아간다.
주소·라우팅·전송·애플리케이션·관측·보안의 연결고리를 이해하면, **웹/클라우드/분산/IoT** 어디서든 문제를 **체계적으로 정의·측정·해결**할 수 있다.
