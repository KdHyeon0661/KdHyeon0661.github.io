---
layout: post
title: 파이썬 심화 - 숫자, 날짜, 시간 (2)
date: 2025-11-26 22:25:23 +0900
category: 파이썬 심화
---
# 숫자, 날짜, 시간 (2)

파이썬은 과학 계산, 데이터 분석, 수치 시뮬레이션 등 다양한 수학적 연산을 지원하는 풍부한 생태계를 갖추고 있습니다. 기본적인 산술 연산부터 고급 선형대수 계산까지 다양한 수치 처리 기법을 살펴보겠습니다.

## 무한대와 NaN 사용하기

수치 계산에서 특수한 값들을 표현하는 `inf`(무한대)와 `NaN`(Not a Number)은 수학적 예외 상황을 처리하는 데 필수적입니다.

```python
import math

# 1. 무한대(inf)와 음의 무한대(-inf)
positive_inf = float('inf')  # 또는 math.inf
negative_inf = float('-inf')

print(f"양의 무한대: {positive_inf}")
print(f"음의 무한대: {negative_inf}")

# 무한대 연산 예시
print(f"10 / 0 = {10.0 / 0.0}")        # inf
print(f"-5 / 0 = {-5.0 / 0.0}")        # -inf
print(f"inf + 100 = {positive_inf + 100}")     # inf
print(f"inf * 2 = {positive_inf * 2}")         # inf
print(f"inf / inf = {positive_inf / positive_inf}")  # nan

# 2. NaN (Not a Number)
nan_value = float('nan')  # 또는 math.nan
print(f"\nNaN 값: {nan_value}")
print(f"NaN의 타입: {type(nan_value)}")

# NaN 연산 특징
print(f"NaN + 10 = {nan_value + 10}")      # nan
print(f"NaN * 5 = {nan_value * 5}")        # nan
print(f"NaN == NaN = {nan_value == nan_value}")  # False (중요!)
print(f"NaN is NaN = {nan_value is nan_value}")  # True

# 3. 무한대와 NaN 검사
values = [10.0, -5.0, float('inf'), float('-inf'), float('nan'), 0.0]

for value in values:
    print(f"\n값: {value}")
    print(f"  무한대인가? {math.isinf(value)}")
    print(f"  유한한가? {math.isfinite(value)}")
    print(f"  NaN인가? {math.isnan(value)}")

# 4. 실전 예제: 안전한 수치 계산 함수
def safe_divide(numerator, denominator):
    """
    0으로 나누기나 무효한 연산을 안전하게 처리하는 함수
    """
    try:
        result = numerator / denominator
        if math.isinf(result):
            return float('inf') if result > 0 else float('-inf')
        return result
    except (ZeroDivisionError, TypeError):
        return float('nan')

# 테스트
test_cases = [(10, 2), (5, 0), (-3, 0), (0, 0), (float('inf'), 2)]
for a, b in test_cases:
    result = safe_divide(a, b)
    print(f"{a} / {b} = {result}")

# 5. 통계 계산에서의 NaN 처리
import numpy as np

# NaN이 포함된 데이터의 통계 계산
data_with_nan = [1.2, 2.3, float('nan'), 3.4, 4.5, float('nan'), 5.6]

# NaN을 무시하고 통계 계산
valid_data = [x for x in data_with_nan if not math.isnan(x)]
print(f"\n원본 데이터: {data_with_nan}")
print(f"유효한 데이터: {valid_data}")
print(f"평균: {sum(valid_data) / len(valid_data):.2f}")
print(f"최대값: {max(valid_data)}")
print(f"최소값: {min(valid_data)}")

# 6. 로그 계산 시 무한대 방지
def safe_log(x):
    """
    로그 계산 시 0이나 음수 값을 안전하게 처리
    """
    if x > 0:
        return math.log(x)
    elif x == 0:
        return float('-inf')
    else:  # x < 0
        return float('nan')

# 테스트
for val in [10, 1, 0.1, 0, -5]:
    print(f"log({val}) = {safe_log(val)}")
```

## 분수 계산

정확한 유리수 연산이 필요한 경우 `fractions` 모듈을 사용하여 분수 계산을 수행할 수 있습니다.

```python
from fractions import Fraction
from decimal import Decimal

# 1. 기본 분수 생성
f1 = Fraction(3, 4)      # 3/4
f2 = Fraction(2, 5)      # 2/5
f3 = Fraction('0.75')    # 문자열에서 생성
f4 = Fraction(Decimal('0.125'))  # Decimal에서 생성

print(f"f1 = {f1}")      # 3/4
print(f"f2 = {f2}")      # 2/5
print(f"f3 = {f3}")      # 3/4
print(f"f4 = {f4}")      # 1/8

# 2. 분수 연산
print(f"\n분수 연산:")
print(f"{f1} + {f2} = {f1 + f2}")        # 23/20
print(f"{f1} - {f2} = {f1 - f2}")        # 7/20
print(f"{f1} × {f2} = {f1 * f2}")        # 3/10
print(f"{f1} ÷ {f2} = {f1 / f2}")        # 15/8
print(f"{f1}의 제곱 = {f1 ** 2}")        # 9/16

# 3. 분수와 다른 숫자 타입 간 연산
print(f"\n혼합 연산:")
print(f"{f1} + 2 = {f1 + 2}")            # 11/4
print(f"{f1} + 0.5 = {float(f1 + Fraction(1, 2))}")  # 1.25

# 4. 분수 단순화
f5 = Fraction(12, 18)
print(f"\n분수 단순화:")
print(f"12/18 = {f5}")                   # 2/3 (자동 단순화)
print(f"분자: {f5.numerator}")           # 2
print(f"분모: {f5.denominator}")         # 3

f6 = Fraction(8, -12)
print(f"8/-12 = {f6}")                   # -2/3 (음수는 분자에 표시)

# 5. 실전 예제: 연이율 계산
def calculate_compound_interest(principal, annual_rate, years, compounds_per_year):
    """
    복리 계산: A = P(1 + r/n)^(nt)
    """
    rate_per_period = Fraction(annual_rate, compounds_per_year)
    total_periods = years * compounds_per_year
    
    # (1 + r/n) 계산
    base = 1 + rate_per_period
    
    # (1 + r/n)^(nt) 계산
    growth_factor = base ** total_periods
    
    # 최종 금액 계산
    final_amount = principal * float(growth_factor)
    
    return final_amount

# 월 복리 5% 이자, 3년 간 100만원 투자
final = calculate_compound_interest(
    principal=1000000,
    annual_rate=Fraction(5, 100),  # 5%
    years=3,
    compounds_per_year=12
)
print(f"\n복리 계산 결과: {final:,.0f}원")

# 6. 분수를 사용한 정확한 비율 계산
def simplify_ratio(a, b):
    """
    두 수의 비율을 가장 간단한 분수 형태로 변환
    """
    ratio = Fraction(a, b)
    return f"{ratio.numerator}:{ratio.denominator}"

# 화면 해상도 비율 계산
width, height = 1920, 1080
aspect_ratio = simplify_ratio(width, height)
print(f"\n해상도 {width}×{height}의 종횡비: {aspect_ratio}")

# 레시피 재료 비율 조정
original_recipe = {
    '밀가루': Fraction(3, 4),    # 3/4 컵
    '설탕': Fraction(1, 2),      # 1/2 컵
    '버터': Fraction(1, 3),      # 1/3 컵
    '계란': 2
}

# 재료를 1.5배로 늘리기
scale_factor = Fraction(3, 2)  # 1.5배
scaled_recipe = {}
for ingredient, amount in original_recipe.items():
    if isinstance(amount, Fraction):
        scaled_recipe[ingredient] = amount * scale_factor
    else:
        scaled_recipe[ingredient] = amount * float(scale_factor)

print("\n조정된 레시피:")
for ingredient, amount in scaled_recipe.items():
    if isinstance(amount, Fraction):
        print(f"  {ingredient}: {amount} 컵")
    else:
        print(f"  {ingredient}: {amount} 개")

# 7. 연분수 표현
def to_continued_fraction(fraction, max_terms=10):
    """
    분수를 연분수로 변환
    """
    result = []
    f = fraction
    for _ in range(max_terms):
        whole = f.numerator // f.denominator
        result.append(whole)
        remainder = f - whole
        if remainder == 0:
            break
        f = 1 / remainder
    return result

# 원주율 근사값을 연분수로 표현
pi_approx = Fraction(355, 113)  # π의 유명한 근사값
cf = to_continued_fraction(pi_approx)
print(f"\n355/113의 연분수 표현: {cf}")
print(f"이는 π ≈ 3.14159292035...를 나타냅니다.")
```

## 큰 배열 계산 (NumPy 활용)

대규모 수치 데이터를 효율적으로 처리하려면 NumPy 배열을 사용해야 합니다.

```python
import numpy as np
import time

# 1. 기본 배열 생성
# 일반 리스트와 NumPy 배열 비교
list_data = [1, 2, 3, 4, 5] * 1000  # 5000개 요소
array_data = np.array(list_data)

print(f"리스트 크기: {len(list_data)}")
print(f"배열 크기: {array_data.shape}")
print(f"배열 차원: {array_data.ndim}")
print(f"배열 데이터 타입: {array_data.dtype}")

# 2. 성능 비교: 리스트 vs NumPy 배열
def list_operation(data):
    """리스트 제곱 연산"""
    return [x ** 2 for x in data]

def numpy_operation(data):
    """NumPy 배열 제곱 연산"""
    return data ** 2

# 성능 측정
start = time.time()
list_result = list_operation(list_data)
list_time = time.time() - start

start = time.time()
numpy_result = numpy_operation(array_data)
numpy_time = time.time() - start

print(f"\n성능 비교:")
print(f"리스트 연산 시간: {list_time:.6f}초")
print(f"NumPy 연산 시간: {numpy_time:.6f}초")
print(f"NumPy가 {list_time/numpy_time:.1f}배 빠릅니다.")

# 3. 대용량 배열 생성 및 처리
# 100만 개 요소 배열
large_array = np.random.rand(1000000)  # 0~1 사이 랜덤 값

print(f"\n대용량 배열 정보:")
print(f"크기: {large_array.size:,}개 요소")
print(f"메모리 사용량: {large_array.nbytes:,} bytes")
print(f"평균: {large_array.mean():.4f}")
print(f"표준편차: {large_array.std():.4f}")
print(f"최소값: {large_array.min():.4f}")
print(f"최대값: {large_array.max():.4f}")

# 4. 배열 연산 최적화
# 벡터화 연산의 이점
size = 1000000
a = np.random.rand(size)
b = np.random.rand(size)

# Python 반복문 (느림)
def slow_dot_product(a, b):
    result = 0
    for i in range(len(a)):
        result += a[i] * b[i]
    return result

# NumPy 벡터화 연산 (빠름)
def fast_dot_product(a, b):
    return np.dot(a, b)

# 성능 비교
start = time.time()
slow_result = slow_dot_product(a, b)
slow_time = time.time() - start

start = time.time()
fast_result = fast_dot_product(a, b)
fast_time = time.time() - start

print(f"\n내적 연산 성능 비교:")
print(f"반복문 시간: {slow_time:.4f}초, 결과: {slow_result:.4f}")
print(f"벡터화 시간: {fast_time:.6f}초, 결과: {fast_result:.4f}")

# 5. 메모리 효율적인 배열 처리
# 뷰(View) vs 복사(Copy)
original = np.arange(10)
print(f"\n원본 배열: {original}")

# 뷰 생성 (메모리 공유)
view = original[3:7]
view[0] = 999
print(f"뷰 수정 후 원본: {original}")  # 원본도 변경됨

# 복사 생성 (새 메모리 할당)
copy = original[3:7].copy()
copy[0] = 111
print(f"복사 수정 후 원본: {original}")  # 원본은 변경되지 않음

# 6. 브로드캐스팅
# 크기가 다른 배열 간 연산
matrix = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
vector = np.array([10, 20, 30])

print(f"\n브로드캐스팅 예제:")
print(f"행렬:\n{matrix}")
print(f"벡터: {vector}")
print(f"\n행렬 + 벡터:\n{matrix + vector}")
print(f"\n행렬 * 벡터:\n{matrix * vector}")

# 7. 유니버설 함수(ufunc) 활용
x = np.linspace(0, 2*np.pi, 100)
y_sin = np.sin(x)
y_cos = np.cos(x)
y_exp = np.exp(x)

print(f"\n삼각함수 계산 (100개 점):")
print(f"sin(π/2) = {np.sin(np.pi/2):.6f}")
print(f"cos(π) = {np.cos(np.pi):.6f}")

# 8. 조건부 연산과 마스킹
data = np.random.randn(1000)  # 정규분포 난수
print(f"\n데이터 통계:")
print(f"평균: {data.mean():.4f}")
print(f"표준편차: {data.std():.4f}")

# 조건에 맞는 데이터만 선택
positive_mask = data > 0
negative_mask = data < 0
large_mask = np.abs(data) > 2

print(f"\n조건부 필터링:")
print(f"양수 개수: {positive_mask.sum()}")
print(f"음수 개수: {negative_mask.sum()}")
print(f"|값| > 2인 개수: {large_mask.sum()}")

# 마스킹을 이용한 조건부 연산
data_masked = np.where(data > 0, data, 0)  # 음수는 0으로
print(f"\n음수를 0으로 대체한 데이터 평균: {data_masked.mean():.4f}")
```

## 행렬과 선형대수 계산

NumPy와 SciPy를 활용한 고급 선형대수 연산을 살펴봅니다.

```python
import numpy as np
from scipy import linalg

# 1. 행렬 생성과 기본 연산
print("1. 행렬 생성과 기본 연산")
print("=" * 50)

A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
B = np.array([[9, 8, 7], [6, 5, 4], [3, 2, 1]])

print(f"행렬 A:\n{A}")
print(f"\n행렬 B:\n{B}")

# 기본 연산
print(f"\nA + B:\n{A + B}")
print(f"\nA - B:\n{A - B}")
print(f"\nA × B (요소별 곱):\n{A * B}")
print(f"\nA @ B (행렬 곱):\n{A @ B}")

# 2. 특수 행렬 생성
print(f"\n\n2. 특수 행렬 생성")
print("=" * 50)

# 단위 행렬
I3 = np.eye(3)
print(f"3×3 단위 행렬:\n{I3}")

# 영행렬
zeros = np.zeros((3, 3))
print(f"\n3×3 영행렬:\n{zeros}")

# 대각 행렬
diag_matrix = np.diag([1, 2, 3])
print(f"\n대각 행렬:\n{diag_matrix}")

# 난수 행렬
random_matrix = np.random.rand(3, 3)
print(f"\n랜덤 행렬:\n{random_matrix}")

# 3. 행렬 속성과 연산
print(f"\n\n3. 행렬 속성과 연산")
print("=" * 50)

M = np.array([[4, 12, -16], [12, 37, -43], [-16, -43, 98]], dtype=float)

print(f"행렬 M:\n{M}")
print(f"\n전치 행렬 Mᵀ:\n{M.T}")
print(f"\n대각선 요소: {np.diag(M)}")
print(f"\n행렬의 대각합(trace): {np.trace(M)}")
print(f"\n행렬식(determinant): {np.linalg.det(M):.6f}")

# 4. 역행렬 계산
print(f"\n\n4. 역행렬 계산")
print("=" * 50)

# 가역 행렬 생성
invertible = np.array([[4, 7], [2, 6]], dtype=float)
print(f"가역 행렬:\n{invertible}")
print(f"행렬식: {np.linalg.det(invertible)}")

try:
    inv_matrix = np.linalg.inv(invertible)
    print(f"\n역행렬:\n{inv_matrix}")
    
    # 검증: A × A⁻¹ = I
    identity_check = invertible @ inv_matrix
    print(f"\n검증 (A × A⁻¹):\n{identity_check}")
    
except np.linalg.LinAlgError:
    print("행렬이 특이 행렬입니다. 역행렬이 존재하지 않습니다.")

# 5. 선형 시스템 해 구하기
print(f"\n\n5. 선형 시스템 해 구하기")
print("=" * 50)

# Ax = b 형태의 선형 시스템
A_system = np.array([[3, 2, -1], [2, -2, 4], [-1, 0.5, -1]], dtype=float)
b = np.array([1, -2, 0], dtype=float)

print(f"계수 행렬 A:\n{A_system}")
print(f"\n상수 벡터 b: {b}")

# 해 구하기
x = np.linalg.solve(A_system, b)
print(f"\n해 x: {x}")

# 검증: Ax - b ≈ 0
residual = A_system @ x - b
print(f"\n잔차 (Ax - b): {residual}")
print(f"잔차 노름: {np.linalg.norm(residual):.10f}")

# 6. 고유값과 고유벡터
print(f"\n\n6. 고유값과 고유벡터")
print("=" * 50)

# 대칭 행렬 생성
symmetric_matrix = np.array([[2, -1, 0], [-1, 2, -1], [0, -1, 2]], dtype=float)

print(f"대칭 행렬:\n{symmetric_matrix}")

# 고유값 분해
eigenvalues, eigenvectors = np.linalg.eig(symmetric_matrix)

print(f"\n고유값: {eigenvalues}")
print(f"\n고유벡터 (각 열이 고유벡터):\n{eigenvectors}")

# 검증: A·v = λ·v
print("\n검증 (A·v = λ·v):")
for i in range(len(eigenvalues)):
    v = eigenvectors[:, i]
    λ = eigenvalues[i]
    left_side = symmetric_matrix @ v
    right_side = λ * v
    error = np.linalg.norm(left_side - right_side)
    print(f"고유값 {λ:.4f}: 오차 = {error:.10f}")

# 7. 특이값 분해(SVD)
print(f"\n\n7. 특이값 분해(SVD)")
print("=" * 50)

# 랜덤 행렬
C = np.random.rand(4, 3)
print(f"4×3 행렬 C:\n{C}")

# 특이값 분해
U, S, Vt = np.linalg.svd(C, full_matrices=False)

print(f"\nU 행렬 (4×3):\n{U}")
print(f"\n특이값: {S}")
print(f"\nVᵀ 행렬 (3×3):\n{Vt}")

# 원행렬 복원
Sigma = np.diag(S)
C_reconstructed = U @ Sigma @ Vt
reconstruction_error = np.linalg.norm(C - C_reconstructed)

print(f"\n복원 오차: {reconstruction_error:.10f}")

# 8. 실전 응용: 이미지 압축
print(f"\n\n8. 실전 응용: SVD를 이용한 이미지 압축")
print("=" * 50)

# 간단한 이미지 데이터 생성 (흑백 이미지)
image = np.array([
    [255, 255, 255, 255, 255],
    [255, 100, 100, 100, 255],
    [255, 100, 0, 100, 255],
    [255, 100, 100, 100, 255],
    [255, 255, 255, 255, 255]
], dtype=float)

print(f"원본 이미지 (5×5):\n{image.astype(int)}")

# SVD 수행
U_img, S_img, Vt_img = np.linalg.svd(image)

# 저차원 근사 (k=2)
k = 2
U_k = U_img[:, :k]
S_k = np.diag(S_img[:k])
Vt_k = Vt_img[:k, :]

# 압축된 이미지 재구성
compressed_image = U_k @ S_k @ Vt_k

print(f"\n{k}개의 특이값으로 압축한 이미지:\n{compressed_image.astype(int)}")

# 압축률 계산
original_size = image.size
compressed_size = U_k.size + S_k.size + Vt_k.size
compression_ratio = original_size / compressed_size

print(f"\n압축 정보:")
print(f"원본 크기: {original_size} elements")
print(f"압축 크기: {compressed_size} elements")
print(f"압축률: {compression_ratio:.2f}:1")

# 9. 최소제곱법 (선형 회귀)
print(f"\n\n9. 최소제곱법을 이용한 선형 회귀")
print("=" * 50)

# 샘플 데이터 생성
np.random.seed(42)
n_points = 20
x = np.linspace(0, 10, n_points)
true_slope = 2.5
true_intercept = 1.0
y_true = true_slope * x + true_intercept
y_noisy = y_true + np.random.randn(n_points) * 2  # 노이즈 추가

# 설계 행렬 구성
X_design = np.column_stack([x, np.ones_like(x)])

# 최소제곱해 계산
coefficients, residuals, rank, s = np.linalg.lstsq(X_design, y_noisy, rcond=None)
estimated_slope, estimated_intercept = coefficients

print(f"실제 기울기: {true_slope:.4f}, 실제 절편: {true_intercept:.4f}")
print(f"추정 기울기: {estimated_slope:.4f}, 추정 절편: {estimated_intercept:.4f}")
print(f"잔차 제곱합: {residuals[0]:.4f}")

# 10. 행렬 분해 응용
print(f"\n\n10. LU 분해와 Cholesky 분해")
print("=" * 50)

# LU 분해
A_lu = np.array([[4, 3], [6, 3]], dtype=float)
P, L, U = linalg.lu(A_lu)

print(f"행렬 A:\n{A_lu}")
print(f"\n치환 행렬 P:\n{P}")
print(f"\n하삼각 행렬 L:\n{L}")
print(f"\n상삼각 행렬 U:\n{U}")
print(f"\n검증 (P×A ≈ L×U):")
print(f"P×A:\n{P @ A_lu}")
print(f"L×U:\n{L @ U}")

# Cholesky 분해 (양정치 행렬)
A_chol = np.array([[4, 12, -16], [12, 37, -43], [-16, -43, 98]], dtype=float)
L_chol = linalg.cholesky(A_chol, lower=True)

print(f"\n\n양정치 행렬 A:\n{A_chol}")
print(f"\nCholesky 분해 L:\n{L_chol}")
print(f"\n검증 (L×Lᵀ):\n{L_chol @ L_chol.T}")
```

## 결론

파이썬은 무한대와 NaN 처리부터 고급 선형대수 연산까지 다양한 수치 계산 기능을 제공합니다. 수학적 예외 상황을 다루기 위한 `inf`와 `nan`, 정확한 유리수 연산을 위한 `Fraction`, 대규모 배열 처리를 위한 NumPy, 그리고 고급 선형대수 연산을 위한 SciPy는 과학 계산과 데이터 분석 작업에 필수적인 도구들입니다.

이러한 라이브러리들을 효과적으로 활용하면 복잡한 수학적 문제도 간결하고 효율적으로 해결할 수 있습니다. 특히 대용량 데이터 처리나 수치적 안정성이 중요한 문제에서는 NumPy의 벡터화 연산과 SciPy의 수치 알고리즘을 사용하는 것이 성능과 정확도 측면에서 큰 이점을 제공합니다. 실제 응용 프로그램 개발 시에는 문제의 특성에 맞는 적절한 수치 계산 방법을 선택하고, 수치적 안정성을 고려한 구현이 필요합니다.