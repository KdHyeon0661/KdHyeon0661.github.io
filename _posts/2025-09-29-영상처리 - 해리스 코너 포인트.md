---
layout: post
title: 영상처리 - 해리스 코너 포인트
date: 2025-09-29 22:25:23 +0900
category: 영상처리
---
# | **해리스(Harris) 코너 포인트 검출**

## 해리스 코너 검출 방법

### 코너란?

코너(모서리점)는 영상 밝기 함수 \(f(x,y)\)가 **서로 다른 방향**에서 **큰 변화**를 갖는 위치입니다.
미세 이동 \((u,v)\)에 대한 **자기상관(autocorrelation)** 변화:
\[
E(u,v) \approx
\begin{bmatrix}u & v\end{bmatrix}
\underbrace{\sum\_{(x,y)\in\mathcal{W}}
\begin{bmatrix} f\_x^2 & f\_x f\_y\\ f\_x f\_y & f\_y^2\end{bmatrix}}\_{M(x,y)}
\begin{bmatrix}u\\v\end{bmatrix}
\]
여기서 \(M\) 은 **구조 텐서(Structure Tensor)** 또는 두 번째 모멘트 행렬.
윈도우 \(\mathcal{W}\) 는 보통 **가우시안**으로 가중하고, \(f\_x, f\_y\) 는 밝기의 1차 미분입니다.

### 해리스 응답식

\(M\) 의 고유값을 \(\lambda\_1,\lambda\_2\)라 하면,
- **코너**: \(\lambda\_1,\lambda\_2\) 모두 큼
- **에지**: 한쪽만 큼
- **평탄**: 둘 다 작음

해리스는 고유값 대신 다음 **응답 \(R\)** 을 사용합니다:
\[
R = \det(M) - k \cdot \operatorname{trace}(M)^2
= (\lambda\_1 \lambda\_2) - k(\lambda\_1 + \lambda\_2)^2
\]
- 보통 \(k \in [0.04, 0.06]\)
- \(R>0\) 이고 크면 코너

### 실용 구현

1) Sobel 등으로 \(I\_x, I\_y\) 계산
2) \(I\_x^2, I\_y^2, I\_x I\_y\) **가우시안 블러**(분리 합성) → \(M\) 구성
3) 픽셀별 \(R\) 계산
4) **NMS**로 국소 최대만 남김
5) **임계값**과 **최소 간격**으로 최종 코너 선택

---

## 파라미터와 출력

- \(\sigma\): 구조 텐서(누적)용 가우시안 표준편차. **1.0~2.0** 권장
- \(k\): 해리스 상수(기본 **0.04**)
- Threshold: \(R\_{\max}\) 대비 **상대 임계(%)**
- NMS radius: 국소 최대 탐색 반경(픽셀)
- MaxCorners: 최대 코너 수(스코어 상위)
- 출력 모드: **Overlay(코너 크로스)** / **Heatmap(R 시각화)**

---

## 코드 — 해리스 코너 검출(핵심 모듈)

```cpp
// Harris.hpp
#pragma once
#include <vector>
#include <cstdint>
#include <cmath>
#include <algorithm>
#include <queue>
#include <string>
#include "IppDib.h"

// ===== 옵션/구조체 =====
enum class HarrisOut { Overlay, Heatmap };

struct HarrisOptions {
    double sigma = 1.4;       // 가우시안 누적 시그마
    double k     = 0.04;      // Harris k
    int    threshPercent = 10;// Rmax 대비 % (예: 10% -> 0.10 * Rmax)
    int    nmsRadius     = 3; // 국소 최대 반경
    int    maxCorners    = 200;
    bool   replicateBorder = true;
    HarrisOut out = HarrisOut::Overlay;

    // 렌더링
    int    crossSize = 4;     // 코너 크로스 반길이
    uint8_t colorR=16, colorG=255, colorB=32; // 초록(연두) 계열
};

// ===== 유틸: 그레이 변환(float) =====
inline void DibToGrayF32(const IppDib& src, std::vector<float>& Y, int& W, int& H){
    if (!src){ W=H=0; Y.clear(); return; }
    W=src.width(); H=src.height();
    Y.resize((size_t)W*H);
    for (int y=0;y<H;++y){
        const uint8_t* s=(const uint8_t*)src.bits()+(size_t)y*src.stride();
        for (int x=0;x<W;++x){
            int B=s[x*4+0], G=s[x*4+1], R=s[x*4+2];
            Y[(size_t)y*W+x] = 0.114f*B + 0.587f*G + 0.299f*R;
        }
    }
}
inline int clampi(int v, int lo, int hi){ return (v<lo)?lo:((v>hi)?hi:v); }
inline float sampleF(const std::vector<float>& A, int W,int H,int x,int y, bool repl){
    if (repl){ x=clampi(x,0,W-1); y=clampi(y,0,H-1); return A[(size_t)y*W+x]; }
    if ((unsigned)x>=(unsigned)W || (unsigned)y>=(unsigned)H) return 0.f;
    return A[(size_t)y*W+x];
}
static inline uint8_t toU8(double v){
    if (v<0) v=0; else if (v>255) v=255;
    return (uint8_t)std::lround(v);
}

// ===== 가우시안 1D, 분리 합성 =====
inline std::vector<float> gaussianKernel1D(double sigma, int& radius){
    if (sigma<=0){ radius=0; return {1.f}; }
    radius=(int)std::ceil(3.0*sigma);
    int ksize=2*radius+1;
    std::vector<float> k(ksize);
    double sum=0.0, s2=2.0*sigma*sigma;
    for (int i=-radius;i<=radius;++i){
        double v=std::exp(-(i*i)/s2);
        k[i+radius]=(float)v; sum+=v;
    }
    for (auto& v:k) v=(float)(v/sum);
    return k;
}
inline void convolveSeparable(const std::vector<float>& src, int W,int H,
                              const std::vector<float>& k, int radius,
                              std::vector<float>& dst, bool repl)
{
    dst.assign((size_t)W*H,0.f);
    std::vector<float> tmp((size_t)W*H,0.f);

    // X
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            double acc=0.0;
            for (int i=-radius;i<=radius;++i)
                acc += (double)sampleF(src,W,H,x+i,y,repl) * k[i+radius];
            tmp[(size_t)y*W+x]=(float)acc;
        }
    }
    // Y
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            double acc=0.0;
            for (int j=-radius;j<=radius;++j)
                acc += (double)sampleF(tmp,W,H,x,y+j,repl) * k[j+radius];
            dst[(size_t)y*W+x]=(float)acc;
        }
    }
}

// ===== Sobel 그래디언트 =====
inline void sobelGrad(const std::vector<float>& S, int W,int H,
                      std::vector<float>& Gx, std::vector<float>& Gy, bool repl)
{
    Gx.assign((size_t)W*H,0.f); Gy.assign((size_t)W*H,0.f);
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            float p00=sampleF(S,W,H,x-1,y-1,repl), p10=sampleF(S,W,H,x,y-1,repl), p20=sampleF(S,W,H,x+1,y-1,repl);
            float p01=sampleF(S,W,H,x-1,y  ,repl), /*p11*/(void)0,      p21=sampleF(S,W,H,x+1,y  ,repl);
            float p02=sampleF(S,W,H,x-1,y+1,repl), p12=sampleF(S,W,H,x,y+1,repl), p22=sampleF(S,W,H,x+1,y+1,repl);

            float gx = (-p00 + p20) + (-2.f*p01 + 2.f*p21) + (-p02 + p22);
            float gy = (-p00 - 2.f*p10 - p20) + (p02 + 2.f*p12 + p22);
            Gx[(size_t)y*W+x]=gx; Gy[(size_t)y*W+x]=gy;
        }
    }
}

// ===== 해리스 응답 계산 =====
inline void harrisResponse(const std::vector<float>& Y, int W,int H,
                           double sigma, double k, bool repl,
                           std::vector<float>& R, float& Rmax)
{
    // 1) 그래디언트
    std::vector<float> Gx,Gy; sobelGrad(Y,W,H,Gx,Gy,repl);

    // 2) 제품 항
    std::vector<float> Ix2((size_t)W*H), Iy2((size_t)W*H), Ixy((size_t)W*H);
    for (size_t i=0;i<Ix2.size();++i){
        float gx=Gx[i], gy=Gy[i];
        Ix2[i]=gx*gx; Iy2[i]=gy*gy; Ixy[i]=gx*gy;
    }

    // 3) 가우시안 누적
    int radius; auto g=gaussianKernel1D(sigma, radius);
    std::vector<float> Sx2,Sy2,Sxy;
    convolveSeparable(Ix2,W,H,g,radius,Sx2,repl);
    convolveSeparable(Iy2,W,H,g,radius,Sy2,repl);
    convolveSeparable(Ixy,W,H,g,radius,Sxy,repl);

    // 4) R = det(M) - k * trace(M)^2
    R.assign((size_t)W*H,0.f); Rmax=0.f;
    for (size_t i=0;i<R.size();++i){
        double a=Sx2[i], b=Sxy[i], c=Sy2[i];
        double det = a*c - b*b;
        double tr  = a + c;
        double r   = det - k*tr*tr;
        R[i]=(float)r;
        if (r>Rmax) Rmax=(float)r;
    }
}

// ===== 히트맵(그레이) 만들기 =====
inline IppDib RToGray(const std::vector<float>& R, int W,int H){
    float mx=0.f; for (auto v:R) if (v>mx) mx=v;
    float scale = (mx>1e-6f)? 255.f/mx : 1.f;
    IppDib out; out.create(W,H,32);
    for (int y=0;y<H;++y){
        uint8_t* d=(uint8_t*)out.bits()+(size_t)y*out.stride();
        for (int x=0;x<W;++x){
            uint8_t g = toU8(R[(size_t)y*W+x]*scale);
            d[x*4+0]=d[x*4+1]=d[x*4+2]=g; d[x*4+3]=255;
        }
    }
    return out;
}

// ===== NMS + 임계 + 상위 N 선택 =====
struct Corner { int x,y; float score; };

inline std::vector<Corner> selectCornersNMS(const std::vector<float>& R, int W,int H,
                                            int nmsRadius, float threshAbs, int maxCorners)
{
    auto at=[&](int x,int y)->float{ return R[(size_t)y*W+x]; };

    std::vector<Corner> cand;
    // 1) 임계
    for (int y=0;y<H;++y){
        for (int x=0;x<W;++x){
            float r = at(x,y);
            if (r < threshAbs) continue;
            // 2) NMS: 반경 내 최대인지
            bool isMax=true;
            for (int j=-nmsRadius; j<=nmsRadius && isMax; ++j){
                int yy = y+j; if ((unsigned)yy>=(unsigned)H) continue;
                for (int i=-nmsRadius; i<=nmsRadius; ++i){
                    int xx = x+i; if ((unsigned)xx>=(unsigned)W) continue;
                    if (i==0 && j==0) continue;
                    if (at(xx,yy) > r){ isMax=false; break; }
                }
            }
            if (isMax) cand.push_back({x,y,r});
        }
    }
    // 3) 스코어 내림차순 및 상위 N
    std::sort(cand.begin(), cand.end(), [](auto&a,auto&b){ return a.score>b.score; });
    if ((int)cand.size()>maxCorners) cand.resize(maxCorners);
    return cand;
}

// ===== 코너 시각화 =====
inline void drawCross(IppDib& img, int x,int y, int s, uint8_t r,uint8_t g,uint8_t b){
    auto put=[&](int px,int py){
        if ((unsigned)px>=(unsigned)img.width() || (unsigned)py>=(unsigned)img.height()) return;
        uint8_t* p=(uint8_t*)img.bits()+(size_t)py*img.stride()+px*4;
        p[0]=b; p[1]=g; p[2]=r; p[3]=255;
    };
    for (int d=-s; d<=s; ++d){ put(x+d,y); put(x,y+d); }
}

// ===== 공개 API: Harris 실행 =====
inline bool HarrisDetect(const IppDib& in, IppDib& out,
                         const HarrisOptions& opt, std::vector<Corner>* cornersOut=nullptr)
{
    if (!in) return false;
    int W,H; std::vector<float> Y; DibToGrayF32(in, Y, W,H);

    std::vector<float> R; float Rmax;
    harrisResponse(Y, W,H, opt.sigma, opt.k, opt.replicateBorder, R, Rmax);
    if (Rmax<=1e-9f){
        out = in; return true;
    }

    // 임계: Rmax * (threshPercent/100)
    float threshAbs = Rmax * (std::max(0,std::min(100,opt.threshPercent)) / 100.0f);
    auto corners = selectCornersNMS(R, W,H, opt.nmsRadius, threshAbs, opt.maxCorners);
    if (cornersOut) *cornersOut = corners;

    if (opt.out==HarrisOut::Heatmap){
        out = RToGray(R,W,H);
    } else {
        out = in;
        for (auto& c : corners)
            drawCross(out, c.x, c.y, opt.crossSize, opt.colorR, opt.colorG, opt.colorB);
    }
    return true;
}
```

---

## UI — **해리스 코너 대화 상자** & **메뉴**

### 리소스 ID

```cpp
// resource.h (추가)
#define IDD_HARRIS_DLG                 3700
#define IDC_EDIT_HARRIS_SIGMA          3701
#define IDC_EDIT_HARRIS_K              3702
#define IDC_EDIT_HARRIS_TPCT           3703
#define IDC_EDIT_HARRIS_NMSR           3704
#define IDC_EDIT_HARRIS_MAXN           3705
#define IDC_CHK_HARRIS_REPL            3706
#define IDC_EDIT_HARRIS_CROSS          3707
#define IDC_RAD_HARRIS_OVERLAY         3708
#define IDC_RAD_HARRIS_HEATMAP         3709
#define IDC_EDIT_HARRIS_COLOR_R        3710
#define IDC_EDIT_HARRIS_COLOR_G        3711
#define IDC_EDIT_HARRIS_COLOR_B        3712

// 메뉴
#define ID_MENU_HARRIS                 76000

```

### RC

```rc
// ImageTool.rc (추가)
IDD_HARRIS_DLG DIALOGEX 0,0, 260, 190
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Harris Corners"
FONT 9, "Segoe UI"
BEGIN
    LTEXT "Sigma:", -1, 14, 14, 40, 10
    EDITTEXT IDC_EDIT_HARRIS_SIGMA, 58, 12, 36, 14, ES_AUTOHSCROLL
    LTEXT "k:", -1, 102, 14, 12, 10
    EDITTEXT IDC_EDIT_HARRIS_K, 116, 12, 36, 14, ES_AUTOHSCROLL
    LTEXT "Thresh %:", -1, 160, 14, 44, 10
    EDITTEXT IDC_EDIT_HARRIS_TPCT, 208, 12, 32, 14, ES_NUMBER

    LTEXT "NMS r:", -1, 14, 34, 40, 10
    EDITTEXT IDC_EDIT_HARRIS_NMSR, 58, 32, 24, 14, ES_NUMBER
    LTEXT "MaxN:", -1, 86, 34, 28, 10
    EDITTEXT IDC_EDIT_HARRIS_MAXN, 116, 32, 36, 14, ES_NUMBER
    AUTOCHECKBOX "Replicate border", IDC_CHK_HARRIS_REPL, 160, 34, 90, 12

    GROUPBOX "Render", -1, 14, 52, 226, 46
    AUTORADIOBUTTON "Overlay", IDC_RAD_HARRIS_OVERLAY, 24, 66, 52, 10, WS_TABSTOP
    AUTORADIOBUTTON "Heatmap", IDC_RAD_HARRIS_HEATMAP, 84, 66, 56, 10
    LTEXT "Cross:", -1, 148, 66, 30, 10
    EDITTEXT IDC_EDIT_HARRIS_CROSS, 182, 64, 24, 14, ES_NUMBER

    LTEXT "Color (R,G,B):", -1, 14, 104, 60, 10
    EDITTEXT IDC_EDIT_HARRIS_COLOR_R, 80, 102, 28, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_HARRIS_COLOR_G, 112, 102, 28, 14, ES_NUMBER
    EDITTEXT IDC_EDIT_HARRIS_COLOR_B, 144, 102, 28, 14, ES_NUMBER

    DEFPUSHBUTTON "OK", IDOK,  130, 150, 44, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 180, 150, 44, 16
END

// 메뉴 & 가속키
POPUP "&Features"
BEGIN
    MENUITEM "Harris Corners...\tCtrl+Shift+H", ID_MENU_HARRIS
END

IDR_ACCEL ACCELERATORS
BEGIN
    "H", ID_MENU_HARRIS, VIRTKEY, CONTROL, SHIFT
END
```

### 대화 상자 코드

```cpp
// HarrisDlg.h
#pragma once
#include <windows.h>
#include "resource.h"
#include "Harris.hpp"

class HarrisDlg {
public:
    HarrisDlg(HWND owner, IppDib& dib): owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
    INT_PTR OnInit(HWND);
    INT_PTR OnCommand(HWND, WPARAM, LPARAM);

    double ReadDouble(HWND h, int id, double def) const;
    int    ReadInt   (HWND h, int id, int def) const;
    bool   IsChecked (HWND h, int id) const { return IsDlgButtonChecked(h,id)==BST_CHECKED; }

private:
    HWND owner_{};
    IppDib& dib_;
};
```

```cpp
// HarrisDlg.cpp
#include "HarrisDlg.h"

INT_PTR HarrisDlg::DoModal(){
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_HARRIS_DLG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK HarrisDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l){
    if (m==WM_INITDIALOG){ SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(HarrisDlg*)l; return self->OnInit(h); }
    auto* self=(HarrisDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    if (m==WM_COMMAND) return self->OnCommand(h,w,l);
    return FALSE;
}
INT_PTR HarrisDlg::OnInit(HWND h){
    SetDlgItemTextW(h, IDC_EDIT_HARRIS_SIGMA, L"1.4");
    SetDlgItemTextW(h, IDC_EDIT_HARRIS_K,     L"0.04");
    SetDlgItemInt  (h, IDC_EDIT_HARRIS_TPCT,  10, FALSE);
    SetDlgItemInt  (h, IDC_EDIT_HARRIS_NMSR,   3, FALSE);
    SetDlgItemInt  (h, IDC_EDIT_HARRIS_MAXN, 200, FALSE);
    CheckDlgButton (h, IDC_CHK_HARRIS_REPL, BST_CHECKED);
    SetDlgItemInt  (h, IDC_EDIT_HARRIS_CROSS,  4, FALSE);
    SetDlgItemInt  (h, IDC_EDIT_HARRIS_COLOR_R, 16, FALSE);
    SetDlgItemInt  (h, IDC_EDIT_HARRIS_COLOR_G,255, FALSE);
    SetDlgItemInt  (h, IDC_EDIT_HARRIS_COLOR_B, 32, FALSE);
    CheckRadioButton(h, IDC_RAD_HARRIS_OVERLAY, IDC_RAD_HARRIS_HEATMAP, IDC_RAD_HARRIS_OVERLAY);
    return TRUE;
}
double HarrisDlg::ReadDouble(HWND h, int id, double def) const{
    wchar_t buf[64]; if (!GetDlgItemTextW(h, id, buf, 63)) return def;
    try { return std::stod(std::wstring(buf)); } catch(...) { return def; }
}
int HarrisDlg::ReadInt(HWND h, int id, int def) const{
    BOOL ok=FALSE; int v=GetDlgItemInt(h, id, &ok, FALSE); return ok? v : def;
}
INT_PTR HarrisDlg::OnCommand(HWND h, WPARAM w, LPARAM){
    switch (LOWORD(w)){
    case IDOK: {
        HarrisOptions opt;
        opt.sigma = ReadDouble(h, IDC_EDIT_HARRIS_SIGMA, 1.4);
        opt.k     = ReadDouble(h, IDC_EDIT_HARRIS_K,     0.04);
        opt.threshPercent = ReadInt(h, IDC_EDIT_HARRIS_TPCT, 10);
        opt.nmsRadius     = ReadInt(h, IDC_EDIT_HARRIS_NMSR,  3);
        opt.maxCorners    = ReadInt(h, IDC_EDIT_HARRIS_MAXN, 200);
        opt.replicateBorder = IsChecked(h, IDC_CHK_HARRIS_REPL);
        opt.crossSize     = ReadInt(h, IDC_EDIT_HARRIS_CROSS, 4);
        int R = ReadInt(h, IDC_EDIT_HARRIS_COLOR_R, 16);
        int G = ReadInt(h, IDC_EDIT_HARRIS_COLOR_G,255);
        int B = ReadInt(h, IDC_EDIT_HARRIS_COLOR_B, 32);
        opt.colorR=(uint8_t)clampi(R,0,255);
        opt.colorG=(uint8_t)clampi(G,0,255);
        opt.colorB=(uint8_t)clampi(B,0,255);
        opt.out = (IsDlgButtonChecked(h, IDC_RAD_HARRIS_HEATMAP)==BST_CHECKED)
                    ? HarrisOut::Heatmap : HarrisOut::Overlay;

        IppDib out; std::vector<Corner> pts;
        if (HarrisDetect(dib_, out, opt, &pts)) dib_ = out;

        EndDialog(h, IDOK); return TRUE;
    }
    case IDCANCEL:
        EndDialog(h, IDCANCEL); return TRUE;
    }
    return FALSE;
}
```

### 메뉴/메시지 처리

```cpp
// main_multiwin.cpp (발췌)
#include "HarrisDlg.h"

// ...
case ID_MENU_HARRIS:
    if (st && st->dib){
        HarrisDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK){
            InvalidateRect(hWnd, nullptr, FALSE);
            OutputBasicInfo(st); UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 예제 & 상황

### 예제 A) **체스보드 코너(카메라 캘리브레이션 전처리)**

- **상황**: 체스보드 패턴의 정확한 코너 추출 필요
- **설정**: σ=1.2, k=0.04, Thresh=10%, NMS r=3, MaxN=1000, Overlay
- **결과**: 격자 교차점마다 선명한 코너. (정렬/서브픽셀 보정은 후속 단계로 확장 가능)

### 예제 B) **문서 윤곽/코너 추정**

- **상황**: 스캔/카메라 촬영 문서 4개 코너 검출 → 투시 보정
- **설정**: σ=1.6, Thresh=8%, NMS r=5, MaxN=200
- **결과**: 종이 외곽과 내부 직교선 교차점에서 강한 코너가 추출 → 4개 상위 코너로 정제

### 예제 C) **특징 매칭(트래킹)용 키포인트**

- **상황**: 간단한 트래커/매칭(SSD/NCC) 전처리
- **설정**: σ=1.4, Thresh=6~12%, NMS r=6, MaxN=500
- **결과**: 평탄/에지보다 **코너**가 풍부하게 선택되어 **매칭 안정성** 증가

### 예제 D) **히트맵으로 튜닝**

- **상황**: 파라미터 감 잡기
- **동작**: Output=Heatmap으로 R 분포 확인 → Thresh%/σ/NMS 반경 조절

---

## 정확성·성능·확장 팁

- **정확성**
  - \(\sigma\) 가 클수록 더 **넓은 영역**의 구조를 고려 → 노이즈 강건 but 미세 코너 감소
  - \(k\) 는 에지 억제 정도에 영향. 0.04를 시작점으로 0.06까지 미세 조정
  - **NMS 반경**이 너무 작으면 중복 코너, 너무 크면 근접 코너가 사라짐

- **성능**
  - 가우시안은 **분리 합성**으로 \(O(WH\cdot K)\)
  - 큰 영상은 행 블록 **멀티스레딩**으로 가속
  - Harris는 모든 픽셀을 스캔하므로 **ROI** 한정 시 효율↑

- **확장**
  - **Shi–Tomasi(Good Features to Track)**: \(R=\min(\lambda\_1,\lambda\_2)\) 를 스코어로 사용
    - 구현: \(\operatorname{trace}\)와 \(\det\)으로 **고유값 근사** 가능
  - **서브픽셀 정제**: \(3\times 3\) 주변 2차 곡면 피팅으로 극값 위치 보정
  - **저조도/노이즈**: 8.5절의 **비선형 필터**(미디언/비등방 확산) 후 적용

---

## 수학 보조 메모

- 구조 텐서
\[
M =
\begin{bmatrix}
S(I\_x^2) & S(I\_x I\_y)\\
S(I\_x I\_y) & S(I\_y^2)
\end{bmatrix},
\quad S(\cdot) = \text{가우시안 누적}
\]
- 응답
\[
R = (S(I\_x^2)\cdot S(I\_y^2) - S(I\_x I\_y)^2) - k \cdot (S(I\_x^2)+S(I\_y^2))^2
\]
- 고유값 근사:
\[
\lambda\_{1,2} = \frac{\operatorname{tr} \pm \sqrt{\operatorname{tr}^2 - 4\det}}{2}
\]
(Shi–Tomasi는 \(\min(\lambda\_1,\lambda\_2)\) 사용)

---

## 간단 테스트 스니펫

```cpp
// test_harris.cpp
#include <cassert>
#include "Harris.hpp"

int main(){
    const int W=128, H=128;
    IppDib img; img.create(W,H,32);
    // 흰 사각형(좌상단 16,16 ~ 우하단 96,96)
    for (int y=0;y<H;++y){
        uint8_t* d=(uint8_t*)img.bits()+ (size_t)y*img.stride();
        for (int x=0;x<W;++x){
            bool inside = (x>=16 && x<=96 && y>=16 && y<=96);
            uint8_t g = inside? 255 : 0;
            d[x*4+0]=d[x*4+1]=d[x*4+2]=g; d[x*4+3]=255;
        }
    }
    HarrisOptions opt; opt.sigma=1.2; opt.k=0.04; opt.threshPercent=5; opt.nmsRadius=3; opt.maxCorners=20;
    IppDib out; std::vector<Corner> pts;
    bool ok = HarrisDetect(img, out, opt, &pts); assert(ok);
    // 사각형 모서리 부근 코너가 4개 이상
    assert((int)pts.size() >= 4);
    return 0;
}
```

---

## 요약

- 해리스 코너는 **구조 텐서**의 고유값 정보를 \(R=\det(M)-k\,\operatorname{tr}^2(M)\) 로 압축해 **코너 강도**를 산출합니다.
- 본 구현은 **Sobel→가우시안 누적→해리스 응답→NMS/임계→렌더링**까지 일괄 제공.
- 대화 상자/메뉴로 **σ, k, Thresh%, NMS r, MaxN, 출력 모드/색상**을 즉시 조절 가능.
- 체스보드/문서/트래킹 등 **전처리 핵심 특징점**으로 실전 활용도가 매우 높습니다.
