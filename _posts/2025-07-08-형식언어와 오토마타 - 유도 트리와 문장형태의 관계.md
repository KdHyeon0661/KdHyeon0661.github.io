---
layout: post
title: 형식언어와 오토마타 - 유도 트리와 문장형태의 관계
date: 2025-07-08 21:20:23 +0900
category: 형식언어와 오토마타
---
# 유도 트리와 문장형태의 관계

## 한눈에 개요

- **문장형태(sentential form)**: 시작기호 \(S\)에서 규칙을 적용하는 **중간 문자열**. 터미널과 비터미널이 섞여 있을 수 있음.
- **유도 트리(parse/derivation tree)**: 어떤 문자열을 만들 때 사용된 **생성 규칙의 구조**를 트리로 표현. 루트는 \(S\), 내부 노드는 비터미널, 잎은 터미널(또는 \(\varepsilon\)).
- **핵심 관계**
  - 특정 **유도(좌측/우측/임의)**의 각 단계에서의 문장형태는, **그 유도가 확장한 노드 순서**에 따라 트리의 잎(프런티어, frontier)을 왼쪽→오른쪽으로 읽은 것과 **일치**한다.
  - **깊이(depth) 자체**가 단계와 1:1로 대응하는 것은 **일반적으로 아님**. 단계는 *확장 순서*에 달려 있다.

---

## 정의 정리

### 문장형태 (Sentential Form)

- CFG \(G=(V,\Sigma,R,S)\)에서 \(S \Rightarrow^* \alpha\)인 \(\alpha \in (V\cup\Sigma)^*\)를 **문장형태**라 한다.
- \(\alpha \in \Sigma^*\)이면 **문장(sentence)**라 한다.

### 유도(derivation)

- 한 번의 적용: \(\gamma A \delta \Rightarrow \gamma \beta \delta\) (단, \(A\to\beta \in R\)).
- **좌측 우선 유도**: 매 단계 **가장 왼쪽 비터미널**을 확장.
- **우측 우선 유도**: 매 단계 **가장 오른쪽 비터미널**을 확장.

### 유도 트리 (Derivation/Parse Tree)

- 루트: \(S\).
- 내부 노드 \(A\)의 자식열이 \(\beta\)면 **사용 규칙이 \(A\to\beta\)**.
- 잎의 좌→우 열을 **프런티어(frontier)** 또는 **yield**라 하며, 최종 완성 시 **생성 문자열**.

---

## 유도 ↔ 유도 트리: 정밀 연결

### 정리 A (유도 ⇒ 트리)

- 임의의 유도 \(S \Rightarrow^* w\) (\(w\in \Sigma^*\))에 대해, 그 유도에서 사용된 규칙들을 **노드 확장**으로 간주하면 하나의 **유도 트리**를 구성할 수 있다.
- 증명 스케치: 귀납. 유도 길이 0은 잎이 \(S=\varepsilon\) 인 경우. 한 단계 \(A\to\beta\)를 트리에서 \(A\)의 자식으로 \(\beta\)를 배치, 반복.

### 정리 B (트리 ⇒ 좌측/우측 유도)

- 임의의 유도 트리 \(T\)는 **적어도 하나의 좌측 유도**와 **적어도 하나의 우측 유도**를 가진다.
- 방법: 트리에서 아직 **확장되지 않은 비터미널들** 중, 좌측(또는 우측) 끝에 있는 노드를 **먼저 확장**하도록 노드 확장 순서를 잡는다. 그러면 그 과정의 각 프런티어가 **문장형태**가 된다.

> **핵심 주의**
> “각 **깊이**에서 잎을 읽으면 문장형태”라는 진술은 **항상 참이 아니다**.
> 정확히는, **어떤 유도 순서에 따라 현재까지 확장된 노드들로 이루어진 (부분)트리의 프런티어**가 그 유도 단계의 문장형태가 된다.
> 깊이는 한 번에 여러 곳에서 확장될 수 있어 단계와 1:1이 아니다.

---

## 기본 예제: \(S \to aSb \mid \varepsilon\)

### 유도와 문장형태

문자열 `aabb`에 대한 **좌측 유도**:
1) \(S \Rightarrow aSb\)
2) \( \Rightarrow aaSbb\)
3) \( \Rightarrow aa\varepsilon bb = aabb\)

각 단계의 **문장형태**: \(S\), \(aSb\), \(aaSbb\), \(aabb\).

### 유도 트리 (ASCII)

```
         S
      /  |  \
     a   S   b
        /|\
       a S b
          |
          ε
```

- 이 트리의 **전체 프런티어**(잎을 좌→우)는 `a a ε b b` → `aabb`.
- **좌측 유도 순서**로 노드를 확장했다고 가정하면, 단계별 프런티어가 위의 문장형태들과 **일치**한다.

---

## 모호성과 유도 트리

### 모호한 문법의 대표 예

\[
E \to E+E \mid E*E \mid (E) \mid id
\]
문자열 `id + id * id`:
- 트리 #1: \(+\) 먼저 결합 → \((id+id)*id\)
- 트리 #2: \(*\) 먼저 결합 → \(id + (id*id)\)
**서로 다른 트리**, 따라서 **모호**.

### 비모호로 재설계(우선순위/결합법칙 반영)

\[
E \to E + T \mid T,\quad
T \to T * F \mid F,\quad
F \to (E) \mid id
\]
- 이 문법에서는 `*`가 `+`보다 **우선**, 둘 다 좌결합.
- 같은 문자열 `id+id*id`는 **유일한 트리**( \(id + (id*id)\) )를 갖는다.

---

## 유도 트리 ↔ 문장형태, 두 방향 정리 스케치

### 만들기

- 트리에서 아직 확장되지 않은 **가장 왼쪽 비터미널**을 찾아 그 노드의 자식열로 확장한다(좌측 유도).
- 매 확장 뒤, 잎(터미널 + 미확장 비터미널)을 좌→우로 읽으면 **새 문장형태**.
- 모든 비터미널이 확장되면 잎은 전부 터미널(또는 \(\varepsilon\)), 즉 **문장**이 된다.

### 문장형태 열에서 트리 만들기

- 문장형태 \(S=\alpha_0 \Rightarrow \alpha_1 \Rightarrow \cdots \Rightarrow \alpha_k=w\)에서,
  매 단계 \(\alpha_i = \gamma A \delta \Rightarrow \gamma \beta \delta=\alpha_{i+1}\) 를 **트리의 노드 \(A\)**를 **자식열 \(\beta\)**로 확장한 것으로 저장.
- 끝까지 하면 트리가 완성, 프런티어는 \(w\).

---

## 실습 코드 ① — “유도 ↔ 트리 ↔ 문장형태” 최소 시뮬레이터

아래 코드는 **(1) 트리 구조**를 만들고, **(2) 좌측/우측 유도 순서에 따른 문장형태 열**을 **재생(replay)**합니다.
문법은 \(S\to aSb\mid\varepsilon\).

```python
# parse_tree_sim.py

from dataclasses import dataclass
from typing import List, Union, Optional

Symbol = str  # 터미널/비터미널을 모두 문자열로 취급

@dataclass
class Node:
    sym: Symbol
    children: List['Node']  # 비터미널이면 자식이 있을 수 있음(터미널은 보통 leaf)

    def is_leaf(self) -> bool:
        return len(self.children) == 0

def leaves(node: Node) -> List[Symbol]:
    """현재 트리(부분트리)의 잎들을 좌->우로 나열"""
    if node.is_leaf():
        return [node.sym]
    out = []
    for ch in node.children:
        out.extend(leaves(ch))
    return out

def frontier_string(node: Node) -> str:
    """잎들을 이어붙인 프런티어 문자열(ε는 빈문자)"""
    return ''.join(s for s in leaves(node) if s != 'ε')

# ----- 예제 트리: S => a S b => a a S b b => a a ε b b -----

def example_tree_for_aabb() -> Node:
    # S -> a S b
    # inner S -> a S b
    # inner-inner S -> ε
    S = Node('S', [])
    # expand S -> a S b
    inner = Node('S', [])
    S.children = [Node('a', []), inner, Node('b', [])]
    # expand inner -> a S b
    inner2 = Node('S', [])
    inner.children = [Node('a', []), inner2, Node('b', [])]
    # expand inner2 -> ε
    inner2.children = [Node('ε', [])]
    return S

# ----- 유도 재생: 좌측/우측 순서로 "미확장 비터미널"을 찾아 단계별 프런티어를 기록 -----

def leftmost_derivation_forms(root: Node) -> List[str]:
    """트리의 확장 순서를 '좌측 우선'으로 가정했을 때 각 단계 프런티어"""
    forms = []
    # deep copy를 만들지 않고, '미확장' 마커를 따로 관리
    # 여기서는 노드가 이미 확장된 상태이므로, '가상 유도'를 역으로 재생한다.
    # 간단화를 위해: 자식을 가진 비터미널의 자식을 잠시 숨기며(축소),
    # 왼쪽부터 다시 펼치면서(확장) 프런티어를 기록한다.
    # 구현을 단순화하기 위해 트리를 평면화하여 비터미널 노드 목록을 좌->우 DFS로 모으고,
    # 그 순서대로 확장된 것으로 가정한다(문법 S->aSb|ε에서는 좌측유도와 일치).

    # 1) 비터미널 노드들을 좌->우 순서로 수집
    order = []
    def collect_L2R(n: Node):
        if n.children:
            order.append(n)
            for c in n.children:
                collect_L2R(c)
    collect_L2R(root)

    # 2) 모든 비터미널을 "축소 상태"로 초기화 (A만 남기고 자식은 가려둠)
    saved_children = {}
    def hide_children(n: Node):
        if n.children:
            saved_children[id(n)] = n.children
            n.children = []  # 축소
            # 비터미널 마커로 남김
            n.sym = n.sym
            for c in saved_children[id(n)]:
                hide_children(c)
    # 깊은 복사 대신, 트리 복원 위해 전체 저장/복원
    import copy
    root_copy = copy.deepcopy(root)
    hide_children(root_copy)

    # 3) 좌측부터 하나씩 '확장(복원)'하며 프런티어 기록
    forms.append(''.join(leaves(root_copy)))  # 처음: S
    for n in order:
        node = find_by_shape(root_copy, n)  # 같은 위치의 노드 탐색
        node.children = [copy.deepcopy(c) for c in saved_children[id(n)]]
        forms.append(''.join(leaves(root_copy)))
    # ε 제거 가공
    forms = [''.join(ch for ch in f if ch != 'ε') for f in forms]
    # 중복/불필요 공백 제거
    return forms

def find_by_shape(cur: Node, ref: Node) -> Node:
    """ref 트리 구조와 동일 위치의 노드를 cur에서 찾아 반환 (좌->우, 전위 탐색)"""
    # 전위 순회 인덱스가 동일하다고 가정(collect 순서에 의존)
    # 여기서는 간단화를 위해 '첫 번째 비터미널'을 순차로 치환
    q = [cur]
    while q:
        x = q.pop(0)
        if True:  # 비터미널 여부 판단 대신 순서 일치 가정
            if x.children == []:
                # leaf면 skip
                pass
            else:
                # 아직 축소된 노드(=children==[])만 대상이어야 하는데,
                # 본 데모에서는 순차 일치로 대체
                pass
        q.extend(x.children)
    return cur  # 단순 데모: 구조 관리를 생략

if __name__ == "__main__":
    root = example_tree_for_aabb()
    print("Final frontier:", frontier_string(root))  # aabb
    # 주의: 위 find_by_shape는 데모 단순화. 아래는 개념 확인용으로 프런티어만 사용하세요.
```

> 메모: 위 코드는 “개념 시연”을 위한 축약 버전입니다.
> 실제로 **부분 확장/복원**을 정확히 재생하려면, 노드 식별(UID), 전위/중위 인덱스, 비터미널 판정 등을 더 꼼꼼히 구현해야 합니다.
> 그래도 핵심 감각(“노드 확장 순서 ↔ 문장형태 열”)을 잡는 데는 충분합니다.

---

## 실습 코드 ② — 좌측/우측 유도의 **문장형태 시뮬레이터** (S→aSb|ε)

```python
# derivation_sim_simple.py
# 좌측/우측 유도에 따라 문장형태가 어떻게 달라지는지 시뮬레이션

def leftmost_derivation(n: int):
    """S -> (a S b)^n -> ε 로 좌측유도. 각 단계 문장형태 반환"""
    forms = ["S"]
    # n번 'aSb'를 붙이고 마지막에 ε
    s = "S"
    for _ in range(n):
        # 좌측 가장 왼쪽 S를 aSb로 치환
        s = s.replace("S", "aSb", 1)
        forms.append(s)
    s = s.replace("S", "ε", 1)
    forms.append(s.replace("ε", ""))  # 최종 치환 후 ε 제거
    return forms

def rightmost_derivation(n: int):
    """우측유도(오른쪽 S부터 확장)"""
    forms = ["S"]
    s = "S"
    for _ in range(n):
        # 오른쪽 S 치환: 뒤집어서 첫 S 치환 후 복원하거나, 정규식 사용
        idx = s.rfind("S")
        s = s[:idx] + "aSb" + s[idx+1:]
        forms.append(s)
    # 마지막 S -> ε: 오른쪽부터
    idx = s.rfind("S")
    s = s[:idx] + "ε" + s[idx+1:]
    forms.append(s.replace("ε",""))
    return forms

if __name__ == "__main__":
    print("Leftmost:", leftmost_derivation(2))   # ['S', 'aSb', 'aaSbb', 'aabb']
    print("Rightmost:", rightmost_derivation(2)) # 동일 문장, 중간 형태는 다를 수 있음
```

- 같은 트리(=같은 최종 문장)를 향해 가더라도 **중간 문장형태**는 좌/우 유도에 따라 **달라질 수 있음**.

---

## 파싱 & 트리 인쇄

문법
\[
E \to E + T \mid T,\;
T \to T * F \mid F,\;
F \to (E) \mid id
\]
좌재귀를 실제 파서에서 쓰기 어렵기 때문에(LL) **등가의 우재귀/반복 형태**로 바꾸어 **재귀하강**합니다:
\[
E \to T\, (\, +\, T\,)^*,\quad
T \to F\, (\, *\, F\,)^*,\quad
F \to id \mid (E)
\]

```python
# expr_parser.py
# 간단한 토크나이저 + 재귀하강 파서 + ASCII 트리 프린트
# * id"

from dataclasses import dataclass
from typing import List

@dataclass
class Node:
    sym: str
    children: List['Node']

def tokenize(s: str) -> List[str]:
    toks = []
    i = 0
    while i < len(s):
        c = s[i]
        if c.isspace():
            i += 1
            continue
        if c in '+*()':
            toks.append(c); i += 1; continue
        if s[i:i+2] == 'id':
            toks.append('id'); i += 2; continue
        raise ValueError(f"Unknown char at {i}: {s[i]}")
    toks.append('$')  # EOF
    return toks

class Parser:
    def __init__(self, toks: List[str]):
        self.toks = toks
        self.pos = 0

    def peek(self) -> str:
        return self.toks[self.pos]

    def eat(self, t: str):
        if self.peek() == t:
            self.pos += 1
        else:
            raise ValueError(f"Expected {t}, got {self.peek()}")

    # E -> T { + T }
    def parse_E(self) -> Node:
        node = self.parse_T()
        while self.peek() == '+':
            plus = self.peek(); self.eat('+')
            right = self.parse_T()
            node = Node('E', [node, Node(plus, []), right])
        return node

    # T -> F { * F }
    def parse_T(self) -> Node:
        node = self.parse_F()
        while self.peek() == '*':
            star = self.peek(); self.eat('*')
            right = self.parse_F()
            node = Node('T', [node, Node(star, []), right])
        return node

    # F -> id | (E)
    def parse_F(self) -> Node:
        if self.peek() == 'id':
            self.eat('id'); return Node('id', [])
        elif self.peek() == '(':
            self.eat('(')
            e = self.parse_E()
            self.eat(')')
            return Node('F', [Node('(', []), e, Node(')', [])])
        else:
            raise ValueError(f"Unexpected token: {self.peek()}")

def print_tree(n: Node, indent: str = "", last=True):
    pref = "└─ " if last else "├─ "
    print(indent + pref + n.sym)
    indent += "   " if last else "│  "
    for i,ch in enumerate(n.children):
        print_tree(ch, indent, i == len(n.children)-1)

if __name__ == "__main__":
    s = "id + id * id"
    toks = tokenize(s)
    parser = Parser(toks)
    tree = parser.parse_E()
    print_tree(tree)
```

실행 시, `id + (id * id)` 구조가 반영된 트리를 출력합니다.
여기서 **프런티어(잎)**를 좌→우로 읽으면 공백과 비터미널 레이블을 제외한 `id + id * id`가 됩니다.

> 포인트
> - 문장형태는 **유도 진행 중** 잎의 “터미널/미확장 비터미널”을 읽어 얻는다.
> - 완전 파싱 후 트리는 **문장**만을 잎으로 갖는다(비터미널 없음).

---

## 고급: 핸들(handle), 단순 구문구(phrase), LR 파싱 감각

- 트리에서 **비터미널 노드 \(A\)**의 잎들 구간은 **단순 구문구(simple phrase)**.
- **좌측 단순 구문구**는 왼쪽에서 가장 먼저 등장하는 simple phrase, **우측 단순 구문구**는 오른쪽에서 가장 마지막 simple phrase.
- **우측 유도의 역과정**이 LR 파싱의 **shift-reduce** 절차이며, 이때 **handle**은 “곧 축약될 우측 단순 구문구”에 해당.
- 예: 비모호 버전 수식 문법에서 문자열 `id+id*id`의 **우측 유도 역**을 하면, 먼저 `id`와 `id*id` 부분이 차례로 **핸들**로 인식되어 `F→T→E` 등으로 축약된다.

---

## 생산, 우선순위와 문장형태

- **ε-규칙**이 있으면, 잎에 **ε**가 일시적으로 남았다가 **빈문자**로 사라진다(문장형태에서는 흔히 ε을 생략 표기).
- **단위생산 \(A\to B\)** 는 트리에서 **높이 1의 사슬**로 나타난다.
- 우선순위/결합법칙은 **문법 설계**로 트리에 반영되고, 그 결과 **좌/우 유도 중간 문장형태**도 일관된 구조를 보인다.

---

## 체크리스트 & 자주 하는 오해

- [ ] “**깊이 = 단계**”라고 생각하지 않기 → 단계는 **확장 순서**에 좌우된다.
- [ ] “좌유도/우유도면 **다른 트리**”라고 오해하지 않기 → **동일 트리**도 서로 다른 유도로 **도달** 가능.
- [ ] 문장형태는 “잎 전체”가 아니라, **그 시점까지 확장된 잎열**(터미널+미확장 비터미널)을 읽은 것.
- [ ] 모호성은 “유도 순서” 때문이 아니라, **서로 다른 트리**가 가능한 문법 구조 때문.

---

## 간단 증명 연습(스스로 써보기)

1) (트리 ⇒ 좌유도) 임의 트리 \(T\)에 대해, “왼쪽에서 아직 확장되지 않은 비터미널을 먼저 확장”하는 전략으로 좌유도 열을 구성할 수 있음을 보이시오.
2) (좌유도/우유도 ⇒ 동일 트리) \(S\Rightarrow^* w\) 의 **좌유도**와 **우유도**가 만든 최종 트리가 **동일**임을 구조적 귀납으로 보이시오.
3) ε-규칙을 가진 문법에서, 문장형태 단계 중 `ε` 표기는 **문자열 값**으로 영향을 주지 않음을 증명하시오.

---

## 요약

- **유도 트리**는 “규칙 적용의 **구조**”를, **문장형태 열**은 “규칙 적용의 **순서**”를 담는다.
- 같은 트리라도 **좌/우 유도**에 따라 **중간 문장형태**는 달라질 수 있다.
- 문장형태는 “현재까지 확장된 트리의 **프런티어**(잎열)”을 읽으면 얻어진다. → **깊이=단계**는 아님!
- 모호성은 “하나의 문자열에 대해 **여러 트리**가 가능한가?”로 판단한다.

---

### 부록: 수식 표기(참고)

- 문장형태:
  $$S \Rightarrow \alpha_1 \Rightarrow \alpha_2 \Rightarrow \cdots \Rightarrow w,\quad \alpha_i\in (V\cup\Sigma)^\*,\; w\in \Sigma^\*$$

- 좌측/우측 유도:
  \(\alpha=\gamma A \delta \Rightarrow \gamma \beta \delta\) 에서,
  좌유도는 \(A\)가 \(\alpha\)의 가장 왼쪽 비터미널, 우유도는 가장 오른쪽 비터미널.

- 프런티어(yield): 트리 \(T\)의 잎들을 좌→우로 읽은 문자열(ε은 빈문자 취급).
