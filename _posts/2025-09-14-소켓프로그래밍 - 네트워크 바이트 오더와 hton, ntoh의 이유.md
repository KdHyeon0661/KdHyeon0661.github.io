---
layout: post
title: 소켓프로그래밍 - 네트워크 바이트 오더와 hton, ntoh의 이유
date: 2025-09-14 14:25:23 +0900
category: 소켓프로그래밍
---
## A. 네트워크 바이트 오더(빅엔디안)와 `hton* / ntoh*`의 이유

> 한 줄 핵심: **전 세계 이기종 CPU(빅엔디안/리틀엔디안)가 같은 규약으로 통신**하려면, **전선 위의 비트 나열 순서(=네트워크 바이트 오더)** 를 고정해야 한다. 그 표준이 **빅엔디안**, 그리고 애플리케이션은 `htons/htonl/ntohs/ntohl`로 **호스트↔네트워크** 변환을 수행한다.

---

### A.1 엔디안(Endian) 기본기

- **엔디안**은 메모리에 다바이트(2B 이상) 정수가 **어느 바이트부터 나열되는지**를 말한다.
  - **빅엔디안(Big-endian)**: 상위 바이트가 낮은 주소(“큰 놈이 앞에”).
    예) 16진수 `0x12345678` → 메모리: `12 34 56 78`
  - **리틀엔디안(Little-endian)**: 하위 바이트가 낮은 주소(“작은 놈이 앞에”).
    예) `0x12345678` → 메모리: `78 56 34 12`
- x86/x86-64, ARM 대부분의 운영 모드는 **리틀엔디안**. 일부 네트워크/임베디드/과거 RISC는 **빅엔디안**도 존재.
- 통신선(와이어) 위 **바이트 배치**를 표준화하지 않으면, 이기종 간에 숫자 해석이 **뒤집혀 오동작**한다.

---

### A.2 왜 네트워크는 “빅엔디안”인가?

- 인터넷 초창기(ARPANET, RFC 시절) 설계에서 **네트워크 바이트 오더를 빅엔디안으로 규정**했다.
- 이유는 역사적·표기적 관습(상위→하위)과 일부 당시 하드웨어의 빅엔디안 선호 영향.
- 오늘날 관점에서 중요한 건 **“한 쪽으로 일관되게 정했기 때문에”** 이질적인 CPU가 **공통의 바이트 순서**로 상호 운용 가능하다는 점.

> **용어 표기**
> - **Network Byte Order** = **Big-endian** (암기!)
> - **Host Byte Order** = **해당 머신의 엔디안**(대부분 리틀엔디안)

---

### A.3 `hton* / ntoh*` 변환군과 올바른 사용 위치

- **16비트 포트**, **32비트 IPv4 주소(구 API)**, **32/16비트 길이·시퀀스** 등 **프로토콜 필드**를 소켓 API에 넣거나 / 소켓에서 읽을 때는 **반드시 변환**을 거친다.

| 함수 | 의미 | 적용 대상(예시) |
|---|---|---|
| `htons(uint16_t)` | Host → Network (Short) | 포트(16비트) |
| `htonl(uint32_t)` | Host → Network (Long) | 길이/시퀀스(32비트) |
| `ntohs(uint16_t)` | Network → Host (Short) | 수신한 16비트 필드 |
| `ntohl(uint32_t)` | Network → Host (Long) | 수신한 32비트 필드 |

- **언제?**
  - **보내기 전**: 구조체/헤더의 다바이트 정수를 **네트워크 바이트 오더**로 변환해 버퍼에 써라.
  - **받은 후**: 수신 버퍼의 다바이트 정수를 **호스트 바이트 오더**로 변환해 해석하라.

> **규율**: “**와이어로 나가는 직전**에 hton*, **와이어에서 들어온 직후**에 ntoh*”.

---

### A.4 수식으로 보는 바이트 스왑

- 16비트에서 **엔디안 변환**은 바이트 스왑과 동일:
  $$
  \text{swap16}(x) = ((x \ll 8) \ \&\ 0xFF00) \ \vert\ ((x \gg 8) \ \&\ 0x00FF)
  $$
- 32비트:
  $$
  \text{swap32}(x) = ((x \ll 24) \& 0xFF000000) \ \vert\ ((x \ll 8) \& 0x00FF0000) \ \vert\ ((x \gg 8) \& 0x0000FF00) \ \vert\ ((x \gg 24) \& 0x000000FF)
  $$
- 실제로 많은 라이브러리가 **호스트 엔디안이 리틀**이면 내부에서 바이트 스왑을 수행, **빅**이면 **no-op**.

---

### A.5 C++23에서의 현대적 도구: `std::endian`, `std::byteswap`

- `<bit>`의 `std::endian`으로 **컴파일 타임에 엔디안**을 식별할 수 있다.
- C++23의 `std::byteswap`은 바이트 스왑을 **표준 함수**로 제공한다.

```cpp
#include <bit>
#include <cstdint>
#include <print>

constexpr uint16_t to_net16(uint16_t x) {
    if constexpr (std::endian::native == std::endian::little)
        return std::byteswap(x);
    else
        return x; // big-endian host면 그대로
}

constexpr uint32_t to_net32(uint32_t x) {
    if constexpr (std::endian::native == std::endian::little)
        return std::byteswap(x);
    else
        return x;
}

int main() {
    uint16_t port = 0x1234; // 4660
    auto be = to_net16(port);
    std::println("host: 0x{:04X}, net: 0x{:04X}", port, be);
}
```

> 실무에서는 여전히 **`htons/htonl`** 을 쓰는 게 이식성/명확성 측면에서 표준적이다.
> 다만 **자체 직렬화**(예: TLV 헤더) 구현 시 `std::byteswap` + `std::endian`이 편리하다.

---

### A.6 잘못된 예와 올바른 예

#### 잘못된 예 (포트를 네이티브 엔디안으로 `bind`)
```cpp
sockaddr_in sa{};
sa.sin_family = AF_INET;
sa.sin_port   = 9000;          // ❌ 리틀엔디안 시스템이면 0x2328 → 전선에는 거꾸로
inet_pton(AF_INET, "0.0.0.0", &sa.sin_addr);
bind(fd, (sockaddr*)&sa, sizeof(sa)); // 포트가 엉뚱하게 잡힘
```

#### 올바른 예
```cpp
sockaddr_in sa{};
sa.sin_family = AF_INET;
sa.sin_port   = htons(9000);   // ✅ 반드시 htons
inet_pton(AF_INET, "0.0.0.0", &sa.sin_addr);
bind(fd, (sockaddr*)&sa, sizeof(sa));
```

#### 수신 필드 해석 시 올바른 예
```cpp
// 네트워크로부터 온 4바이트 길이 필드
uint32_t net_len;
std::memcpy(&net_len, buf, 4);
uint32_t len = ntohl(net_len); // ✅ 이제 호스트 엔디안 정수
```

---

### A.7 구조체를 “그대로” 보내면 안 되는 이유

1) **엔디안**: 필드가 네트워크 엔디안이어야 하는데, 호스트 엔디안 그대로면 이기종에서 깨진다.
2) **패딩/정렬**: 컴파일러의 **패딩 바이트**로 인해 구조체 레이아웃이 플랫폼마다 달라질 수 있다.
3) **UB 위험**: `reinterpret_cast`로 곧장 바이트화를 하면 **엄격 별칭(Strict aliasing)**, **정렬(Alignment)** 문제를 유발 가능.

> **원칙**: **직렬화/역직렬화 함수를 명시적으로** 작성하라. 각 필드를 **htons/htonl** 등으로 변환해 **바이트 버퍼**에 쓴 뒤 전송하라.

```cpp
struct MsgHeader {
    uint16_t type;   // host-endian
    uint32_t length; // host-endian
};

void encode_header(std::byte* out, const MsgHeader& h) {
    uint16_t t = htons(h.type);
    uint32_t l = htonl(h.length);
    std::memcpy(out+0, &t, 2);
    std::memcpy(out+2, &l, 4);
}

bool decode_header(const std::byte* in, MsgHeader& h) {
    uint16_t t; uint32_t l;
    std::memcpy(&t, in+0, 2);
    std::memcpy(&l, in+2, 4);
    h.type   = ntohs(t);
    h.length = ntohl(l);
    return true;
}
```

---

### A.8 64비트가 필요하다면? (`htonll`이 없다면)

- POSIX에는 표준 `htonll`/`ntohll`이 없다(플랫폼 확장 정의가 있기도).
- C++23이라면 `std::byteswap(uint64_t)` 를 이용해 **직접 구현** 가능.

```cpp
constexpr uint64_t to_net64(uint64_t x) {
    if constexpr (std::endian::native == std::endian::little)
        return std::byteswap(x);
    else
        return x;
}
constexpr uint64_t to_host64(uint64_t x) { return to_net64(x); }
```

---

### A.9 엔디안 버그를 “눈”으로 확인하는 빠른 실험

```cpp
// endian_probe.cpp
#include <arpa/inet.h>
#include <cstdint>
#include <cstdio>

int main() {
    uint16_t p = 0x1234;
    uint16_t n = htons(p);
    std::printf("host=0x%04X, htons=0x%04X\n", p, n);

    uint8_t* pb = reinterpret_cast<uint8_t*>(&p);
    uint8_t* nb = reinterpret_cast<uint8_t*>(&n);
    std::printf("host bytes: %02X %02X\n", pb[0], pb[1]);
    std::printf("net  bytes: %02X %02X\n", nb[0], nb[1]);
}
```

- **리틀엔디안** 머신이라면 출력이 대략:
  ```
  host=0x1234, htons=0x3412
  host bytes: 34 12
  net  bytes: 12 34
  ```
- 바이트 순서가 **뒤집히는** 것을 눈으로 확인하라.

---

## B. 파일 디스크립터(fd)로서의 소켓: `read/write/close`가 통하는 배경

> 한 줄 핵심: 유닉스 철학 **“모든 것은 파일”**. 커널은 **파일 디스크립터 테이블**로 **열린 객체(정규파일, 파이프, 소켓, 디바이스)** 를 관리한다. **소켓도 fd**이므로 `read/write/close`가 가능하고, `select/poll/epoll` 같은 **fd 기반 멀티플렉싱**이 동작한다.

---

### B.1 사용자 공간과 커널의 경계: 시스템 콜과 fd

- 프로세스는 **정수 인덱스(fd)** 로 열린 객체를 식별한다.
- 각 프로세스는 **fd 테이블**을 가진다: 0=stdin, 1=stdout, 2=stderr, 그 외 `open/socket/pipe` 등으로 얻은 fd.
- **소켓** 생성은 `socket()` 시스템 콜 → 커널에 **소켓 객체**가 만들어지고 fd가 반환.

---

### B.2 왜 소켓에 `read/write`가 통하는가?

- 커널 내부에서 **소켓 파일 연산 테이블(file operations)** 이 **읽기/쓰기** 인터페이스를 구현한다.
- 그래서 애플리케이션은 **정규 파일과 유사한** 인터페이스로 **소켓 I/O**를 수행할 수 있다.
- 소켓 전용 확장 동작이 필요할 땐 **`send/recv`** (플래그, 주소 포함), **`setsockopt/getsockopt`**, **`ioctl`** 을 사용.

> 차이점
> - 정규 파일의 `read/write`는 **디스크** I/O, 소켓의 `read/write`는 **네트워크 스택**을 통해 NIC로.
> - 소켓에는 **연결 상태**, **송·수신 버퍼**, **TCP 상태 머신** 등이 존재한다.

---

### B.3 `read/write` vs `recv/send` (소켓에서 무엇을 쓸까?)

- `read/write`는 **POSIX 범용** I/O. 소켓에서도 동작하지만 **부가 플래그**를 못 건다.
- `recv/send`는 **소켓 전용** I/O로, 다음 장점이 있다.
  - `recv(fd, buf, len, MSG_DONTWAIT)` → 호출 단위 비차단
  - `send(fd, buf, len, MSG_NOSIGNAL)` → **SIGPIPE** 방지(상대가 끊었을 때 프로세스 종료 방지)
  - `recvfrom/sendto` → **UDP 주소** 동반 I/O
- **실무 팁**: TCP 스트림에서는 `send/recv` 선호(플래그 활용), 간단 케이스는 `read/write`도 무방.

---

### B.4 `close`와 `shutdown`(half-close)의 의미

- `close(fd)`: **해당 fd 참조 해제**. 참조가 0이 되면 커널 객체가 해제(소켓이면 연결도 종료 루틴).
- `shutdown(fd, SHUT_WR)`: **송신만 종료(half-close)**, 수신은 계속 가능.
  - 예) 요청 송신 후 더 이상 보낼 건 없지만 **답은 받아야 할 때** 유용(HTTP/1.0 스타일).
- `shutdown(fd, SHUT_RD)`: 수신 스트림을 닫음(더 받지 않겠다).
- `shutdown(fd, SHUT_RDWR)`: 양방향 종료(상대에게도 알림).

> **반드시 기억**: TCP 종료는 **4-way**가 일반적이며, half-close를 통해 **반이중 종료**를 표현한다.

---

### B.5 `dup/dup2`/fork 상속: fd의 복제와 공유

- `dup/dup2`는 **같은 커널 객체**를 가리키는 **새 fd**를 만든다(참조 카운트 증가).
- `fork()` 후 자식 프로세스는 부모의 fd 테이블을 **복사**(참조 공유).
  - **파이프/소켓**으로 **프로세스 간 통신**을 구성할 수 있다.
- `exec()`로 새 프로그램을 실행해도 **CLOEXEC**이 아니면 fd가 넘어간다.

---

### B.6 `select/poll/epoll`이 “fd” 기반인 이유

- **fd는 커널 I/O 객체의 공통 분모**.
- `select/poll/epoll`은 **fd의 준비 상태**(읽기/쓰기/예외)를 알려준다.
- 따라서 **정규 파일, 파이프, 소켓**을 한 이벤트 루프에서 **통일적으로** 감시 가능.
  - (정규 파일은 보통 “항상 즉시 읽기 가능”이라 이벤트 감시 의미가 적지만, 소켓/파이프는 유용)

---

### B.7 실험: 파이프 vs 소켓 — 동일한 `read/write` 패턴

```cpp
// fd_unify_demo.cpp — 파이프/소켓 모두 read/write로 동작하는 모습 (요지)
#include <sys/socket.h>
#include <unistd.h>
#include <cstring>
#include <cstdio>

int main(){
    int sv[2];
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) != 0) return 1;

    const char* msg = "hello";
    write(sv[0], msg, std::strlen(msg));   // 소켓에도 write가 통한다
    char buf[16]{};
    read(sv[1], buf, sizeof(buf));         // 반대편에서 read
    std::printf("got: %s\n", buf);

    close(sv[0]); close(sv[1]);
}
```

- 결과: `got: hello`
- **UNIX 도메인 소켓**이지만, TCP/UDP 소켓도 **동일한 I/O 인터페이스**로 접근 가능하다는 점을 보여준다.

---

### B.8 SIGPIPE와 `MSG_NOSIGNAL` (소켓의 “파일과 다른” 함정)

- 정규 파일에 `write` 하다 대상이 사라져도 SIGPIPE는 흔치 않다.
- **소켓에서** 상대가 이미 닫은 상태로 `send/write` 하면 **SIGPIPE** 신호가 올 수 있고, **프로세스가 종료**될 수 있다.
  - 리눅스: `send(..., MSG_NOSIGNAL)` 또는 `signal(SIGPIPE, SIG_IGN)` 으로 무시
  - macOS/BSD: `SO_NOSIGPIPE` 옵션 존재

```cpp
int yes = 1;
#ifdef SO_NOSIGPIPE
setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, &yes, sizeof(yes));
#endif
// 또는
send(fd, data, len, MSG_NOSIGNAL);
```

---

### B.9 `read/write`가 보여주지 않는 소켓 특화 정보

- **상대 주소/포트**: `read/write` 자체로는 알 수 없다 → `getpeername/getsockname` 사용
- **소켓 옵션/상태**: `getsockopt/setsockopt`로 접근 (예: `TCP_NODELAY`, 버퍼 크기, keepalive 등)
- **Out-of-band/peek**: `recv` 플래그 (`MSG_OOB`, `MSG_PEEK`) 로만 접근되는 기능들

---

### B.10 “fd로서의 소켓”을 이해하면 쉬워지는 것들

1) **리디렉션/파이프라인**: 프로세스 간 연결을 **fd 복제**로 구성
2) **이벤트 루프**: **하나의 인터페이스(select/poll/epoll)** 로 다종 I/O를 관리
3) **자원 관리**: RAII로 fd 소유권을 명확히 → 누수/이중 close 방지

```cpp
// C++23 얇은 RAII (요지)
struct unique_fd {
    int fd{-1};
    ~unique_fd(){ if(fd!=-1) ::close(fd); }
    unique_fd() = default;
    explicit unique_fd(int f):fd(f){}
    unique_fd(const unique_fd&) = delete;
    unique_fd& operator=(const unique_fd&) = delete;
    unique_fd(unique_fd&& o) noexcept : fd(std::exchange(o.fd,-1)){}
    unique_fd& operator=(unique_fd&& o) noexcept {
        if (this!=&o) { if(fd!=-1) ::close(fd); fd=std::exchange(o.fd,-1); }
        return *this;
    }
};
```

---

### B.11 실무 체크리스트

- [ ] **네트워크로 나갈 모든 다바이트 정수**는 `htons/htonl` 등으로 **네트워크 엔디안**에 맞춰라.
- [ ] 수신 즉시 `ntohs/ntohl` 로 **호스트 엔디안**으로 돌려 해석하라.
- [ ] 구조체는 **그대로 송수신 금지**: **명시적 직렬화/역직렬화** 작성.
- [ ] **fd 수명**은 RAII로: 예외/에러 시에도 **항상 close**.
- [ ] 소켓 I/O는 `send/recv` 선호(플래그 활용), **SIGPIPE** 대책 마련.
- [ ] half-close(`shutdown`) 의미를 정확히 이해하고 사용.
- [ ] 이벤트 대기는 fd 기반(`select/poll/epoll`) — 소켓이 “파일처럼” 다뤄지는 이유.

---

### B.12 미니 과제

1) **엔디안 혼선 재현**
   - 서버: 포트를 `htons` 없이 `bind`하도록 고의 버그를 넣고, 클라이언트가 접속 실패/오접속하는지 실험.
   - 수정 후 `htons` 적용 시 정상 동작 확인.

2) **직렬화 챌린지**
   - 헤더 `{version:1B, type:1B, length:2B, req_id:4B}` 를 설계하고, **네트워크 엔디안**으로 버퍼에 쓰는 `encode`, 수신 버퍼에서 읽는 `decode` 작성.
   - `tcpdump` 로 실제 패킷의 바이트 배열이 **기대한 순서**인지 검증.

3) **SIGPIPE 관측**
   - 클라이언트가 서버에 연결 후 즉시 종료. 서버가 그 소켓에 `send()` 를 두 번 연속 호출하도록 해서 **SIGPIPE** 발생 여부 관찰.
   - `MSG_NOSIGNAL` 적용 시 차이 비교.

---

### B.13 요약

- **네트워크 바이트 오더 = 빅엔디안**. 이 규약이 있기에 **이기종 간** 바이트 해석이 일치한다.
- 애플리케이션은 **와이어 직전/직후**에 `hton* / ntoh*`를 수행해야 한다.
- **소켓은 fd**다. 그래서 `read/write/close`가 통하고, **fd 기반 이벤트 멀티플렉싱**이 가능하다.
- 단, 소켓은 파일과 달리 **연결/버퍼/상태 머신**을 갖고 있으며, `send/recv` 플래그, `shutdown`, `setsockopt` 같은 **전용 기능**을 적절히 활용해야 한다.
