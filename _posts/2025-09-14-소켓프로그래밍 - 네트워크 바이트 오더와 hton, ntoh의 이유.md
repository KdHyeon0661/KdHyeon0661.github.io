---
layout: post
title: 소켓프로그래밍 - 네트워크 바이트 오더와 hton, ntoh의 이유
date: 2025-09-14 14:25:23 +0900
category: 소켓프로그래밍
---
# 네트워크 바이트 오더와 fd로서의 소켓

## 1. 엔디안과 네트워크 바이트 오더

### 1.1 엔디안 기본기 — “숫자를 메모리에 어떻게 쌓을 것인가”

정수형(16비트 이상) 값 하나를 메모리에 쓸 때, **바이트를 어떤 순서로 배치할지**가 바로 **엔디안(Endianness)** 이다.

- **빅엔디안(Big-endian)**  
  - 상위 바이트(MSB, Most Significant Byte)가 낮은 주소에 온다.  
  - 예) 32비트 정수 `0x12345678` 을 주소 `p` 에 저장한다고 할 때:

    | 주소 | 값 |
    |------|----|
    | `p+0` | `0x12` |
    | `p+1` | `0x34` |
    | `p+2` | `0x56` |
    | `p+3` | `0x78` |

- **리틀엔디안(Little-endian)**  
  - 하위 바이트(LSB)가 낮은 주소에 온다.  
  - 같은 값 `0x12345678` 의 메모리 배치:

    | 주소 | 값 |
    |------|----|
    | `p+0` | `0x78` |
    | `p+1` | `0x56` |
    | `p+2` | `0x34` |
    | `p+3` | `0x12` |

현대 데스크톱/서버 CPU의 **대부분(x86-64, 일반적인 ARM 서버/모바일 모드 등)** 은 **리틀엔디안**이다.:contentReference[oaicite:0]{index=0}  
일부 네트워크 장비, 디지털 시그널 프로세서, 구형 RISC CPU 등은 빅엔디안이거나 듀얼 엔디안(둘 다 지원)이기도 하다.:contentReference[oaicite:1]{index=1}

여기서 중요한 포인트:

- **“엔디안”은 메모리 상의 바이트 배치 규칙**이다.
- CPU가 덧셈/곱셈을 할 때는 내부적으로 알아서 처리하므로, 우리가 신경 쓸 것은 **“메모리에 저장된 바이트를 다른 시스템이 어떤 순서로 해석할 것인가”** 이다.

---

### 1.2 왜 네트워크 바이트 오더는 “빅엔디안”인가

인터넷 초기 RFC 들에서는 **“Network Byte Order”를 빅엔디안으로 정의**했다. IP/TCP/UDP 헤더의 모든 다바이트 정수 필드는 **네트워크 바이트 오더(= 빅엔디안)** 로 전송해야 한다고 규정되어 있다.:contentReference[oaicite:2]{index=2}

정리하면:

- **Network Byte Order = Big-endian** (암기 사항)
- **Host Byte Order = 해당 머신의 엔디안** (대부분 리틀엔디안)

역사적인 이유는 복합적이다.

- 당시 많이 쓰이던 일부 메인프레임/미니컴퓨터가 빅엔디안에 친숙했다.
- 사람이 숫자를 쓸 때 **상위 자리부터** 쓰는 표기(예: 1234에서 1이 가장 왼쪽)와 같은 감각.
- 무엇보다 중요한 건 **“표준 하나로 고정했다”** 는 점이다.

만약 “네트워크 바이트 오더” 규칙이 없다면:

- 리틀엔디안 CPU가 포트 80을 `0x0050` 으로 메모리에 저장.
- 빅엔디안 CPU가 같은 2바이트를 `0x0050` → `0x5000` 으로 잘못 해석.
- 이기종(heterogeneous) 네트워크 통신이 **완전히 깨진다**.

---

### 1.3 `hton* / ntoh*` 변환군 — 언제, 어디서 써야 하는가

소켓 API와 프레이밍 프로토콜에서 **다바이트 정수**를 안전하게 주고받기 위해 POSIX는 다음 네 가지 함수를 제공한다:

| 함수 | 방향 | 의미 | 보통 쓰는 곳 |
|------|------|------|--------------|
| `htons(uint16_t)` | Host → Network | 16비트 정수를 네트워크(빅엔디안)로 변환 | 포트 번호(16비트) |
| `htonl(uint32_t)` | Host → Network | 32비트 정수를 네트워크로 | IPv4 주소(구 API), 길이 필드, 시퀀스 번호 등 |
| `ntohs(uint16_t)` | Network → Host | 16비트 네트워크 정수를 호스트 엔디안으로 | 수신 포트, 16비트 헤더 필드 |
| `ntohl(uint32_t)` | Network → Host | 32비트 네트워크 정수를 호스트 엔디안으로 | 수신 길이, 시퀀스, IPv4 주소 등 |

**규율(강력 추천)**:

- **와이어로 나가기 직전**에 `htons/htonl` 로 **호스트 → 네트워크** 변환.
- **와이어에서 들어온 직후**에 `ntohs/ntohl` 로 **네트워크 → 호스트** 변환.

#### 1.3.1 사용 위치 예 — 포트 번호 바인드

잘못된 예:

```cpp
sockaddr_in sa{};
sa.sin_family = AF_INET;
sa.sin_port   = 9000;                    // ❌ 네이티브 엔디안 그대로
inet_pton(AF_INET, "0.0.0.0", &sa.sin_addr);
bind(fd, (sockaddr*)&sa, sizeof(sa));    // 리틀엔디안이면 포트가 뒤집힌다
```

올바른 예:

```cpp
sockaddr_in sa{};
sa.sin_family = AF_INET;
sa.sin_port   = htons(9000);             // ✅ 네트워크 바이트 오더
inet_pton(AF_INET, "0.0.0.0", &sa.sin_addr);
bind(fd, (sockaddr*)&sa, sizeof(sa));
```

클라이언트에서도 마찬가지로 `connect` 시 포트는 `htons` 를 거친 값으로 들어간다.

#### 1.3.2 사용 위치 예 — 길이 필드 프레이밍

예: TCP 스트림에서 **“4바이트 길이 + 바디”** 구조를 사용할 때.

송신:

```cpp
void send_frame(int fd, const std::byte* data, uint32_t len) {
    uint32_t net_len = htonl(len); // 4바이트 길이 필드
    std::byte buf[4];
    std::memcpy(buf, &net_len, 4);
    // 길이 전송
    send(fd, buf, 4, 0);
    // 바디 전송
    send(fd, data, len, 0);
}
```

수신:

```cpp
bool recv_exact(int fd, std::byte* buf, std::size_t len) {
    std::size_t got = 0;
    while (got < len) {
        ssize_t n = recv(fd, buf + got, len - got, 0);
        if (n > 0) got += static_cast<std::size_t>(n);
        else if (n == 0) return false;          // peer closed
        else if (errno == EINTR) continue;
        else if (errno == EAGAIN || errno == EWOULDBLOCK) continue;
        else return false;
    }
    return true;
}

bool recv_frame(int fd, std::vector<std::byte>& out) {
    std::byte hdr[4];
    if (!recv_exact(fd, hdr, 4)) return false;
    uint32_t net_len;
    std::memcpy(&net_len, hdr, 4);
    uint32_t len = ntohl(net_len);              // ✅ 네트워크 → 호스트
    if (len > (1u<<20)) return false;           // 예: 1MiB cap
    out.resize(len);
    return recv_exact(fd, out.data(), len);
}
```

---

### 1.4 수식으로 보는 바이트 스왑

엔디안 변환은 **바이트 스왑(byte swap)** 과 동일하다. 리틀엔디안 ↔ 빅엔디안은 서로 역변환이다.

#### 1.4.1 16비트 스왑

16비트 정수 \(x\) 의 상·하위 바이트를 뒤집는 연산:

$$
\text{swap16}(x) = \left( (x \ll 8) \land 0xFF00 \right) \ \vert\ \left( (x \gg 8) \land 0x00FF \right)
$$

- 상위 8비트를 왼쪽으로 보내고 마스크.
- 하위 8비트를 오른쪽으로 보내고 마스크.
- 두 값을 OR 로 합친다.

C 코드로 구현하면:

```c
uint16_t swap16(uint16_t x) {
    return ((x << 8) & 0xFF00u) | ((x >> 8) & 0x00FFu);
}
```

실제로 많은 구현에서 **리틀엔디안 호스트**에서는 `htons` 가 내부적으로 이와 유사한 바이트 스왑을 수행하고, **빅엔디안 호스트**에서는 **no-op** 에 가깝게 최적화된다.

#### 1.4.2 32비트 스왑

32비트 정수 \(x\) 에 대해:

$$
\begin{aligned}
\text{swap32}(x) = &\ ((x \ll 24) \land 0xFF000000) \\
&\ \vert\ ((x \ll 8) \land 0x00FF0000) \\
&\ \vert\ ((x \gg 8) \land 0x0000FF00) \\
&\ \vert\ ((x \gg 24) \land 0x000000FF)
\end{aligned}
$$

C 코드:

```c
uint32_t swap32(uint32_t x) {
    return ((x << 24) & 0xFF000000u) |
           ((x <<  8) & 0x00FF0000u) |
           ((x >>  8) & 0x0000FF00u) |
           ((x >> 24) & 0x000000FFu);
}
```

이는 **엔디안 변환**과 동일한 연산이다.  

즉, **엔디안 변환 = 바이트 스왑**(호스트가 리틀엔디안일 때), **엔디안 유지 = 그대로**(호스트가 빅엔디안일 때).

---

### 1.5 C++23: `std::endian` 과 `std::byteswap` 로 직접 구현하기

C++20 이후 `<bit>` 헤더에는 **엔디안 정보**와 **바이트 스왑 함수**가 표준으로 들어왔다.

```cpp
#include <bit>
#include <cstdint>
#include <print>

constexpr uint16_t to_net16(uint16_t x) {
    if constexpr (std::endian::native == std::endian::little)
        return std::byteswap(x);
    else
        return x; // big-endian host면 그대로
}

constexpr uint16_t to_host16(uint16_t x) {
    // 네트워크=빅엔디안이므로, 다시 같은 변환
    return to_net16(x);
}

constexpr uint32_t to_net32(uint32_t x) {
    if constexpr (std::endian::native == std::endian::little)
        return std::byteswap(x);
    else
        return x;
}

constexpr uint32_t to_host32(uint32_t x) { return to_net32(x); }

int main() {
    uint16_t port = 0x1234;   // host
    auto be = to_net16(port); // network
    std::println("host=0x{:04X}, net=0x{:04X}", port, be);
}
```

실무에서는 여전히 **`htons/htonl`** 을 사용하는 것이 소켓 API와의 연계 측면에서 직관적이다.  

다만:

- 바이너리 파일 포맷,  
- 커스텀 프로토콜(TLV 등),  
- 크로스 플랫폼 직렬화 라이브러리

같은 것을 직접 구현할 때는 `std::endian`/`std::byteswap` 을 쓰는 것이 **C++ 표준 안**에서 더 깔끔하다.

---

### 1.6 잘못된 예/올바른 예 — 패턴으로 익히기

#### 1.6.1 잘못된 예: IPv4 헤더를 그대로 `send` 하기

```cpp
struct IPv4Header {
    uint8_t  version_ihl;
    uint8_t  tos;
    uint16_t total_length;     // host-endian
    uint16_t identification;   // host-endian
    uint16_t flags_frag_off;   // host-endian
    uint8_t  ttl;
    uint8_t  protocol;
    uint16_t header_checksum;  // host-endian
    uint32_t src_addr;         // host-endian
    uint32_t dst_addr;         // host-endian
};

// ❌ 이렇게 그대로 보내면 안 된다
IPv4Header h{ /* 값 채움 */ };
send(fd, &h, sizeof(h), 0);
```

문제점:

1. **엔디안**: `total_length` 등은 네트워크 바이트 오더여야 하는데, host 엔디안 그대로 전송하면 타 시스템에서 해석이 깨진다.
2. **패딩**: `struct` 내부에 컴파일러가 넣은 **패딩 바이트**가 포함될 수 있다.
3. **호환성**: 다른 컴파일러/플랫폼/ABI에서 구조체 레이아웃이 달라질 수 있다.

#### 1.6.2 올바른 예: 명시적 직렬화

```cpp
void encode_ipv4_header(std::byte* out, const IPv4Header& h) {
    out[0] = std::byte(h.version_ihl);
    out[1] = std::byte(h.tos);

    uint16_t total = htons(h.total_length);
    std::memcpy(out + 2, &total, 2);

    uint16_t id = htons(h.identification);
    std::memcpy(out + 4, &id, 2);

    uint16_t frag = htons(h.flags_frag_off);
    std::memcpy(out + 6, &frag, 2);

    out[8] = std::byte(h.ttl);
    out[9] = std::byte(h.protocol);

    uint16_t cksum = htons(h.header_checksum);
    std::memcpy(out + 10, &cksum, 2);

    uint32_t src = htonl(h.src_addr);
    uint32_t dst = htonl(h.dst_addr);
    std::memcpy(out + 12, &src, 4);
    std::memcpy(out + 16, &dst, 4);
}
```

이렇게 **필드별로 명시적으로 변환/복사** 하는 것이 **네트워크 프로그래밍의 기본 습관**이다.

---

### 1.7 구조체 직렬화의 3대 문제: 엔디안, 패딩, 버전

구조체를 그대로 네트워크에 흘려보내면 **반드시** 다음 문제가 생긴다.

1. **엔디안 차이**  
   - 다바이트 필드가 네트워크 규약(빅엔디안)을 따르지 않는다.
2. **패딩/정렬**  
   - 컴파일러는 구조체를 정렬하기 위해 패딩 바이트를 삽입한다.
   - 패딩 위치/크기는 컴파일러/옵션/플랫폼에 따라 다르다.
3. **버전 관리**  
   - 필드를 추가/삭제/재정렬하면, 이전 버전과의 바이너리 호환성이 깨진다.

따라서 **직렬화/역직렬화 함수를 확실하게 작성**하여:

- 네트워크 바이트 오더를 명시하고,
- 바이트 레이아웃을 명확히 정의하고,
- 버전 필드 등으로 확장 가능성을 확보하는 것이 중요하다.

#### 1.7.1 예: 간단한 헤더 직렬화/역직렬화

```cpp
struct MsgHeader {
    uint8_t  version;  // 1B
    uint8_t  type;     // 1B
    uint16_t flags;    // 2B
    uint32_t length;   // 4B
};

constexpr std::size_t MSG_HEADER_SIZE = 1 + 1 + 2 + 4;

void encode_header(std::byte* out, const MsgHeader& h) {
    out[0] = std::byte(h.version);
    out[1] = std::byte(h.type);

    uint16_t f = htons(h.flags);
    std::memcpy(out + 2, &f, 2);

    uint32_t len = htonl(h.length);
    std::memcpy(out + 4, &len, 4);
}

bool decode_header(const std::byte* in, MsgHeader& h) {
    h.version = static_cast<uint8_t>(in[0]);
    h.type    = static_cast<uint8_t>(in[1]);

    uint16_t f;
    std::memcpy(&f, in + 2, 2);
    h.flags = ntohs(f);

    uint32_t len;
    std::memcpy(&len, in + 4, 4);
    h.length = ntohl(len);
    return true;
}
```

---

### 1.8 64비트 필드, `htonll` 가 없을 때

POSIX 표준에는 `htonll` / `ntohll` 이 없다. 일부 시스템은 확장으로 제공하지만, 이식성 측면에서 애매하다.

**C++23** 에서는 `std::byteswap(uint64_t)` 로 쉽게 구현할 수 있다.

```cpp
#include <bit>
#include <cstdint>

constexpr uint64_t to_net64(uint64_t x) {
    if constexpr (std::endian::native == std::endian::little)
        return std::byteswap(x);
    else
        return x;
}

constexpr uint64_t to_host64(uint64_t x) {
    return to_net64(x); // 네트워크=빅엔디안
}
```

이렇게 구현해두고, 64비트 시퀀스 번호, 타임스탬프, UUID 일부 등에도 일관성 있게 적용할 수 있다.

---

### 1.9 엔디안 버그를 눈으로 확인하는 실험

엔디안 관련 버그를 이해하려면 **실제 메모리 덤프**를 보는 것이 가장 빠르다.

```cpp
// endian_probe.cpp
#include <arpa/inet.h>
#include <cstdint>
#include <cstdio>
#include <cstring>

int main() {
    uint16_t p = 0x1234;
    uint16_t n = htons(p);

    std::printf("host=0x%04X, htons=0x%04X\n", p, n);

    unsigned char pb[2];
    unsigned char nb[2];

    std::memcpy(pb, &p, 2);
    std::memcpy(nb, &n, 2);

    std::printf("host bytes: %02X %02X\n", pb[0], pb[1]);
    std::printf("net  bytes: %02X %02X\n", nb[0], nb[1]);
}
```

리틀엔디안 머신이라면 대략 다음과 비슷하게 나온다:

```text
host=0x1234, htons=0x3412
host bytes: 34 12
net  bytes: 12 34
```

- **host bytes**: 메모리에서 `0x34 0x12` → 리틀엔디안
- **net bytes**: `0x12 0x34` → 네트워크 바이트 오더(빅엔디안)

이 차이를 실제로 보는 순간, “왜 `htons` 를 써야 하는가” 가 직관적으로 이해된다.

---

### 1.10 미니 과제 — 네트워크 바이트 오더에 완전히 익숙해지기

1. **고의 버그 서버 만들기**
   - 포트 설정에서 `htons` 를 빼고 `sa.sin_port = 9000;` 으로 둔 서버를 작성.
   - `netstat`, `ss -ltn`, `tcpdump` 로 실제 열린 포트가 무엇인지 확인해본다.
   - 클라이언트에서 “9000으로 접속했다는데 실제로는 엉뚱한 포트” 현상을 눈으로 본다.
2. **TLV 프로토콜 설계**
   - `type(1B) + length(2B, net) + value(lengthB)` 형태의 단순 TLV(TLV = Type-Length-Value) 프레이밍을 설계.
   - 여러 개의 TLV를 하나의 TCP 스트림에 붙여보내고, 수신 쪽에서 `ntohs` 를 사용해 올바르게 역직렬화.
3. **tcpdump/wireshark 으로 값 확인**
   - 위 TLV 프로토콜을 사용하는 프로그램을 돌리고,
   - `tcpdump -X` 또는 Wireshark 로 패킷을 캡처해, **길이/포트/타입** 필드가 **빅엔디안** 순서로 잘 실리는지 확인한다.

---

## 2. 파일 디스크립터로서의 소켓 — “모든 것은 파일이다”

> 한 줄 핵심: 유닉스 계열 시스템에서 **소켓도 결국 파일 디스크립터(fd)** 이다.  
> `read/write/close` 가 가능한 이유, `send/recv`, `shutdown`, `SIGPIPE`, `select/poll/epoll` 이 모두 **fd 중심 모델** 위에 서 있다.

---

### 2.1 fd 테이블과 시스템 콜

프로세스는 **정수 인덱스인 fd(file descriptor)** 를 통해 커널 리소스에 접근한다.

- 각 프로세스는 **fd 테이블**을 가진다.
- 0 = `STDIN_FILENO`, 1 = `STDOUT_FILENO`, 2 = `STDERR_FILENO`.
- `open`, `socket`, `pipe`, `accept` 등은 **새 fd** 를 반환한다.

개념적으로:

- fd는 단순한 **정수**이다.
- 이 정수는 커널 내부의 **파일 객체/소켓 객체/파이프 객체** 를 가리킨다.
- 시스템 콜 `read(fd, ...)`, `write(fd, ...)`, `close(fd)` 는 이 객체에 대한 연산을 수행한다.

---

### 2.2 소켓이 “파일”처럼 동작하는 이유

소켓은 `socket()` 시스템 콜로 생성되는 **네트워크 I/O 객체**지만, 커널 내부 구현에서는 **파일 추상화의 한 종류**로 관리된다.

- 커널은 각 객체마다 **file operations(연산 테이블)** 을 둔다.
- 정규 파일은 디스크 I/O, 소켓은 네트워크 스택을 통해 패킷을 주고받는다.
- 그러나 사용자 공간에서는 **동일한 인터페이스**: `read/write/close`, `select/poll/epoll` 로 접근할 수 있다.

예:

```cpp
int sv[2];
socketpair(AF_UNIX, SOCK_STREAM, 0, sv); // sv[0], sv[1] 두 fd

const char* msg = "hello";
write(sv[0], msg, std::strlen(msg));     // 소켓에 write
char buf[16]{};
read(sv[1], buf, sizeof(buf));          // 소켓에서 read
std::printf("got: %s\n", buf);          // "got: hello"

// 마지막엔 close
close(sv[0]);
close(sv[1]);
```

- **UNIX 도메인 소켓**이지만, 인터페이스는 정규 파일과 완전히 같다.
- TCP/UDP 소켓 역시 **fd를 통해 read/write/close** 가 가능하다.

---

### 2.3 `read/write` vs `recv/send` — 언제 무엇을 써야 하는가

둘 다 소켓에서 동작하지만, 차이가 있다.

#### 2.3.1 `read/write`

- POSIX 공통 I/O 인터페이스.
- 장점:
  - 파일/파이프/소켓 모두에 동일하게 사용 가능.
  - 간단한 코드에서는 편하다.
- 단점:
  - 소켓 전용 플래그(예: `MSG_DONTWAIT`, `MSG_NOSIGNAL`, `MSG_PEEK`) 를 사용할 수 없다.

#### 2.3.2 `recv/send`

- 소켓 전용 I/O 함수.

장점:

- `recv(fd, buf, len, MSG_DONTWAIT)`  
  → 호출 단위로 **논블로킹** 동작.
- `send(fd, buf, len, MSG_NOSIGNAL)`  
  → **SIGPIPE** 방지(상대가 끊었을 때 프로세스 전체가 죽는 것을 막는다).
- `recvfrom/sendto`  
  → UDP 등에서 **송신/수신 주소**를 함께 다룰 수 있다.
- `sendmsg/recvmsg`  
  → iovec, ancillary data, SCM_RIGHTS 등 고급 기능.

**실무 요약**:

- TCP 스트림에서는 기본적으로 **`send/recv` 를 선호**한다.
- 간단한 데모/학습에서는 `read/write` 를 써도 동작에는 문제가 없다.
- 단, **SIGPIPE**, **플래그 기반 논블로킹**, **peek/out-of-band 데이터** 등을 고려해야 할 때는 반드시 `send/recv` 를 써야 한다.

---

### 2.4 `close` vs `shutdown` — half-close 의 의미

TCP 연결은 논리적으로 **양방향 스트림**이다.

- `close(fd)`:
  - 해당 프로세스의 fd 참조를 끊는다.
  - 이 fd의 참조 카운트가 0이 되면 커널이 소켓을 정리하고, 필요하면 **FIN/_RST** 를 전송한다.
- `shutdown(fd, how)`:
  - 스트림의 방향을 **부분 종료(half-close)** 할 수 있다.

`how` 인자는:

- `SHUT_RD` (또는 0): 더 이상 **읽지 않겠다**. 수신 방향 종료.
- `SHUT_WR` (또는 1): 더 이상 **보내지 않겠다**. 송신 방향 종료. (상대는 EOF를 보게 된다.)
- `SHUT_RDWR` (또는 2): 양방향 종료.

#### 2.4.1 예 — 요청 전송 후 half-close

HTTP/1.0 스타일 간단 클라이언트:

```cpp
void send_http_request_and_read(int fd, std::string_view req) {
    send(fd, req.data(), req.size(), 0);
    shutdown(fd, SHUT_WR); // 더 이상 보낼 데이터 없음

    char buf[4096];
    for (;;) {
        ssize_t n = recv(fd, buf, sizeof(buf), 0);
        if (n > 0) {
            write(STDOUT_FILENO, buf, n);
        } else if (n == 0) {
            // 서버가 FIN 보냄
            break;
        } else if (errno == EINTR) {
            continue;
        } else {
            break;
        }
    }
}
```

- `SHUT_WR` 을 통해 **요청 전송 종료**를 표현.
- 서버는 클라이언트가 더 이상 보낼 게 없음을 알고, 응답을 보내고 나서 종료할 수 있다.

---

### 2.5 `dup/dup2` 와 fork — fd의 복제와 상속

fd는 단순 정수이지만, **커널 객체에 대한 포인터 역할**을 한다.

- `dup(fd)`:
  - 같은 커널 객체를 가리키는 **새 fd** 를 만든다. (참조 카운트 증가)
- `dup2(oldfd, newfd)`:
  - `newfd` 가 이미 열려 있다면 닫고, `oldfd` 와 **같은 객체**를 가리키게 한다.

`fork()` 가 발생하면:

- 자식 프로세스는 부모의 fd 테이블을 **복사**한다.
- 복사된 fd는 **같은 커널 객체**를 가리키므로,  
  - 부모/자식이 같은 소켓/파이프/파일을 공유할 수 있다.

이 패턴으로:

- HTTP 서버에서 **accept 전용 프로세스**와 **워크 프로세스**를 분리한다거나,
- 파이프/소켓을 이용해 **프로세스 간 통신(IPC)** 을 구현할 수 있다.

---

### 2.6 fd 기반 멀티플렉싱: `select/poll/epoll`

**소켓이 fd** 이기 때문에, `select/poll/epoll` 같은 멀티플렉싱 API가 **모든 종류의 I/O 스트림**(소켓, 파이프, 일부 디바이스)을 통합적으로 감시할 수 있다.

- `select`:
  - fd 집합을 비트마스크로 전달.
  - FD_SETSIZE 제한, 매 호출마다 전체 마스크 복사/스캔.
- `poll`:
  - `struct pollfd { int fd; short events; short revents; }` 배열로 이벤트 관심을 등록.
  - FD 개수 제한은 사실상 없음. 다만 매 호출마다 O(N) 스캔.
- `epoll` (Linux 고유):
  - 커널에 **관심 fd 집합을 등록**해놓고, 이벤트 발생시 **준비된 fd 목록만** 돌려줌.
  - 수만 개 이상의 fd 에서도 효율적으로 동작 가능(이벤트 기반, O(ready_fds) 에 근접).

이 모든 API가 **“fd 준비 상태(읽기/쓰기/에러)”** 를 다루기 때문에:

- 소켓도 fd이므로 자연스럽게 **같은 이벤트 루프** 에 올릴 수 있다.
- “소켓이 파일처럼 취급된다”는 말은 단순한 수사가 아니라, **커널 I/O 모델 전체의 중심 개념**이다.

---

### 2.7 fd 통합 실험 — 파이프와 소켓을 한 루프에서 다루기

아래 예제는 `pipe` 와 `socketpair` 를 동시에 감시하는 `poll` 기반 간단 데모이다.

```cpp
// fd_unify_demo.cpp
#include <sys/socket.h>
#include <sys/types.h>
#include <sys/poll.h>
#include <unistd.h>
#include <cstdio>
#include <cstring>
#include <vector>

int main() {
    int pipefd[2];
    if (pipe(pipefd) != 0) {
        std::perror("pipe");
        return 1;
    }

    int sv[2];
    if (socketpair(AF_UNIX, SOCK_STREAM, 0, sv) != 0) {
        std::perror("socketpair");
        return 1;
    }

    // 파이프/소켓에 데이터 쓰기
    const char* msg1 = "pipe hello";
    write(pipefd[1], msg1, std::strlen(msg1));

    const char* msg2 = "sock hello";
    write(sv[0], msg2, std::strlen(msg2));

    std::vector<pollfd> pfds = {
        { pipefd[0], POLLIN, 0 },
        { sv[1],     POLLIN, 0 }
    };

    char buf[128]{};

    for (;;) {
        int rc = ::poll(pfds.data(), pfds.size(), 5000);
        if (rc < 0) {
            if (errno == EINTR) continue;
            std::perror("poll");
            break;
        }
        if (rc == 0) {
            std::printf("timeout\n");
            continue;
        }

        for (auto& p : pfds) {
            if (p.revents & POLLIN) {
                ssize_t n = read(p.fd, buf, sizeof(buf)-1);
                if (n > 0) {
                    buf[n] = '\0';
                    std::printf("fd=%d got: %s\n", p.fd, buf);
                } else if (n == 0) {
                    std::printf("fd=%d closed\n", p.fd);
                    p.fd = -1;
                } else {
                    std::perror("read");
                }
            }
        }

        // 종료 조건
        if (pfds[0].fd == -1 && pfds[1].fd == -1) break;
    }

    close(pipefd[0]); close(pipefd[1]);
    close(sv[0]); close(sv[1]);
    return 0;
}
```

- 파이프와 소켓이 **동일한 poll 루프** 안에서 처리된다.
- 이것이 바로 **“fd 중심 유닉스 I/O 모델”** 이 갖는 강력함이다.

---

### 2.8 SIGPIPE 와 `MSG_NOSIGNAL` — 소켓이 “파일과 다른” 부분

정규 파일에서 `write` 를 하다가 대상이 사라지는 경우, 보통은 **오류 코드만** 받는다.  
하지만 **소켓에서** 상대가 이미 닫힌 상태로 `send/write` 하면 **SIGPIPE** 신호가 발생할 수 있고, **프로세스가 종료**될 수도 있다.

#### 2.8.1 SIGPIPE 방지 방법

리눅스 계열:

1. **프로세스 전체**에서 `SIGPIPE` 무시

```c
#include <signal.h>

int main() {
    signal(SIGPIPE, SIG_IGN); // 혹은 sigaction 사용
    // ...
}
```

2. **개별 send 호출에서만** 무시

```cpp
send(fd, data, len, MSG_NOSIGNAL);
```

macOS / BSD:

- `SO_NOSIGPIPE` 소켓 옵션 사용 가능.

```cpp
int on = 1;
setsockopt(fd, SOL_SOCKET, SO_NOSIGPIPE, &on, sizeof(on));
```

#### 2.8.2 SIGPIPE 관측 실험

1. 서버:

```cpp
// server_sigpipe.cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#include <cstdio>
#include <cstring>

int main() {
    int s = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in sa{};
    sa.sin_family = AF_INET;
    sa.sin_port   = htons(9000);
    inet_pton(AF_INET, "0.0.0.0", &sa.sin_addr);
    bind(s, (sockaddr*)&sa, sizeof(sa));
    listen(s, 1);
    int c = accept(s, nullptr, nullptr);

    const char* msg = "test";
    // 일부러 두 번 연속 send, 클라이언트는 일찍 종료시킴
    send(c, msg, std::strlen(msg), 0);
    sleep(1);
    send(c, msg, std::strlen(msg), 0); // 여기서 SIGPIPE 가능
}
```

2. 클라이언트:

```cpp
// client_quit.cpp
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>

int main() {
    int s = socket(AF_INET, SOCK_STREAM, 0);
    sockaddr_in sa{};
    sa.sin_family = AF_INET;
    sa.sin_port   = htons(9000);
    inet_pton(AF_INET, "127.0.0.1", &sa.sin_addr);
    connect(s, (sockaddr*)&sa, sizeof(sa));
    // 즉시 종료
    close(s);
}
```

서버에서 SIGPIPE 를 처리하지 않으면, 두 번째 `send` 에서 프로세스가 종료되는 것을 볼 수 있다.  
`MSG_NOSIGNAL` 또는 `signal(SIGPIPE, SIG_IGN)` 으로 방지할 수 있다.

---

### 2.9 RAII로 fd 수명 관리하기

fd는 **커널 자원**이기 때문에, 누수되면:

- 한 프로세스에서 fd가 한계(ulimit -n)에 도달,
- 시스템 전체의 fd 테이블을 압박,
- 예기치 않은 `EMFILE` (“Too many open files”) 오류가 발생할 수 있다.

C++23에서는 얇은 RAII 래퍼를 만들어 fd 생애를 관리하는 것이 좋다.

```cpp
#include <unistd.h>
#include <utility>

struct unique_fd {
    int fd{-1};

    unique_fd() = default;
    explicit unique_fd(int f): fd(f) {}

    ~unique_fd() {
        if (fd != -1) ::close(fd);
    }

    unique_fd(const unique_fd&) = delete;
    unique_fd& operator=(const unique_fd&) = delete;

    unique_fd(unique_fd&& other) noexcept
        : fd(std::exchange(other.fd, -1)) {}

    unique_fd& operator=(unique_fd&& other) noexcept {
        if (this != &other) {
            if (fd != -1) ::close(fd);
            fd = std::exchange(other.fd, -1);
        }
        return *this;
    }

    int get() const noexcept { return fd; }
    explicit operator bool() const noexcept { return fd != -1; }

    int release() noexcept {
        int t = fd;
        fd = -1;
        return t;
    }
};
```

이렇게 해 두면:

- 예외가 발생해도 fd가 자동으로 닫힌다.
- 함수에서 조기에 return 하더라도 fd 누수가 나지 않는다.
- `unique_ptr` 와 같은 패턴으로 **소유권**이 명확해진다.

---

### 2.10 실무 체크리스트 — 엔디안 + fd/소켓

**네트워크 바이트 오더 관련**

- [ ] 네트워크로 나가는 모든 다바이트 정수는 **`htons/htonl` 을 거쳐 네트워크(빅엔디안)로** 변환했는가.
- [ ] 수신 직후 `ntohs/ntohl` 로 **호스트 엔디안으로 되돌려** 해석하고 있는가.
- [ ] 구조체를 그대로 `send/recv` 하지 않고, **명시적 직렬화/역직렬화** 코드를 작성했는가.
- [ ] 패킷 캡처(tcpdump, Wireshark 등)에서 **포트/길이/시퀀스** 필드 바이트 순서를 직접 확인해 봤는가.

**fd / 소켓 관련**

- [ ] fd 수명을 RAII(`unique_fd` 등) 로 관리하고 있는가.
- [ ] 소켓 I/O에선 `send/recv` 를 사용하고, **`MSG_NOSIGNAL` 혹은 SIGPIPE 무시** 설정을 해 두었는가.
- [ ] half-close(`shutdown`) 의 의미와 용도를 정확히 이해하고 있는가.
- [ ] 소켓/파이프/파일을 하나의 **이벤트 루프(select/poll/epoll)** 에 올려, **fd 중심 모델** 을 활용하고 있는가.

---

### 2.11 종합 요약

1. **네트워크 바이트 오더 = 빅엔디안**  
   - 이 규약 덕분에 서로 다른 CPU/OS 가 같은 패킷을 **동일한 의미**로 해석할 수 있다.
   - 애플리케이션은 **와이어 직전**에 `hton*`, **와이어 직후**에 `ntoh*` 를 수행해야 한다.

2. **구조체를 그대로 보내지 말고, 명시적인 직렬화**  
   - 엔디안/패딩/버전 문제를 피하기 위해, 필드별 변환·복사를 통해 버퍼를 구성하라.
   - C++23에서는 `std::endian`/`std::byteswap` 이 도움이 된다.

3. **소켓은 fd다**  
   - `read/write/close` 가 통하는 이유는 **유닉스 fd 테이블** 상에서 소켓도 **파일 객체의 한 종류**이기 때문이다.
   - `select/poll/epoll` 은 모두 **fd 기반 멀티플렉싱**을 수행한다.

4. **소켓 특화 기능 잊지 말기**  
   - `send/recv`, `shutdown`, `setsockopt`, `MSG_NOSIGNAL`, `recvfrom/sendto` 등은 **파일에는 없는 소켓 고유 기능**이다.
   - 특히 **SIGPIPE 처리**, **half-close**, **논블로킹 + 멀티플렉싱**은 서버 구현에서 필수다.
