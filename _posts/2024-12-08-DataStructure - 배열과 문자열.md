---
layout: post
title: Data Structure - 배열과 문자열
date: 2024-12-08 19:20:23 +0900
category: Data Structure
---
# 배열과 문자열

자료구조의 가장 기본이자 중요한 구조는 **배열(Array)**과 **문자열(String)**입니다. 많은 알고리즘과 고급 자료구조들이 배열 기반으로 구현되므로, 그 원리를 제대로 이해하는 것이 중요합니다.

---

## 1. 배열(Array)

### 정의

배열은 **같은 타입의 데이터를 연속된 메모리 공간**에 저장하는 자료구조입니다.

```cpp
int arr[5] = {1, 2, 3, 4, 5};
```

### 특징

- **인덱스 기반 접근**: `O(1)` 시간에 임의 위치 접근 가능
- **고정된 크기**: 선언 시 크기 지정 필요
- **삽입/삭제 비용**: 중간에서 삽입/삭제 시 `O(n)` 시간 필요

### 장점

- 빠른 접근 속도 (`arr[i]`는 즉시 접근 가능)
- 구조가 단순하여 구현이 쉬움

### 단점

- 크기 변경 불가 (정적 배열의 경우)
- 메모리 낭비 가능성 있음

### 예제: 배열에서 특정 값 찾기

```cpp
int find(int arr[], int size, int target) {
    for (int i = 0; i < size; ++i)
        if (arr[i] == target)
            return i;
    return -1;
}
```

---

## 2. 문자열(String)

### 정의

문자열은 **문자의 배열**입니다. 보통 널 종료 문자 `\0`를 마지막에 포함시켜 끝을 표시합니다.

```c
char str[] = "hello";  // 실제 메모리에는 {'h','e','l','l','o','\0'}
```

C++에서는 `std::string`을 사용하면 더 편리하게 문자열을 다룰 수 있습니다.

```cpp
std::string s = "hello";
s += " world";  // "hello world"
```

---

### 문자열 연산들

| 연산 | 설명 | 시간 복잡도 |
|------|------|--------------|
| 길이 구하기 (`length()`, `size()`) | 문자열의 길이 반환 | `O(1)` |
| 비교 (`==`, `compare`) | 두 문자열이 같은지 비교 | `O(n)` |
| 연결 (`+`, `append`) | 문자열 결합 | `O(n)` |
| 부분 문자열 (`substr`) | 일부 문자열 추출 | `O(k)` |
| 검색 (`find`) | 특정 문자의 위치 찾기 | `O(n)` |

---

## 3. 동적 배열 (vector)

C++에서는 고정된 배열보다 **동적 배열(`std::vector`)**을 많이 사용합니다. 자동으로 크기를 조절해주며, 배열보다 유연합니다.

```cpp
#include <vector>

std::vector<int> v = {1, 2, 3};
v.push_back(4);  // 크기 자동 증가
v[2] = 10;       // 인덱스 접근 가능
```

### 동적 배열의 장점

- 크기 제한 없음
- 다양한 편의 메서드 (`push_back`, `pop_back`, `insert`, `erase` 등)

---

## 4. 문자열과 배열의 관계

- 문자열도 결국은 배열이므로 **인덱스로 문자 접근** 가능
- 문자열 문제 대부분은 배열 문제로 환원 가능
- 대표 예시:
  - 회문 확인
  - 아나그램 판단
  - 슬라이딩 윈도우 (부분 문자열 처리)
