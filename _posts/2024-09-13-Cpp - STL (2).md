---
layout: post
title: C++ - STL (2)
date: 2024-09-13 19:20:23 +0900
category: Cpp
---
# STL 2 — 순차 컨테이너: `vector`, `list`, `deque`

## 순차 컨테이너 큰 그림

순차 컨테이너는 데이터를 순서대로 저장하며, 반복자(iterator)를 통해 순회할 수 있는 컨테이너들입니다. **핵심 차이는 내부 메모리 구조**에 있으며, 이는 성능(시간 복잡도), 캐시 지역성, 반복자 무효화 규칙을 결정합니다.

- **`vector`**: 연속된 메모리 블록을 사용하는 동적 배열입니다. 임의 접근이 빠르고(O(1)), CPU 캐시 효율이 매우 좋습니다. 대신 중간 삽입/삭제는 비용이 큽니다.
- **`list`**: 이중 연결 리스트로 구현되어 있습니다. 어디서든 삽입/삭제가 이론상 O(1)이지만, 메모리가 흩어져 있어 캐시 효율이 낮고 실제 속도는 느릴 수 있습니다.
- **`deque`**: 여러 개의 고정 크기 메모리 블록으로 구성된 "분절 배열"입니다. 양끝에서의 삽입/삭제가 효율적이고(O(1)), 임의 접근도 가능하지만 캐시 효율은 `vector`보다 낮습니다.

---

## `vector` — 기본 선택이 되는 이유

### 내부 구조와 성능 특징
`vector`는 C 스타일 배열처럼 물리적으로 연속된 메모리를 사용합니다. 이로 인해 다음과 같은 장점이 있습니다:
- **임의 접근(Random Access)**이 상수 시간(O(1))에 가능합니다.
- **캐시 지역성(Cache Locality)**이 뛰어나서 순차 접근 속도가 매우 빠릅니다.
- 크기가 증가할 때는 기존 용량(capacity)을 넘어서면 새로운 더 큰 메모리 영역을 할당하고 모든 요소를 이동시킵니다(재할당, reallocation). 이 작업은 O(n)이지만, 용량을 지수적으로 증가시키므로 `push_back` 연산은 **분할 상환 분석(Amortized Analysis)** 상 O(1)입니다.

### 주요 API 활용과 주의사항

```cpp
#include <vector>
#include <algorithm>
#include <iostream>

int main() {
    // 1. 생성과 용량 관리
    std::vector<int> vec;
    vec.reserve(100); // 재할당을 방지하기 위해 미리 공간 확보

    // 2. 데이터 추가
    vec.push_back(10);
    vec.emplace_back(20); // 내부에서 직접 생성. 복사/이동 비용 절감
    vec.insert(vec.begin() + 1, 15); // 중간 삽입 (비용 높음)

    // 3. 데이터 접근
    std::cout << vec[0] << "\n";        // 빠르지만 범위 검사 없음
    std::cout << vec.at(0) << "\n";     // 범위 검사 후 접근 (예외 가능)
    std::cout << vec.front() << ", " << vec.back() << "\n";

    // 4. 데이터 제거: erase-remove 관용구
    vec.erase(std::remove_if(vec.begin(), vec.end(),
                             [](int x) { return x % 2 == 0; }),
              vec.end());

    // 5. 크기 조정
    vec.resize(50, -1); // 크기를 50으로. 새 공간은 -1로 채움
    vec.shrink_to_fit(); // 여분의 용량을 줄이려 시도 (강제성 없음)
}
```

### 반복자 무효화: 가장 중요한 규칙
`vector`의 반복자, 포인터, 참조는 특정 연산 후에 무효화될 수 있습니다. 이는 미묘한 버그의 원인이 됩니다.
- **재할당 발생 시(예: `push_back` 후 `size > capacity`)**: **모든** 반복자/포인터/참조가 무효화됩니다.
- **중간 삽입(`insert`) 또는 삭제(`erase`) 시**: **수정된 위치부터 끝까지**의 반복자 등이 무효화됩니다.
- **`pop_back()` 시**: 마지막 요소에 대한 참조만 무효화됩니다.

**안전한 사용법**: 재할당 가능성이 있는 연산(`push_back` 등)이나 중간 삭제 후에는 반복자를 다시 얻어서 사용하세요.

---

## `list` — 이중 연결 리스트, 언제 사용해야 하나?

### 구조와 특성
`list`는 각 노드가 이전/다음 노드를 가리키는 포인터를 가지고 연결된 구조입니다.
- **장점**: 반복자가 가리키는 위치에서의 삽입/삭제가 **항상 O(1)**입니다. 다른 요소들의 반복자가 무효화되지 않습니다(안정성).
- **단점**: 임의 접근이 불가능합니다. 메모리 공간이 연속적이지 않아 캐시 미스가 자주 발생하며, 개별 노드 할당/해제 오버헤드가 있습니다.

### 주요 API와 고유한 멤버 함수
```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> myList = {1, 2, 3, 4, 5};

    // 양끝 삽입/삭제
    myList.push_front(0);
    myList.pop_back();

    // 반복자를 이용한 중간 조작
    auto it = std::next(myList.begin(), 2);
    myList.insert(it, 99); // O(1)
    it = myList.erase(it); // O(1), 삭제된 다음 반복자 반환

    // list 고유 알고리즘: 데이터 이동 없이 포인터만 조작
    myList.sort(); // std::sort는 사용 불가. 멤버 함수 sort 사용
    myList.unique(); // 인접한 중복 요소 제거

    // splice: 다른 list의 노드를 통째로 가져옴 (O(1))
    std::list<int> otherList = {100, 200};
    myList.splice(it, otherList); // it 앞에 otherList의 모든 노드 삽입

    // remove: 특정 값을 가진 모든 노드 제거
    myList.remove(99);
}
```

### `list`의 실전 활용 시점
- **반복자 안정성이 절대적으로 필요한 경우**: 컨테이너 조작 중에도 다른 곳에서 가지고 있는 반복자가 절대 무효화되지 않아야 할 때.
- **빈번한 중간 삽입/삭제가 예상되고, 그 위치를 알고 있을 때**: 예를 들면, 이벤트 리스너 목록이나 LRU 캐시 구현.
- **주의**: 이론적 복잡도가 좋아도 실제 성능은 `vector`보다 느릴 수 있으므로 **반드시 프로파일링으로 확인**하세요.

---

## `deque` — 양쪽 끝에서의 작업에 최적화

### 내부 동작 원리
`deque`는 "분할된 배열"이라고 생각할 수 있습니다. 여러 개의 고정 크기 메모리 블록을 관리하며, 앞뒤로 블록을 추가할 수 있습니다.
- **양끝 삽입/삭제(`push_front`, `pop_back` 등)**: O(1)의 성능을 보장합니다.
- **임의 접근**: `operator[]`를 지원하지만(O(1)), 내부적으로 블록을 찾는 간접 참조가 발생해 `vector`보다는 느릴 수 있습니다.
- **메모리**: 전체가 연속적이지 않아 캐시 효율은 `vector`보다 떨어지지만, 큰 재할당 비용은 없습니다.

### 주요 사용법
```cpp
#include <deque>
#include <iostream>
#include <algorithm> // std::sort 사용 가능 (RandomAccess Iterator 지원)

int main() {
    std::deque<int> dq;

    // 양끝 연산
    dq.push_back(2);
    dq.push_front(1);
    dq.push_back(3);
    // dq 상태: [1, 2, 3]

    dq.pop_front(); // [2, 3]
    dq.pop_back();  // [2]

    // 임의 접근 및 알고리즘 적용
    dq.push_back(5);
    dq.push_back(1);
    dq.push_back(4);
    std::cout << dq[1] << "\n"; // 5 출력
    std::sort(dq.begin(), dq.end()); // 정렬 가능

    // 반복자 무효화: vector보다 복잡하며, 양끝 연산시에도 무효화될 수 있음
    // 일반적으로 연산 후에는 반복자를 다시 획득하는 것이 안전합니다.
}
```

### 실전 패턴: 슬라이딩 윈도우
`deque`는 실시간 데이터 스트림에서 최근 N개의 값 중 최대/최소를 구하는 **슬라이딩 윈도우** 알고리즘 구현에 자주 사용됩니다.
```cpp
// 모든 슬라이딩 윈도우의 최대값 구하기
std::vector<int> maxSlidingWindow(const std::vector<int>& nums, int k) {
    std::deque<int> dq; // 인덱스를 저장 (값의 내림차순 유지)
    std::vector<int> result;
    for (int i = 0; i < nums.size(); ++i) {
        // 현재 값보다 작은 이전 값들은 윈도우에서 의미가 없으므로 제거
        while (!dq.empty() && nums[dq.back()] <= nums[i]) dq.pop_back();
        dq.push_back(i);
        // 윈도우를 벗어난 인덱스 제거
        if (dq.front() <= i - k) dq.pop_front();
        // 윈도우가 완성된 후부터 결과 저장
        if (i >= k - 1) result.push_back(nums[dq.front()]);
    }
    return result;
}
```

---

## 선택 가이드: 무엇을 쓸 것인가?

1.  **기본값은 `std::vector`입니다.**
    - 현대 컴퓨터 하드웨어는 연속 메모리 접근에 최적화되어 있습니다. 캐시 미스를 최소화하여 대부분의 시나리오에서 가장 빠른 성능을 제공합니다.
    - 알고리즘 라이브러리(`<algorithm>`)와의 호환성이 완벽합니다.

2.  **다음 조건에 해당하면 `std::deque`를 고려하세요.**
    - **데이터의 앞뒤 모두에서 빈번한 삽입/삭제**가 발생하며, **임의 접근도 필요**할 때.
    - 예: 작업 큐(Job Queue), 실시간 데이터 버퍼, 슬라이딩 윈도우.

3.  **다음 조건에 해당할 때만 `std::list`를 선택하세요.**
    - 순차 컨테이너 내부에서 **빈번한 중간 삽입/삭제**가 발생하고, 그 **위치를 이미 알고 있는 경우**(반복자를 가지고 있는 경우).
    - **반복자 안정성**이 가장 중요한 요구사항일 때 (예: 외부에서 요소를 가리키는 반복자를 장시간 보관해야 함).
    - *성능 측정 없이는 선택하지 마세요.* 노드 기반 구조의 오버헤드가 예상보다 클 수 있습니다.

---

## 핵심 결론

`vector`, `list`, `deque`는 모두 순서가 있는 데이터를 저장한다는 공통점을 가지지만, 그 내부 구현은 근본적으로 다릅니다. 이 차이는 단순한 "이론상 시간 복잡도"를 넘어서, **실제 실행 속도, 메모리 사용 패턴, 그리고 코드의 안정성(반복자 무효화 문제)** 에 지대한 영향을 미칩니다.

**`vector`의 연속 메모리 특성은 현대 하드웨어의 장점을 극대화합니다.** 따라서 별다른 이유가 없다면 `vector`를 기본 컨테이너로 선택하십시오. `deque`나 `list`를 선택해야 하는 명확한 이유(양끝 조작, 반복자 안정성)가 있다면, 그 이유를 알고 선택하되, 궁극적으로는 **실제 데이터와 환경에서의 성능 측정**이 최선의 판단 기준이 될 것입니다.