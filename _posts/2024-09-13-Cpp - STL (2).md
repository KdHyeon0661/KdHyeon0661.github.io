---
layout: post
title: C++ - STL (2)
date: 2024-09-13 19:20:23 +0900
category: Cpp
---
# STL 2 — 순차 컨테이너: `vector`, `list`, `deque`

## 순차 컨테이너 큰 그림

- **공통점**: “순서가 있는 데이터”를 담고, 이터레이터로 순회한다.
- **핵심 차이**는 **내부 구조** → 이것이 **복잡도, 캐시 지역성, 반복자 무효화**를 결정:
  - `vector`: **연속 메모리**(contiguous) 동적 배열 — 임의 접근 O(1), 캐시 친화, 끝 삽입 암ortized O(1)
  - `deque`: **분절 블록** 배열 — 양끝 O(1) 삽입/삭제, 랜덤 접근 O(1)이지만 캐시 지역성은 `vector`↓
  - `list`: **이중 연결 리스트** — 어디서든 `iterator`로 O(1) 삽입/삭제, 임의 접근 불가, 캐시 비우호

---

## `vector` — “기본값”이 되는 이유

### 내부 구조와 복잡도

- **연속(contiguous) 메모리**: C 배열과 동일한 배치 → SIMD/프리패치/캐시 적중률↑
- 크기 증가 시 **용량(capacity)** 을 지수적으로 늘리며 재할당(reallocation) 수행
- 대표 복잡도:
  - 인덱스 접근: $$O(1)$$
  - `push_back`: **평균**(amortized) $$O(1)$$, 재할당 발생 시 $$O(n)$$
  - 중간 `insert/erase`: $$O(n)$$ (구간 이동 비용)

### 필수 API & 주석

```cpp
#include <vector>
#include <iostream>
#include <algorithm>
#include <numeric>

int main() {
    std::vector<int> v;          // size=0, capacity=0
    v.reserve(8);                // 용량 미리 확보 → 재할당 횟수↓
    v.push_back(10);
    v.push_back(20);
    v.insert(v.begin(), 5);      // 앞 삽입 O(n): [5,10,20]
    v.insert(v.begin() + 2, 15); // [5,10,15,20]
    v.insert(v.end(), 2, 25);    // 뒤에 25 25 추가

    // 접근
    std::cout << v.at(2) << "\n";     // 범위 체크(예외 던짐)
    std::cout << v[2]     << "\n";    // unchecked
    std::cout << v.front()<< "\n";
    std::cout << v.back() << "\n";

    // 순회
    for (int x : v) std::cout << x << ' '; // 범위 기반 for

    // 삭제
    v.pop_back();                         // 꼬리 하나 제거
    v.erase(v.begin()+1);                 // 한 원소 제거, 뒤 요소들 이동
    v.erase(v.begin()+2, v.end());        // 구간 제거

    // 누적합/알고리즘
    int sum = std::accumulate(v.begin(), v.end(), 0);
    std::cout << "\nsum=" << sum << "\n";

    // 용량 관리
    v.shrink_to_fit(); // 구현체 재량 (항상 줄인다는 보장은 아님)
}
```

### **반복자/포인터/참조 무효화 규칙**

| 상황 | 무효화 범위 |
|---|---|
| `push_back`로 **재할당 발생** | **모든** 반복자/포인터/참조 무효화 |
| `insert/erase` (중간) | **해당 지점 이후** 반복자 무효, 포인터/참조도 영향 가능 |
| `pop_back` | 마지막 원소 관련 반복자/참조 무효 |

> 안전 규칙: 재할당/중간 조작 후에는 **반복자를 다시 획득**하라.

### “지우기”의 정석: **erase-remove 관용구**

```cpp
std::vector<int> v{1,2,3,4,5,6};
// 짝수 제거
v.erase(std::remove_if(v.begin(), v.end(), [](int x){ return x%2==0; }), v.end());
```

- `remove_if`는 **앞으로 당겨 배치**만 하고, 실제로 지우지 않음 → `erase`로 꼬리 정리.

### `emplace*`와 객체 생성 비용 줄이기

```cpp
#include <string>
#include <vector>

int main() {
    std::vector<std::string> names;
    names.reserve(3);
    names.emplace_back("Alice");     // 내부에서 직접 생성(복사/이동 감소)
    names.emplace_back(5, 'x');      // "xxxxx"
}
```

### `assign`, `resize`, `reserve` 차이

| 함수 | 의미 |
|---|---|
| `reserve(n)` | **capacity** 최소 n 보장(크기 변동 X) |
| `resize(n, val)` | **size** 조정(늘릴 때 새 원소 `val`/기본값으로 채움) |
| `assign(count, value)` | 기존 내용 교체 후 count개로 재구성 |

### 예외/이동 시맨틱스

- `vector` 재할당 시 **이동(move) 생성**이 호출됨 → 사용자 타입이 **`noexcept` move** 이면 **강한 보장** 달성 쉬움.
- 예외 안전:
  - 기본 보장: 리소스 누수 없음.
  - 강한 보장: 일부 연산(`insert` 등)은 내부적으로 임시 버퍼에 구성 후 교체.

### 실전 레시피

**(a) 빠른 초기화 + 정렬 + 중복 제거(유니크)**

```cpp
std::vector<int> v{4,1,2,2,3};
std::sort(v.begin(), v.end());                       // 1 2 2 3 4
v.erase(std::unique(v.begin(), v.end()), v.end());   // 1 2 3 4
```

**(b) 안정적인 인덱스 보관 필요 시**: 재할당 전 `reserve`로 용량 확보

```cpp
std::vector<int> v;
v.reserve(100000); // 재할당로직 최소화 → 반복자/포인터 안정성↑
```

---

## `list` — 이중 연결 리스트, **언제 유리한가?**

### 특징과 복잡도

- 각 노드가 **포인터(이전/다음)** 로 연결된 **이중 연결 리스트**
- 랜덤 접근 불가, 인덱스 접근 없음
- 삽입/삭제: 위치만 알면 $$O(1)$$ (포인터 조작)
- 캐시 지역성 **매우 낮음** → 실제 성능은 종종 `vector`보다 **느림** (데이터가 흩어짐 + 할당 오버헤드)

### 필수 API

```cpp
#include <list>
#include <iostream>

int main() {
    std::list<int> l = {1,2,3};
    l.push_front(0);  // 0 1 2 3
    l.push_back(4);   // 0 1 2 3 4

    // iterator 기반 삽입/삭제
    auto it = std::next(l.begin(), 2); // 두 칸 전진 (비용 O(n))
    l.insert(it, 99); // 0 1 99 2 3 4

    // remove 관련 멤버 (연관 컨테이너와 달리 list에는 있음)
    l.remove(99);                // 값이 99인 모든 노드 제거
    l.remove_if([](int x){ return x%2==0; }); // 짝수 제거

    // 안정 정렬/병합/유니크/스플라이스
    l.sort();       // 내부 링크 재배열 → O(n log n) (데이터 이동 없음)
    l.unique();     // 인접 중복 제거
    std::list<int> l2 = {10, 20};
    l.splice(l.begin(), l2);     // l2의 모든 노드를 l의 begin 앞에 **포인터만 이동 (O(1) per node)**

    for (int x : l) std::cout << x << ' ';
}
```

### `std::sort` vs `list::sort`

- `list`는 RandomAccess 이터레이터가 **없음** → `std::sort` **불가**
- `list::sort()` 제공(안정 정렬). 노드 링크만 바꾸므로 값 복사 거의 없음.

### 언제 쓰나?

- **대상 요소의 포인터/참조를 오래 들고 있어야 하고**, 중간 삽입/삭제가 **아주 빈번**하며, **반복자 안정성**이 중요할 때.
- 단, **메모리 파편화/캐시 미스**로 인해, “이론적 O(1)”이 **실전에서는 느릴 수 있음** → **측정**하라.

---

## `deque` — 양끝 O(1) + 랜덤 접근

### 내부 구조

- **고정 크기 블록(버퍼)** 들을 중앙 인덱스 테이블로 관리하는 **분절 배열**.
- 앞/뒤 양끝에서 블록 단위로 확장 → `push_front`/`push_back` **모두** 평균 $$O(1)$$
- 랜덤 접근 지원(`operator[]`), 하지만 **메모리 연속성은 없다**(캐시 지역성은 `vector`보다 나쁠 수 있음).

### 필수 API

```cpp
#include <deque>
#include <iostream>
#include <algorithm>

int main() {
    std::deque<int> d;
    d.push_back(1);    // [1]
    d.push_front(0);   // [0,1]
    d.push_back(2);    // [0,1,2]

    std::cout << d.front() << ' ' << d.back() << '\n'; // 0 2
    d.pop_front();     // [1,2]
    d.pop_back();      // [1]

    // 랜덤 접근 가능
    d.push_back(3); d.push_back(4); // [1,3,4]
    std::cout << d[1] << '\n';      // 3

    // 회전/정렬 (RandomAccess 이터레이터 지원)
    std::rotate(d.begin(), d.begin()+1, d.end()); // [3,4,1]
    std::sort(d.begin(), d.end());                // [1,3,4]
}
```

### 반복자 무효화

- 블록이 추가/삭제되며 **양끝 조작 시 일부/전부 무효화 가능** (구현 의존적)
- 일반 원칙: **조작 후 반복자 재획득**.

### 실전 패턴: **슬라이딩 윈도우/모노토닉 큐**

```cpp
#include <deque>
#include <vector>

// 윈도우 크기 k에서 각 위치의 최대값
std::vector<int> sliding_max(const std::vector<int>& a, int k){
    std::deque<int> dq; // 값이 아니라 "인덱스" 저장, dq는 값 내림차순 유지
    std::vector<int> out;
    for (int i=0; i<(int)a.size(); ++i){
        while(!dq.empty() && a[dq.back()] <= a[i]) dq.pop_back();
        dq.push_back(i);
        if (dq.front() <= i-k) dq.pop_front(); // 윈도우 밖 제거
        if (i >= k-1) out.push_back(a[dq.front()]);
    }
    return out;
}
```

- 양끝 조작이 잦은 **실시간 스트림** 처리에 적합.

---

## 복잡도/반복자 무효화/예외 안전 총정리

### 복잡도 표

| 연산 \ 컨테이너 | `vector` | `deque` | `list` |
|---|---|---|---|
| 임의 접근 | $$O(1)$$ | $$O(1)$$ | 불가 |
| `push_back` | amortized $$O(1)$$ | $$O(1)$$ | $$O(1)$$ |
| `push_front` | $$O(n)$$ | $$O(1)$$ | $$O(1)$$ |
| 중간 `insert/erase` | $$O(n)$$ | $$O(n)$$ | **iterator**가 있으면 $$O(1)$$ |
| 정렬 | `std::sort` $$O(n\log n)$$ | `std::sort` $$O(n\log n)$$ | `list::sort` $$O(n\log n)$$ (안정) |

> **주의**: 이론상 `list` 중간 삽입/삭제 O(1)이라도, 실제 시간은 캐시/메모리 오버헤드로 **느릴 수 있음**.

### 반복자 무효화 한눈에

| 컨테이너 | 어떤 때 무효화? |
|---|---|
| `vector` | 재할당 발생 시 **전부**; 중간 `erase/insert` 후 **그 지점부터** |
| `deque` | 양끝 블록 증감 시 넓은 범위 무효화 가능; 중간 삽입/삭제 O(n) + 무효화 |
| `list` | 지운 노드의 반복자만 무효, 나머지 **안정** |

### 예외 안전 개요

- 표준 컨테이너는 대개 **기본 보장** 제공(누수 없음).
- **강한 보장**은 연산/타입에 따라 다름 — 사용자 타입의 **이동 생성자 `noexcept`** 가 핵심.

---

## 언제 무엇을 선택할까? (실전 기준)

1) **기본 선택은 `vector`**
   - 캐시 지역성 + 알고리즘 호환성 최고. 중간 삽입/삭제도 **덩어리로 모아서** 처리하면 충분히 빠름.
2) **양끝 빈번 삽입/삭제 + 랜덤 접근 필요** → `deque`
   - 실시간 스트림/슬라이딩 윈도우.
3) **반복자/참조 안정성 + 특정 위치 O(1) 변경** → `list`
   - 단, 실제 성능은 측정 필요. 노드 기반이라 느릴 때가 많다.

---

## 실전 패턴·레시피 모음

### 대량 삭제(조건 기반) — `vector`용

```cpp
template<class T, class Pred>
void erase_if(std::vector<T>& v, Pred pred){
    v.erase(std::remove_if(v.begin(), v.end(), pred), v.end());
}
```

### 반복자 안전 삭제 루프 — `list`용

```cpp
std::list<int> L = {1,2,3,4,5,6};
for (auto it = L.begin(); it != L.end(); ) {
    if (*it % 2 == 0) it = L.erase(it); // erase가 다음 반복자 반환
    else ++it;
}
```

### `vector`에서 “중간 삽입 많음” 완화 전략

- **버퍼에 모았다가** 마지막에 `insert` 한 번에:
  ```cpp
  std::vector<int> v{1,2,3,10,11};
  std::vector<int> buf{4,5,6,7,8,9};
  // 3 뒤에 버퍼 일괄 삽입
  v.insert(v.begin()+3, buf.begin(), buf.end());
  ```
- 정렬 유지가 필요 없다면 **끝에 push 후 마지막에 정렬**.

### 스택/큐/우선순위 큐 어댑터와의 궁합

```cpp
#include <stack>    // 기본: deque
#include <queue>    // queue(deque), priority_queue(vector)

std::stack<int> st;          // 내부적으로 deque<int>
std::queue<int> q;           // 내부적으로 deque<int>
std::priority_queue<int> pq; // 내부적으로 vector<int> + 힙
```

- `deque`는 **양끝** 조작 필요 시 어댑터의 기본 선택.

### `shrink_to_fit` 주의

- **권고**(non-binding). 실제 capacity가 줄지 않을 수도 있다(구현 재량).
- 대신 **스왑 트릭**:
  ```cpp
  std::vector<int> v = /*...*/;
  std::vector<int>(v).swap(v); // 임시와 스왑하여 capacity 축소
  ```

### `vector<bool>` 특수화 주의

- 공간 최적화를 위해 **비트 압축**된 특수화 → 참조 타입/포인터 호환성이 특이.
- **비트셋-like** 용도 아니면 가급적 **`std::vector<char>`** 나 `std::vector<uint8_t>` 고려.

---

## 성능 감각(수학 + 하드웨어)

- **복잡도**만 보지 말 것:
  - `list` 중간 삽입/삭제 $$O(1)$$ 이어도 **랜덤 메모리 접근/할당**이 많아 **실제는 느릴 수 있음**.
  - `vector` 중간 삽입/삭제 $$O(n)$$ 이어도 **연속 메모리 복사**는 매우 빠르다.
- **빅오** 상식:
  - 정렬 평균: $$O(n \log n)$$
  - 선택(`nth_element`) 평균: $$O(n)$$
  - `deque` 랜덤 접근: 표준상 $$O(1)$$이지만 내부 분기/간접 참조 비용 존재.

---

## 체크리스트 (요약)

1) 컨테이너 기본값은 **`vector`**
2) **반복자 무효화** 규칙을 외워라 (`vector` 재할당/중간 조작, `unordered` rehash, `list` 안정성)
3) 삭제는 **erase-remove** (`vector`), **반복자 삭제 루프** (`list`)
4) 대량 삽입/삭제는 **일괄 처리** + `reserve`/`emplace` 활용
5) 안정 정렬 필요 & 노드 재배치가 유리하면 `list::sort`
6) **양끝 스트림 처리**는 `deque` + 모노토닉 큐 패턴
7) 사용자 타입에 **`noexcept` move** 제공 → `vector` 품질/예외 안전 향상
8) **측정**: 감보다 프로파일/벤치가 정답

---

## 연습 과제

1) **로그 필터**: `vector<string>`에서 특정 접두사 제거 — `erase-remove` 성능 측정 (`reserve` 유/무 비교).
2) **실시간 최대값**: `deque`로 모노토닉 큐 구현, N=1e7 스트림에서 시간/메모리 측정.
3) **리스트 병합**: `list<int>` 두 개를 정렬 후 `merge` vs `vector`로 합쳐서 정렬 — 실제 시간 비교.
4) **중간 대량 삽입**: `vector`에 1e6개 중간 삽입(1개씩 vs 버퍼 일괄) 시간 비교.
5) **반복자 무효화 테스트**: `vector`에서 포인터/반복자 보관 후 재할당을 강제로 유발하고 동작 확인.

---

## 부록: 간단한 종합 예제

```cpp
#include <bits/stdc++.h>

using namespace std;

int main(){
    // 입력: N개 정수, 짝수 삭제 후, 고유화(정렬+unique), 상위 K개만 출력
    ios::sync_with_stdio(false); cin.tie(nullptr);

    int N, K; cin >> N >> K;
    vector<int> v; v.reserve(N);
    for(int i=0;i<N;++i){ int x; cin >> x; v.push_back(x); }

    // 짝수 삭제 (erase-remove)
    v.erase(remove_if(v.begin(), v.end(), [](int x){ return x%2==0; }), v.end());

    sort(v.begin(), v.end());                         // 정렬
    v.erase(unique(v.begin(), v.end()), v.end());     // 고유화

    // 상위 K개: nth_element + partial sort 느낌
    if (K < (int)v.size()){
        nth_element(v.begin(), v.end()-K, v.end());   // 뒤에서 K개가 top-K
        sort(v.end()-K, v.end(), greater<>());        // 그 구간만 내림차순 정렬
        for(auto it = v.end()-K; it != v.end(); ++it) cout << *it << ' ';
    } else {
        sort(v.begin(), v.end(), greater<>());
        for(int x: v) cout << x << ' ';
    }
}
```

- `reserve`로 재할당 줄이기
- `erase-remove` + `unique`로 필터링/고유화
- `nth_element`로 **Top-K**를 효율적으로 얻기 (전체 정렬보다 빨라짐)

---

## 결론

- `vector`/`list`/`deque`는 “순차”라는 공통점 위에서 **내부 구조가 완전히 다르다**
- 이 구조 차이가 **복잡도/캐시/반복자 안정성/예외 보장**을 좌우
- **일단 `vector`**, 필요 시 `deque`/`list`를 **정확한 이유와 측정**으로 선택하라
