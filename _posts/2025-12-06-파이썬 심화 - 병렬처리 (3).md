---
layout: post
title: 파이썬 심화 - 병렬처리 (3)
date: 2025-12-06 17:30:23 +0900
category: 파이썬 심화
---
# 병렬처리 (3)

## GIL(Global Interpreter Lock)의 이해와 효과적 활용

파이썬의 GIL은 한 번에 하나의 스레드만 파이썬 바이트코드를 실행할 수 있도록 하는 메커니즘입니다. 이를 올바르게 이해하고 우회하는 전략은 고성능 파이썬 애플리케이션 개발의 핵심입니다.

### GIL의 작동 메커니즘과 영향 분석

```python
import threading
import time
import multiprocessing
from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
import numpy as np

class GILAnalyzer:
    """GIL의 영향을 분석하는 도구 클래스"""
    
    def __init__(self):
        self.counter = 0
        self.lock = threading.Lock()
        
    def cpu_bound_task(self, iterations: int = 10000000):
        """CPU 집약적인 작업 (GIL의 영향을 크게 받음)"""
        result = 0
        for i in range(iterations):
            result += i * i
        return result
    
    def io_bound_task(self, sleep_time: float = 0.1):
        """I/O 집약적인 작업 (GIL의 영향을 적게 받음)"""
        time.sleep(sleep_time)
        return sleep_time
    
    def test_gil_impact(self):
        """GIL이 성능에 미치는 영향 측정"""
        
        print("=== GIL 영향 분석 테스트 ===")
        
        # 1. 순차적 실행
        print("\n1. 순차적 실행 (기준)")
        start = time.time()
        for _ in range(4):
            self.cpu_bound_task(1000000)
        sequential_time = time.time() - start
        print(f"순차적 실행 시간: {sequential_time:.3f}초")
        
        # 2. 멀티스레딩 (GIL 영향)
        print("\n2. 멀티스레딩 실행 (GIL 영향)")
        start = time.time()
        threads = []
        for _ in range(4):
            t = threading.Thread(target=lambda: self.cpu_bound_task(1000000))
            threads.append(t)
            t.start()
        
        for t in threads:
            t.join()
        threading_time = time.time() - start
        print(f"멀티스레딩 시간: {threading_time:.3f}초")
        print(f"스레딩 오버헤드: {threading_time/sequential_time:.2f}배")
        
        # 3. 멀티프로세싱 (GIL 우회)
        print("\n3. 멀티프로세싱 실행 (GIL 우회)")
        start = time.time()
        with ProcessPoolExecutor(max_workers=4) as executor:
            futures = [executor.submit(self.cpu_bound_task, 1000000) for _ in range(4)]
            results = [f.result() for f in futures]
        multiprocessing_time = time.time() - start
        print(f"멀티프로세싱 시간: {multiprocessing_time:.3f}초")
        
        # 4. I/O 바운드 작업에서의 멀티스레딩
        print("\n4. I/O 바운드 작업 비교")
        
        # 순차적 I/O
        start = time.time()
        for _ in range(4):
            self.io_bound_task(0.1)
        io_sequential = time.time() - start
        
        # 멀티스레딩 I/O
        start = time.time()
        threads = []
        for _ in range(4):
            t = threading.Thread(target=lambda: self.io_bound_task(0.1))
            threads.append(t)
            t.start()
        
        for t in threads:
            t.join()
        io_threading = time.time() - start
        
        print(f"I/O 순차적: {io_sequential:.3f}초")
        print(f"I/O 멀티스레딩: {io_threading:.3f}초")
        print(f"I/O 스레딩 이점: {io_sequential/io_threading:.2f}배 향상")
        
        return {
            'sequential': sequential_time,
            'threading': threading_time,
            'multiprocessing': multiprocessing_time,
            'io_improvement': io_sequential / io_threading
        }

class GILWorkaroundStrategies:
    """GIL을 우회하는 다양한 전략"""
    
    @staticmethod
    def using_multiprocessing():
        """멀티프로세싱을 통한 GIL 우회"""
        
        def parallel_computation(data_chunks):
            """데이터 청크를 병렬로 처리"""
            with ProcessPoolExecutor() as executor:
                results = list(executor.map(
                    lambda chunk: sum(x*x for x in chunk),
                    data_chunks
                ))
            return sum(results)
        
        # 데이터 분할 예시
        data = list(range(1000000))
        chunk_size = len(data) // multiprocessing.cpu_count()
        chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
        
        return parallel_computation(chunks)
    
    @staticmethod
    def using_cython_or_c_extensions():
        """C 확장을 통한 GIL 해제"""
        # 실제 구현에는 Cython이나 C 확장 필요
        print("C 확장에서는 Py_BEGIN_ALLOW_THREADS / Py_END_ALLOW_THREADS로 GIL 해제 가능")
        
    @staticmethod
    def using_numpy_operations():
        """NumPy의 C 기반 연산 활용"""
        # NumPy 연산은 C 레벨에서 실행되므로 GIL의 영향을 받지 않음
        print("NumPy 연산은 내부적으로 C 구현을 사용하므로 GIL 영향 적음")
        
        arr = np.random.rand(1000000)
        # 이 연산은 GIL을 해제한 상태로 C 레벨에서 실행됨
        result = np.sum(arr * arr)
        return result
    
    @staticmethod
    def async_io_for_concurrency():
        """비동기 I/O를 통한 동시성 확보"""
        import asyncio
        
        async def io_operation(name, delay):
            print(f"{name} 시작")
            await asyncio.sleep(delay)
            print(f"{name} 완료")
            return f"{name}:{delay}"
        
        async def main():
            # 여러 I/O 작업을 동시에 실행
            tasks = [
                io_operation("작업1", 1.0),
                io_operation("작업2", 0.5),
                io_operation("작업3", 1.5)
            ]
            
            results = await asyncio.gather(*tasks)
            print(f"모든 작업 완료: {results}")
        
        asyncio.run(main())

class ThreadSafeCounter:
    """GIL 환경에서의 스레드 안전 카운터"""
    
    def __init__(self):
        self._value = 0
        self._lock = threading.Lock()
        
    def increment(self):
        """락을 사용한 안전한 증가"""
        with self._lock:
            self._value += 1
            # GIL이 있더라도 += 연산은 원자적이지 않음
            # 실제로는 LOAD, INCREMENT, STORE 세 단계로 나뉨
            
    def increment_atomic(self):
        """원자적 연산을 통한 증가 (런타임 의존적)"""
        # 참고: 파이썬 3.11+에서는 일부 연산이 더 원자적으로 처리됨
        import sys
        if sys.version_info >= (3, 11):
            # 파이썬 3.11에서는 일부 연산이 더 효율적으로 처리됨
            pass
        self._value += 1  # 여전히 완전한 원자성 보장 안됨
            
    def get_value(self):
        """현재 값 읽기"""
        with self._lock:
            return self._value
    
    def increment_without_lock(self):
        """락 없이 증가 (위험!)"""
        self._value += 1
        # 레이스 컨디션 발생 가능

def demonstrate_gil_issues():
    """GIL 관련 문제 시연"""
    
    print("\n=== GIL 관련 문제 시연 ===")
    
    # 공유 자원
    shared_list = []
    
    def append_to_list(item):
        for i in range(1000):
            shared_list.append(f"{item}-{i}")
    
    # 두 스레드가 동시에 리스트에 추가
    t1 = threading.Thread(target=append_to_list, args=("A",))
    t2 = threading.Thread(target=append_to_list, args=("B",))
    
    t1.start()
    t2.start()
    t1.join()
    t2.join()
    
    print(f"리스트 길이: {len(shared_list)} (예상: 2000)")
    print(f"실제: {len(shared_list)}")
    
    # 데이터 손실 가능성 확인
    if len(shared_list) != 2000:
        print("경고: 데이터 손실 발생 가능!")
```

## 액터 모델 구현과 작업 정의

액터 모델은 동시성 프로그래밍을 위한 수학적 모델로, 각 액터가 독립적인 상태와 메일박스를 가지며 메시지를 통해 통신합니다.

### 완전한 액터 시스템 구현

```python
import threading
import queue
import time
from typing import Any, Callable, Dict, Optional
from dataclasses import dataclass, field
from enum import Enum
import uuid

class MessageType(Enum):
    """액터 메시지 타입"""
    TASK = "task"
    RESULT = "result"
    ERROR = "error"
    CONTROL = "control"
    BROADCAST = "broadcast"

@dataclass
class ActorMessage:
    """액터 간 전송되는 메시지"""
    message_id: str
    sender: str  # 송신자 액터 ID
    recipient: str  # 수신자 액터 ID
    message_type: MessageType
    content: Any
    timestamp: float = field(default_factory=time.time)
    reply_to: Optional[str] = None  # 응답을 기대하는 경우 원본 메시지 ID
    
    def create_reply(self, content: Any, message_type: MessageType = MessageType.RESULT):
        """이 메시지에 대한 응답 생성"""
        return ActorMessage(
            message_id=str(uuid.uuid4()),
            sender=self.recipient,  # 응답자는 현재 수신자
            recipient=self.sender,  # 송신자에게 회신
            message_type=message_type,
            content=content,
            reply_to=self.message_id
        )

class Actor:
    """액터 기본 클래스"""
    
    def __init__(self, actor_id: Optional[str] = None):
        self.actor_id = actor_id or f"actor_{uuid.uuid4().hex[:8]}"
        self.mailbox = queue.Queue(maxsize=1000)  # 메시지 큐
        self.running = False
        self.thread = None
        self.handlers: Dict[MessageType, Callable] = {
            MessageType.TASK: self.handle_task,
            MessageType.CONTROL: self.handle_control,
            MessageType.ERROR: self.handle_error
        }
        self.state = {}  # 액터 상태 저장소
        
    def start(self):
        """액터 실행 시작"""
        self.running = True
        self.thread = threading.Thread(target=self._run_loop, daemon=True)
        self.thread.start()
        print(f"액터 시작됨: {self.actor_id}")
        
    def stop(self):
        """액터 실행 중지"""
        self.running = False
        # 중지 메시지 전송
        self.send_to_self(ActorMessage(
            message_id=str(uuid.uuid4()),
            sender="system",
            recipient=self.actor_id,
            message_type=MessageType.CONTROL,
            content={"command": "shutdown"}
        ))
        
    def _run_loop(self):
        """액터 실행 루프"""
        while self.running:
            try:
                # 메시지 대기 (타임아웃으로 주기적 상태 확인)
                try:
                    message = self.mailbox.get(timeout=0.1)
                except queue.Empty:
                    continue
                
                # 메시지 처리
                self.process_message(message)
                
                # 작업 완료 표시
                self.mailbox.task_done()
                
            except Exception as e:
                print(f"액터 {self.actor_id} 오류: {e}")
                # 오류 복구 로직
                self.handle_system_error(e)
    
    def process_message(self, message: ActorMessage):
        """메시지 처리"""
        handler = self.handlers.get(message.message_type)
        if handler:
            try:
                handler(message)
            except Exception as e:
                # 처리 중 오류 발생 시 오류 메시지 회신
                error_reply = message.create_reply(
                    {"error": str(e), "type": type(e).__name__},
                    MessageType.ERROR
                )
                self.send_message(error_reply)
        else:
            print(f"액터 {self.actor_id}: 처리기 없는 메시지 타입: {message.message_type}")
    
    def handle_task(self, message: ActorMessage):
        """작업 메시지 처리 (서브클래스에서 오버라이드)"""
        print(f"액터 {self.actor_id}: 작업 수신: {message.content}")
        # 기본 구현: 에코 응답
        reply = message.create_reply(
            {"status": "processed", "original": message.content}
        )
        self.send_message(reply)
    
    def handle_control(self, message: ActorMessage):
        """제어 메시지 처리"""
        command = message.content.get("command")
        if command == "shutdown":
            print(f"액터 {self.actor_id}: 종료 명령 수신")
            self.running = False
        elif command == "status":
            reply = message.create_reply({
                "status": "running",
                "mailbox_size": self.mailbox.qsize(),
                "state": self.state
            })
            self.send_message(reply)
    
    def handle_error(self, message: ActorMessage):
        """오류 메시지 처리"""
        print(f"액터 {self.actor_id}: 오류 수신: {message.content}")
    
    def handle_system_error(self, error: Exception):
        """시스템 오류 처리"""
        print(f"액터 {self.actor_id}: 시스템 오류: {error}")
        # 오류 복구 로직 구현
    
    def send_message(self, message: ActorMessage):
        """다른 액터에게 메시지 전송"""
        # 실제 구현에서는 액터 시스템의 디스패처를 통해 전송
        print(f"액터 {self.actor_id} -> {message.recipient}: {message.message_type}")
        # 여기서는 액터 시스템에 메시지 전달
        ActorSystem.get_instance().dispatch(message)
    
    def send_to_self(self, message: ActorMessage):
        """자기 자신에게 메시지 전송"""
        self.mailbox.put(message)
    
    def set_state(self, key: str, value: Any):
        """액터 상태 설정"""
        self.state[key] = value
    
    def get_state(self, key: str, default: Any = None) -> Any:
        """액터 상태 조회"""
        return self.state.get(key, default)

class WorkerActor(Actor):
    """작업 처리 전문 액터"""
    
    def __init__(self, actor_id: Optional[str] = None, specialization: str = "general"):
        super().__init__(actor_id)
        self.specialization = specialization
        self.tasks_completed = 0
        
        # 작업 처리기 등록
        self.handlers[MessageType.TASK] = self.handle_worker_task
    
    def handle_worker_task(self, message: ActorMessage):
        """작업자 액터용 작업 처리"""
        task = message.content
        
        print(f"작업자 {self.actor_id}[{self.specialization}]: 작업 처리 시작: {task}")
        
        # 작업 시뮬레이션
        time.sleep(0.1)  # 작업 처리 시간
        
        # 작업 결과 생성
        result = {
            "worker": self.actor_id,
            "specialization": self.specialization,
            "task": task,
            "result": f"처리된_{task}",
            "completed_tasks": self.tasks_completed + 1
        }
        
        self.tasks_completed += 1
        
        # 결과 회신
        if message.reply_to:  # 응답 기대하는 메시지인 경우
            reply = message.create_reply(result)
            self.send_message(reply)
        
        print(f"작업자 {self.actor_id}: 작업 완료")

class SupervisorActor(Actor):
    """작업 감독 액터"""
    
    def __init__(self, actor_id: Optional[str] = None):
        super().__init__(actor_id)
        self.workers = {}  # worker_id -> specialization
        self.task_queue = queue.Queue()
        self.task_results = {}
        
        self.handlers[MessageType.TASK] = self.handle_supervisor_task
        self.handlers[MessageType.RESULT] = self.handle_task_result
    
    def register_worker(self, worker_id: str, specialization: str):
        """작업자 액터 등록"""
        self.workers[worker_id] = specialization
        print(f"감독자 {self.actor_id}: 작업자 등록 - {worker_id}({specialization})")
    
    def handle_supervisor_task(self, message: ActorMessage):
        """감독자 작업 처리"""
        task = message.content
        task_id = str(uuid.uuid4())
        
        print(f"감독자 {self.actor_id}: 작업 수신, ID: {task_id}")
        
        # 작업자에게 작업 분배
        worker_id = self.select_worker(task)
        if worker_id:
            worker_message = ActorMessage(
                message_id=str(uuid.uuid4()),
                sender=self.actor_id,
                recipient=worker_id,
                message_type=MessageType.TASK,
                content=task,
                reply_to=message.message_id  # 원본 요청에 응답
            )
            
            # 결과 추적을 위해 저장
            self.task_results[task_id] = {
                "original_message": message,
                "assigned_to": worker_id,
                "status": "processing"
            }
            
            self.send_message(worker_message)
            print(f"감독자 {self.actor_id}: 작업 {task_id} -> {worker_id}")
        else:
            # 사용 가능한 작업자 없음
            error_reply = message.create_reply(
                {"error": "사용 가능한 작업자 없음", "task": task},
                MessageType.ERROR
            )
            self.send_message(error_reply)
    
    def handle_task_result(self, message: ActorMessage):
        """작업 결과 처리"""
        result = message.content
        task_id = message.reply_to  # 원본 작업 ID
        
        if task_id in self.task_results:
            self.task_results[task_id]["status"] = "completed"
            self.task_results[task_id]["result"] = result
            
            # 원래 요청자에게 결과 전달
            original_message = self.task_results[task_id]["original_message"]
            final_reply = original_message.create_reply(result)
            self.send_message(final_reply)
            
            print(f"감독자 {self.actor_id}: 작업 {task_id} 완료")
    
    def select_worker(self, task) -> Optional[str]:
        """작업에 적합한 작업자 선택"""
        # 간단한 라운드 로빈 선택
        # 실제로는 작업 유형, 작업자 부하 등에 기반한 선택 로직 구현
        if not self.workers:
            return None
        
        worker_ids = list(self.workers.keys())
        # 여기서는 첫 번째 작업자 반환
        return worker_ids[0]

class ActorSystem:
    """액터 시스템 관리자 (싱글톤)"""
    
    _instance = None
    _lock = threading.Lock()
    
    def __new__(cls):
        with cls._lock:
            if cls._instance is None:
                cls._instance = super().__new__(cls)
                cls._instance.actors = {}
                cls._instance.message_routes = {}
            return cls._instance
    
    @classmethod
    def get_instance(cls):
        return cls()
    
    def register_actor(self, actor: Actor):
        """액터 등록"""
        self.actors[actor.actor_id] = actor
        print(f"액터 시스템: 액터 등록됨 - {actor.actor_id}")
    
    def dispatch(self, message: ActorMessage):
        """메시지 전달"""
        recipient = message.recipient
        
        if recipient in self.actors:
            try:
                self.actors[recipient].mailbox.put(message)
            except queue.Full:
                # 메일박스 가득 참
                error_msg = message.create_reply(
                    {"error": "메일박스 가득 참", "recipient": recipient},
                    MessageType.ERROR
                )
                # 가능하면 송신자에게 오류 통보
                if message.sender in self.actors:
                    self.actors[message.sender].mailbox.put(error_msg)
        else:
            print(f"액터 시스템: 알 수 없는 수신자 - {recipient}")
    
    def broadcast(self, message: ActorMessage, exclude_sender: bool = True):
        """모든 액터에 브로드캐스트"""
        for actor_id, actor in self.actors.items():
            if exclude_sender and actor_id == message.sender:
                continue
            
            broadcast_msg = ActorMessage(
                message_id=str(uuid.uuid4()),
                sender=message.sender,
                recipient=actor_id,
                message_type=MessageType.BROADCAST,
                content=message.content
            )
            self.dispatch(broadcast_msg)
    
    def shutdown_all(self):
        """모든 액터 종료"""
        print("액터 시스템: 모든 액터 종료 중...")
        
        # 종료 명령 브로드캐스트
        shutdown_msg = ActorMessage(
            message_id=str(uuid.uuid4()),
            sender="system",
            recipient="broadcast",
            message_type=MessageType.CONTROL,
            content={"command": "shutdown"}
        )
        self.broadcast(shutdown_msg, exclude_sender=False)
        
        # 액터 종료 대기
        time.sleep(0.5)
        
        # 액터 정리
        for actor in self.actors.values():
            if actor.thread and actor.thread.is_alive():
                actor.thread.join(timeout=1.0)
        
        print("액터 시스템: 종료 완료")
```

## 메시지 발행/구독(Pub/Sub) 패턴 구현

Pub/Sub 패턴은 메시지 생산자(발행자)와 소비자(구독자)를 분리하여 느슨한 결합을 제공합니다.

### 완전한 Pub/Sub 시스템 구현

```python
import threading
import queue
import time
from typing import Dict, List, Callable, Any, Set, Optional
from dataclasses import dataclass, field
import json
import hashlib
from enum import Enum

class TopicPattern:
    """토픽 패턴 매칭 클래스"""
    
    @staticmethod
    def matches(topic: str, pattern: str) -> bool:
        """
        토픽 패턴 매칭
        - *: 단일 레벨 와일드카드
        - #: 다중 레벨 와일드카드
        """
        topic_parts = topic.split('/')
        pattern_parts = pattern.split('/')
        
        t_len, p_len = len(topic_parts), len(pattern_parts)
        t_idx, p_idx = 0, 0
        
        while t_idx < t_len and p_idx < p_len:
            if pattern_parts[p_idx] == '#':
                return True
            elif pattern_parts[p_idx] == '*':
                t_idx += 1
                p_idx += 1
            elif pattern_parts[p_idx] == topic_parts[t_idx]:
                t_idx += 1
                p_idx += 1
            else:
                return False
        
        # 남은 패턴 부분이 모두 '#'인지 확인
        while p_idx < p_len and pattern_parts[p_idx] == '#':
            p_idx += 1
        
        return t_idx == t_len and p_idx == p_len

class MessagePriority(Enum):
    """메시지 우선순위"""
    LOW = 0
    NORMAL = 1
    HIGH = 2
    CRITICAL = 3

@dataclass(order=True)
class PrioritizedMessage:
    """우선순위 큐를 위한 메시지 래퍼"""
    priority: int
    timestamp: float
    message: Any = field(compare=False)

class Message:
    """Pub/Sub 메시지"""
    
    def __init__(self, topic: str, payload: Any, 
                 priority: MessagePriority = MessagePriority.NORMAL,
                 metadata: Optional[Dict] = None):
        self.id = hashlib.md5(f"{topic}:{time.time()}:{payload}".encode()).hexdigest()[:8]
        self.topic = topic
        self.payload = payload
        self.priority = priority
        self.timestamp = time.time()
        self.metadata = metadata or {}
        self.metadata['created_at'] = self.timestamp
        self.metadata['source'] = threading.current_thread().name
    
    def to_dict(self) -> Dict:
        """메시지를 딕셔너리로 변환"""
        return {
            'id': self.id,
            'topic': self.topic,
            'payload': self.payload,
            'priority': self.priority.value,
            'timestamp': self.timestamp,
            'metadata': self.metadata
        }
    
    def to_json(self) -> str:
        """메시지를 JSON 문자열로 변환"""
        return json.dumps(self.to_dict(), default=str)

class Subscription:
    """구독 정보"""
    
    def __init__(self, subscriber_id: str, topic_pattern: str, 
                 callback: Callable, priority: int = 0):
        self.subscriber_id = subscriber_id
        self.topic_pattern = topic_pattern
        self.callback = callback
        self.priority = priority
        self.created_at = time.time()
        self.message_count = 0
    
    def matches(self, topic: str) -> bool:
        """토픽이 이 구독과 매칭되는지 확인"""
        return TopicPattern.matches(topic, self.topic_pattern)

class MessageBroker:
    """메시지 브로커 (중앙 허브)"""
    
    def __init__(self, max_queue_size: int = 10000):
        self.subscriptions: Dict[str, List[Subscription]] = {}
        self.message_queue = queue.PriorityQueue(maxsize=max_queue_size)
        self.running = False
        self.workers = []
        self.worker_count = 2  # 메시지 처리 워커 수
        self.stats = {
            'messages_published': 0,
            'messages_delivered': 0,
            'messages_dropped': 0,
            'subscriptions': 0
        }
        self._lock = threading.RLock()
        
    def start(self):
        """브로커 시작"""
        self.running = True
        
        # 메시지 처리 워커 시작
        for i in range(self.worker_count):
            worker = threading.Thread(
                target=self._message_worker,
                args=(i,),
                daemon=True,
                name=f"BrokerWorker-{i}"
            )
            worker.start()
            self.workers.append(worker)
        
        print(f"메시지 브로커 시작됨 (워커: {self.worker_count})")
    
    def stop(self):
        """브로커 중지"""
        self.running = False
        
        # 워커들이 종료될 시간을 줌
        time.sleep(0.5)
        
        print(f"메시지 브로커 종료. 통계: {self.stats}")
    
    def publish(self, message: Message) -> bool:
        """메시지 발행"""
        with self._lock:
            self.stats['messages_published'] += 1
        
        try:
            # 우선순위 큐에 메시지 추가
            prioritized = PrioritizedMessage(
                priority=message.priority.value,
                timestamp=message.timestamp,
                message=message
            )
            self.message_queue.put(prioritized, block=False)
            return True
        except queue.Full:
            with self._lock:
                self.stats['messages_dropped'] += 1
            print(f"메시지 큐 가득 참. 메시지 드롭: {message.topic}")
            return False
    
    def subscribe(self, topic_pattern: str, callback: Callable, 
                  subscriber_id: Optional[str] = None, priority: int = 0) -> str:
        """토픽 구독"""
        sub_id = subscriber_id or f"sub_{threading.get_ident()}_{time.time()}"
        
        subscription = Subscription(
            subscriber_id=sub_id,
            topic_pattern=topic_pattern,
            callback=callback,
            priority=priority
        )
        
        with self._lock:
            if topic_pattern not in self.subscriptions:
                self.subscriptions[topic_pattern] = []
            
            self.subscriptions[topic_pattern].append(subscription)
            self.subscriptions[topic_pattern].sort(key=lambda s: s.priority, reverse=True)
            
            self.stats['subscriptions'] += 1
        
        print(f"구독 등록됨: {sub_id} -> {topic_pattern}")
        return sub_id
    
    def unsubscribe(self, subscription_id: str) -> bool:
        """구독 해제"""
        with self._lock:
            for pattern, subs in self.subscriptions.items():
                for i, sub in enumerate(subs):
                    if sub.subscriber_id == subscription_id:
                        subs.pop(i)
                        
                        # 빈 리스트 정리
                        if not subs:
                            del self.subscriptions[pattern]
                        
                        self.stats['subscriptions'] -= 1
                        print(f"구독 해제됨: {subscription_id}")
                        return True
        return False
    
    def _message_worker(self, worker_id: int):
        """메시지 처리 워커"""
        print(f"메시지 워커 {worker_id} 시작")
        
        while self.running:
            try:
                # 메시지 가져오기
                prioritized = self.message_queue.get(timeout=0.1)
                message = prioritized.message
                
                # 매칭되는 구독 찾기
                matched_subscriptions = []
                
                with self._lock:
                    for pattern, subscriptions in self.subscriptions.items():
                        if TopicPattern.matches(message.topic, pattern):
                            matched_subscriptions.extend(subscriptions)
                
                # 구독자에게 메시지 전달
                for subscription in matched_subscriptions:
                    try:
                        # 콜백 실행
                        subscription.callback(message)
                        subscription.message_count += 1
                        
                        with self._lock:
                            self.stats['messages_delivered'] += 1
                            
                    except Exception as e:
                        print(f"메시지 전달 실패 ({subscription.subscriber_id}): {e}")
                
                # 작업 완료 표시
                self.message_queue.task_done()
                
            except queue.Empty:
                continue
            except Exception as e:
                print(f"메시지 워커 {worker_id} 오류: {e}")
        
        print(f"메시지 워커 {worker_id} 종료")
    
    def get_stats(self) -> Dict:
        """브로커 통계 반환"""
        with self._lock:
            stats_copy = self.stats.copy()
            stats_copy['queue_size'] = self.message_queue.qsize()
            stats_copy['subscription_patterns'] = len(self.subscriptions)
            return stats_copy

class TopicManager:
    """토픽 계층 관리자"""
    
    def __init__(self):
        self.topic_tree = {}
        self.wildcard_subscriptions = {
            'single_level': set(),  # * 패턴
            'multi_level': set()    # # 패턴
        }
    
    def add_subscription(self, topic_pattern: str, subscription_id: str):
        """토픽 패턴 구독 추가"""
        if '#' in topic_pattern:
            self.wildcard_subscriptions['multi_level'].add((topic_pattern, subscription_id))
        elif '*' in topic_pattern:
            self.wildcard_subscriptions['single_level'].add((topic_pattern, subscription_id))
        else:
            # 정확한 토픽 매칭
            parts = topic_pattern.split('/')
            node = self.topic_tree
            
            for part in parts:
                if part not in node:
                    node[part] = {}
                node = node[part]
            
            if '_subscribers' not in node:
                node['_subscribers'] = set()
            node['_subscribers'].add(subscription_id)
    
    def get_subscribers(self, topic: str) -> Set[str]:
        """토픽의 구독자 조회"""
        subscribers = set()
        parts = topic.split('/')
        
        # 정확한 매칭
        node = self.topic_tree
        for i, part in enumerate(parts):
            if part in node:
                node = node[part]
                if '_subscribers' in node:
                    subscribers.update(node['_subscribers'])
            else:
                break
        
        # 와일드카드 매칭
        for pattern, sub_id in self.wildcard_subscriptions['single_level']:
            if TopicPattern.matches(topic, pattern):
                subscribers.add(sub_id)
        
        for pattern, sub_id in self.wildcard_subscriptions['multi_level']:
            if TopicPattern.matches(topic, pattern):
                subscribers.add(sub_id)
        
        return subscribers

# Pub/Sub 시스템 사용 예시
def pub_sub_demo():
    """Pub/Sub 시스템 데모"""
    
    def stock_price_handler(message: Message):
        print(f"[주가] {message.topic}: {message.payload}")
    
    def system_alert_handler(message: Message):
        print(f"[알림] {message.topic}: {message.payload}")
    
    def all_messages_handler(message: Message):
        print(f"[모든메시지] {message.topic}: {message.payload}")
    
    # 브로커 생성 및 시작
    broker = MessageBroker()
    broker.start()
    
    # 구독 등록
    stock_sub = broker.subscribe("stocks/+/price", stock_price_handler, "stock_watcher")
    alert_sub = broker.subscribe("alerts/#", system_alert_handler, "alert_monitor")
    all_sub = broker.subscribe("#", all_messages_handler, "global_watcher")
    
    # 메시지 발행
    messages = [
        Message("stocks/AAPL/price", {"price": 150.25, "change": 1.5}, MessagePriority.HIGH),
        Message("stocks/GOOG/price", {"price": 2800.50, "change": -5.2}, MessagePriority.NORMAL),
        Message("alerts/system/health", {"status": "healthy", "load": 0.45}, MessagePriority.LOW),
        Message("alerts/security/intrusion", {"severity": "high", "source": "external"}, MessagePriority.CRITICAL),
        Message("logs/application", {"level": "INFO", "message": "Application started"}, MessagePriority.LOW)
    ]
    
    # 메시지 발행
    for msg in messages:
        broker.publish(msg)
        time.sleep(0.1)  # 처리 시간을 주기 위해
    
    # 잠시 대기 후 통계 확인
    time.sleep(1)
    stats = broker.get_stats()
    print(f"\n브로커 통계: {stats}")
    
    # 구독 해제 예시
    broker.unsubscribe(all_sub)
    
    # 추가 메시지 발행 (모든 메시지 구독자는 해제됨)
    broker.publish(Message("test/topic", "이 메시지는 모든 메시지 핸들러에서 처리 안됨"))
    
    time.sleep(0.5)
    
    # 브로커 종료
    broker.stop()

class DurablePubSubBroker(MessageBroker):
    """지속성이 있는 Pub/Sub 브로커"""
    
    def __init__(self, max_queue_size: int = 10000, persistence_file: Optional[str] = None):
        super().__init__(max_queue_size)
        self.persistence_file = persistence_file
        self.durable_subscriptions = {}
        
        # 지속성 로드
        if persistence_file:
            self._load_persistence()
    
    def subscribe(self, topic_pattern: str, callback: Callable, 
                  subscriber_id: Optional[str] = None, priority: int = 0,
                  durable: bool = False) -> str:
        """구독 (지속성 옵션 포함)"""
        sub_id = super().subscribe(topic_pattern, callback, subscriber_id, priority)
        
        if durable:
            self.durable_subscriptions[sub_id] = {
                'topic_pattern': topic_pattern,
                'callback': callback,
                'priority': priority,
                'durable': True
            }
        
        return sub_id
    
    def _save_persistence(self):
        """구독 정보 지속성 저장"""
        if not self.persistence_file:
            return
        
        import pickle
        try:
            with open(self.persistence_file, 'wb') as f:
                pickle.dump(self.durable_subscriptions, f)
        except Exception as e:
            print(f"지속성 저장 실패: {e}")
    
    def _load_persistence(self):
        """구독 정보 지속성 로드"""
        import os
        import pickle
        
        if not os.path.exists(self.persistence_file):
            return
        
        try:
            with open(self.persistence_file, 'rb') as f:
                self.durable_subscriptions = pickle.load(f)
                
                # 지속성 구독 복구
                for sub_id, info in self.durable_subscriptions.items():
                    super().subscribe(
                        info['topic_pattern'],
                        info['callback'],
                        sub_id,
                        info['priority']
                    )
                
                print(f"지속성 구독 복구 완료: {len(self.durable_subscriptions)}개")
        except Exception as e:
            print(f"지속성 로드 실패: {e}")
```

## 결론

### GIL 관리의 전략적 접근법
파이썬의 GIL은 동시성 프로그래밍에 있어 근본적인 제약이지만, 올바른 전략으로 효과적으로 관리할 수 있습니다:

1. **작업 유형별 접근법**:
   - **CPU 바운드 작업**: `multiprocessing` 모듈을 활용하여 프로세스 수준 병렬화
   - **I/O 바운드 작업**: `threading`이나 `asyncio`를 활용하여 동시성 확보
   - **혼합형 작업**: 작업을 유형별로 분리하여 각각 적합한 방식을 적용

2. **GIL 우회 기술**:
   - C 확장 활용 (Py_BEGIN_ALLOW_THREADS / Py_END_ALLOW_THREADS)
   - NumPy, SciPy 등 C 기반 라이브러리 활용
   - JIT 컴파일러 (PyPy) 고려 (상황에 따라 GIL 동작이 다름)

3. **성능 최적화**:
   - 프로파일링을 통한 실제 병목 지점 확인
   - 적절한 동시성 모델 선택 (스레드 vs 프로세스 vs 비동기)
   - 메모리 공유 최소화 및 복사 비용 고려

### 액터 모델의 구현 원칙
액터 모델은 복잡한 동시성 문제를 해결하는 강력한 패러다임입니다:

1. **액터 설계 원칙**:
   - 각 액터는 독립적인 상태와 메일박스를 가짐
   - 메시지 전달을 통한 통신 (공유 메모리 최소화)
   - 실패 격리와 감독 계층을 통한 복원력 확보

2. **시스템 구성**:
   - 특화된 액터 역할 정의 (Worker, Supervisor, Router 등)
   - 계층적 구조를 통한 책임 분리
   - 메시지 라우팅과 로드 밸런싱 메커니즘 구현

3. **모니터링과 디버깅**:
   - 액터 상태 추적 및 메시지 흐름 모니터링
   - 데드 레터 박스(미처리 메시지) 처리
   - 성능 메트릭 수집과 시각화

### Pub/Sub 패턴의 구현 모범 사례
메시지 기반 통신의 핵심인 Pub/Sub 패턴은 확장성 있는 시스템 구축에 필수적입니다:

1. **토픽 설계 전략**:
   - 의미 있는 계층적 토픽 구조 설계 (예: `domain/entity/action`)
   - 와일드카드 패턴의 신중한 사용 (`*`, `#`)
   - 버전 관리 전략 (예: `api/v1/user/create`)

2. **메시지 처리 보장**:
   - 우선순위 큐를 통한 중요 메시지 우선 처리
   - 지속성 구독과 메시지 재전송 메커니즘
   - 배달 보장 수준 설정 (at-most-once, at-least-once, exactly-once)

3. **확장성 고려사항**:
   - 브로커 클러스터링과 샤딩 전략
   - 메시지 필터링과 변환 기능
   - 보안과 인증 메커니즘 통합

### 통합 아키텍처 패턴
이 세 가지 패턴을 효과적으로 결합할 때 고려해야 할 점:

1. **하이브리드 접근법**:
   - 액터 내부에서 GIL 영향을 받는 작업은 프로세스로 분리
   - 액터 간 통신에 Pub/Sub 패턴 적용
   - 시스템 경계에서 적절한 동시성 모델 선택

2. **성능 모니터링**:
   - 분산 트레이싱과 로깅 시스템 통합
   - 실시간 성능 메트릭 대시보드 구축
   - 용량 계획과 부하 테스트 정기 수행

3. **운영 효율성**:
   - 설정 기반의 유연한 아키텍처 구성
   - 핫 스왑 가능한 컴포넌트 설계
   - 자동 복구와 그레이스풀 디그레이데이션 구현

이러한 패턴들과 원칙들을 적용할 때는 항상 애플리케이션의 특정 요구사항, 팀의 전문성, 운영 환경을 고려해야 합니다. 파이썬의 동시성 도구들은 지속적으로 발전하고 있으므로, 최신 버전의 기능과 최적화 기법을 지속적으로 학습하는 것이 중요합니다.