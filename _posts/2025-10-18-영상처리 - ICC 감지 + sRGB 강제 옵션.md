---
layout: post
title: 영상처리 - ICC 감지 + sRGB 강제 옵션
date: 2025-10-18 20:25:23 +0900
category: 영상처리
---
# ICC 감지 + sRGB 강제 옵션

> **목표**
> - JPEG을 열 때 **ICC 프로파일**(APP2: `ICC_PROFILE`)을 **감지**한다.
> - **없으면 sRGB로 간주**(일반 뷰어와 동일 가정), **있으면 보존**이 기본 정책.
> - “**sRGB 강제 변환하여 저장**” 토글을 켜면, **임베디드 프로파일 → sRGB로 픽셀 변환**한 뒤 **sRGB ICC를 부착**하여 저장한다.
> - EXIF, XMP 등 다른 메타는 그대로 보존한다(선택적으로 Strip 옵션 운영 가능).

---

## 운영 규칙(요약)

| 입력 ICC | 토글 OFF(기본) | 토글 ON(강제 sRGB 저장) |
|---|---|---|
| 있음 | 픽셀 **그대로**, ICC **그대로** 보존 | 픽셀을 **ICC→sRGB** 변환, sRGB ICC **부착** |
| 없음 | 픽셀 **그대로**, ICC 없음(=sRGB 가정) | 픽셀 **변화 없음**(이미 sRGB 가정), **sRGB ICC 부착**(명시 태깅) |

> 실전 팁: 웹·앱 파이프라인에서 색 일관성을 높이려면 **토글 ON**을 기본값으로 두고, “원본 색역 보존”이 필요한 워크플로(인쇄 등)만 예외처리하는 것이 안전합니다.

---

## 준비물

- **libjpeg(-turbo)** : 디코드/인코드 + APP 마커 접근
- **lcms2** : ICC 프로파일 로딩/색공간 변환
- (선택) **exiftool** : 테스트시 메타 확인용 CLI

설치 예)
- vcpkg: `vcpkg install libjpeg-turbo lcms`
- brew: `brew install jpeg-turbo little-cms2`

---

## JPEG의 ICC 마커 형식(요점)

- APP2 마커의 payload는 **여러 개 세그먼트**로 쪼개질 수 있습니다.
  각 세그먼트는 아래 헤더로 시작합니다:
```
"ICC_PROFILE\0" (12바이트) + seq_no(1) + seq_count(1) + [ICC 데이터 청크...]
```
- 저장 시에도 동일 포맷으로 **분할**해서 써야 합니다(한 세그먼트 payload 최대 ≈ 65519 bytes).

---

## 코드: **ICC 수집/쓰기 유틸** (APP2: ICC_PROFILE)

```cpp
#include <jpeglib.h>
#include <vector>
#include <string>
#include <cstdint>
#include <memory>
#include <algorithm>
#include <cstring>
#include <stdexcept>

// ---- 파일 핸들 유틸
struct FileCloser { void operator()(FILE* f) const { if (f) fclose(f); } };
using FilePtr = std::unique_ptr<FILE, FileCloser>;

// ---- ICC 수집: marker_list에서 ICC_PROFILE 세그먼트 재조립
static bool JPEG_ReadICCProfile(j_decompress_ptr dinfo, std::vector<uint8_t>& outICC)
{
    static const char ICC_SIG[] = "ICC_PROFILE\0"; // 12 bytes
    struct Part { int seq=0; std::vector<uint8_t> buf; };
    std::vector<Part> parts;
    int count = -1;

    for (jpeg_saved_marker_ptr m = dinfo->marker_list; m; m = m->next) {
        if (m->marker != (JPEG_APP0 + 2)) continue; // APP2
        if (m->data_length < 14) continue;          // 12+2 최소
        if (std::memcmp(m->data, ICC_SIG, 12) != 0) continue;

        int seq_no = m->data[12];
        int total  = m->data[13];
        if (seq_no < 1 || total < 1) continue;

        if (count == -1) count = total;
        if (count != total) continue; // 불일치: 보수적으로 skip

        Part p; p.seq = seq_no;
        p.buf.assign(m->data + 14, m->data + m->data_length);
        parts.emplace_back(std::move(p));
    }

    if (parts.empty()) return false;
    // 순서대로 정렬 & 연속성 검사
    std::sort(parts.begin(), parts.end(), [](const Part& a, const Part& b){return a.seq < b.seq;});
    if (count != (int)parts.size()) return false;
    for (int i=0;i<count;++i) if (parts[i].seq != i+1) return false;

    // 이어붙이기
    size_t totalBytes=0; for (auto& p: parts) totalBytes += p.buf.size();
    outICC.resize(totalBytes);
    size_t off=0;
    for (auto& p: parts) { std::memcpy(outICC.data()+off, p.buf.data(), p.buf.size()); off += p.buf.size(); }
    return true;
}

// ---- ICC 쓰기: cinfo에 sRGB/입력 ICC를 APP2로 분할 부착
static void JPEG_WriteICCProfile(j_compress_ptr cinfo, const std::vector<uint8_t>& icc)
{
    static const char ICC_SIG[] = "ICC_PROFILE\0"; // 12 bytes
    const size_t OVERHEAD = 14;                    // 12+2
    // IJG 샘플과 동일한 여유치: 65519 = 65533(최대길이) - 2(len) - 12(ICC_SIG)
    const size_t MAX_PAYLOAD = 65519;
    if (icc.empty()) return;

    int numParts = (int)((icc.size() + MAX_PAYLOAD - 1) / MAX_PAYLOAD);
    for (int i=0;i<numParts;++i) {
        size_t off = (size_t)i * MAX_PAYLOAD;
        size_t len = std::min(MAX_PAYLOAD, icc.size() - off);

        std::vector<JOCTET> seg;
        seg.resize(OVERHEAD + len);
        std::memcpy(seg.data(), ICC_SIG, 12);
        seg[12] = (JOCTET)(i+1);      // seq no
        seg[13] = (JOCTET)(numParts); // total
        std::memcpy(seg.data()+OVERHEAD, icc.data()+off, len);

        jpeg_write_marker(cinfo, (JOCTET)(JPEG_APP0+2), seg.data(), (unsigned int)seg.size());
    }
}
```

---

## 코드: **lcms2 변환**(임베디드 ICC → sRGB)

- 입력 이미지(8bpc RGB)와 **임베디드 ICC**가 있으면 **픽셀을 sRGB로 변환**합니다.
- 임베디드 ICC가 **없으면 변환 생략**(sRGB 가정).
- 변환 후 저장 시에는 **sRGB ICC를 부착**(토글 ON일 때).

```cpp
#include <lcms2.h>

// 8bpc RGB 버퍼를 ICC(inICC) → sRGB로 변환
// inICC.size()==0 이면 "이미 sRGB"로 간주하고 바로 true 반환(변환 생략)
bool ConvertICCToSRGB_8u(std::vector<uint8_t>& rgb, int w, int h, int strideBytes,
                         const std::vector<uint8_t>& inICC,
                         std::vector<uint8_t>& outSRGB_ProfileBlob /*결과로 부착할 sRGB ICC*/)
{
    // sRGB 프로파일 핸들(출력)
    cmsHPROFILE hsRGB = cmsCreate_sRGBProfile();
    if (!hsRGB) return false;

    // sRGB 프로파일을 바이너리로 직렬화(저장 시 부착)
    // (한 번만 만들어 캐시해도 좋음)
    cmsUInt32Number bytesNeeded = 0;
    cmsSaveProfileToMem(hsRGB, nullptr, &bytesNeeded);
    outSRGB_ProfileBlob.resize(bytesNeeded);
    if (!cmsSaveProfileToMem(hsRGB, outSRGB_ProfileBlob.data(), &bytesNeeded)) {
        cmsCloseProfile(hsRGB);
        return false;
    }

    // 입력 ICC가 없으면 "sRGB로 간주" → 변환 생략
    if (inICC.empty()) {
        cmsCloseProfile(hsRGB);
        return true;
    }

    cmsHPROFILE hIn = cmsOpenProfileFromMem(inICC.data(), (cmsUInt32Number)inICC.size());
    if (!hIn) { cmsCloseProfile(hsRGB); return false; }

    // Intent/BPC/플래그 정책: 일반적 권장값
    int intent = INTENT_PERCEPTUAL;
    cmsUInt32Number flags = cmsFLAGS_BLACKPOINTCOMPENSATION;

    cmsHTRANSFORM xform = cmsCreateTransform(hIn, TYPE_RGB_8, hsRGB, TYPE_RGB_8, intent, flags);
    if (!xform) { cmsCloseProfile(hIn); cmsCloseProfile(hsRGB); return false; }

    // in-place 변환: 행 단위로 안전하게 처리
    for (int y=0; y<h; ++y) {
        uint8_t* row = rgb.data() + (size_t)strideBytes*y;
        cmsDoTransform(xform, row, row, (cmsUInt32Number)w);
    }

    cmsDeleteTransform(xform);
    cmsCloseProfile(hIn);
    cmsCloseProfile(hsRGB);
    return true;
}
```

---

## sRGB로 변환 → 메타 보존 저장**

- EXIF/XMP 등은 APP1, ICC는 APP2에서 **그대로 재부착**합니다.
- “sRGB 강제 변환하여 저장” 켜짐이면:
  - ICC가 있든 없든, 결과물에는 **sRGB ICC를 부착**합니다(없던 경우에도 명시 태깅).
  - ICC가 있었던 경우 픽셀은 **실제로 sRGB로 변환**됩니다.

```cpp
#include <jpeglib.h>
#include <vector>
#include <string>
#include <cstdint>
#include <memory>
#include <stdexcept>
#include <cstring>
#include <algorithm>

// ---- 간단 RGB 컨테이너
struct ImageRGB {
    int w=0, h=0, stride=0; // stride = w*3
    std::vector<uint8_t> data;
};

// ---- APP 마커 유틸(ICC 제외 전부 보존용)
struct AppMarker { int marker=0; std::vector<uint8_t> data; };
using AppMarkers = std::vector<AppMarker>;

static void CollectNonICCMarkers(j_decompress_ptr dinfo, AppMarkers& out)
{
    for (jpeg_saved_marker_ptr m = dinfo->marker_list; m; m = m->next) {
        if (m->marker == (JPEG_APP0+2)) continue; // ICC는 별도 처리
        // EXIF(APP1), XMP(APP1) 등은 전부 보존
        out.push_back({m->marker, std::vector<uint8_t>(m->data, m->data + m->data_length)});
    }
}

static void WriteMarkers(j_compress_ptr cinfo, const AppMarkers& markers)
{
    for (auto& a : markers) {
        if (!a.data.empty())
            jpeg_write_marker(cinfo, (JOCTET)a.marker, (const JOCTET*)a.data.data(), (unsigned int)a.data.size());
    }
}

// ---- 메인: JPEG → (옵션) sRGB 강제 변환 → 저장
bool Jpeg_Reencode_WithICCPolicy(const std::string& inPath, const std::string& outPath,
                                 bool forceSRGB /*토글: 강제 sRGB 변환하여 저장*/)
{
    // 1) 열기 + 마커 저장
    FilePtr in(fopen(inPath.c_str(), "rb"));
    if (!in) throw std::runtime_error("open input failed");

    jpeg_decompress_struct dinfo{}; jpeg_error_mgr jerr{};
    dinfo.err = jpeg_std_error(&jerr); jpeg_create_decompress(&dinfo);
    jpeg_stdio_src(&dinfo, in.get());

    // APP1/APP2 저장
    jpeg_save_markers(&dinfo, JPEG_APP0+1, 0xFFFF); // EXIF/XMP
    jpeg_save_markers(&dinfo, JPEG_APP0+2, 0xFFFF); // ICC
    if (jpeg_read_header(&dinfo, TRUE) != JPEG_HEADER_OK)
        { jpeg_destroy_decompress(&dinfo); throw std::runtime_error("bad jpeg header"); }

    // 2) 메타 수집
    AppMarkers keepMarkers; CollectNonICCMarkers(&dinfo, keepMarkers);
    std::vector<uint8_t> iccIn; JPEG_ReadICCProfile(&dinfo, iccIn);

    // 3) 디코드 → RGB
    dinfo.out_color_space = JCS_RGB;
    jpeg_start_decompress(&dinfo);
    ImageRGB img; img.w = dinfo.output_width; img.h = dinfo.output_height; img.stride = img.w*3;
    img.data.resize((size_t)img.h * img.stride);
    while (dinfo.output_scanline < dinfo.output_height) {
        JSAMPROW rowptr = (JSAMPROW)(img.data.data() + (size_t)img.stride * dinfo.output_scanline);
        jpeg_read_scanlines(&dinfo, &rowptr, 1);
    }
    jpeg_finish_decompress(&dinfo);
    jpeg_destroy_decompress(&dinfo);
    in.reset();

    // 4) (옵션) sRGB 강제 변환
    std::vector<uint8_t> sRGBProfileBlob; // 토글 ON일 때 출력에 부착
    if (forceSRGB) {
        // 임베디드 ICC가 있으면: 실제 변환 → sRGB
        // 없으면: 변환 생략(이미 sRGB 가정), 단 sRGB 프로파일 Blob만 생성
        if (!ConvertICCToSRGB_8u(img.data, img.w, img.h, img.stride, iccIn, sRGBProfileBlob))
            throw std::runtime_error("icc->srgb convert failed");
    }

    // 5) 저장(메타 보존 + ICC 정책)
    FilePtr out(fopen(outPath.c_str(), "wb"));
    if (!out) throw std::runtime_error("open output failed");

    jpeg_compress_struct cinfo{}; jpeg_error_mgr jerr2{};
    cinfo.err = jpeg_std_error(&jerr2); jpeg_create_compress(&cinfo);
    jpeg_stdio_dest(&cinfo, out.get());

    cinfo.image_width  = img.w;
    cinfo.image_height = img.h;
    cinfo.input_components = 3;
    cinfo.in_color_space = JCS_RGB;
    jpeg_set_defaults(&cinfo);
    cinfo.optimize_coding = TRUE;
    jpeg_set_quality(&cinfo, 90, TRUE);

    jpeg_start_compress(&cinfo, TRUE);

    // 5-1) ICC 정책 적용
    //  - 토글 OFF: 입력 ICC 그대로(있으면) 부착
    //  - 토글 ON : sRGB ICC 부착(입력 ICC 무시)
    if (forceSRGB) {
        JPEG_WriteICCProfile(&cinfo, sRGBProfileBlob);
    } else {
        if (!iccIn.empty())
            JPEG_WriteICCProfile(&cinfo, iccIn);
    }

    // 5-2) EXIF/XMP 등 나머지 메타 재부착
    WriteMarkers(&cinfo, keepMarkers);

    // 5-3) 픽셀 쓰기
    while (cinfo.next_scanline < cinfo.image_height) {
        JSAMPROW rowptr = (JSAMPROW)(img.data.data() + (size_t)img.stride * cinfo.next_scanline);
        jpeg_write_scanlines(&cinfo, &rowptr, 1);
    }

    jpeg_finish_compress(&cinfo);
    jpeg_destroy_compress(&cinfo);
    out.reset();

    return true;
}
```

---

## UI/옵션 통합(예: ImageTool/MFC)

- 환경설정에 체크박스: **[ ] sRGB로 강제 변환하여 저장**
- 저장 메뉴/다이얼로그에서 체크값을 읽어 `forceSRGB` 인자로 전달
- **EXIF Orientation 패치**(앞선 섹션)와 **동시에** 적용해도 무방
  - 순서 권장: **Orientation → ICC 변환 → 저장(메타 부착)**

---

## 테스트 시나리오

1) **Display P3 ICC 포함 JPEG**
   - 토글 OFF: 파일 크기/색 변화 없음, ICC=Display P3 유지
   - 토글 ON : 픽셀이 **sRGB로 변환**, ICC=**sRGB** 부착 → 비색관리 뷰어에서도 색상 과포화 감소
   검증:
   ```bash
   exiftool -icc_profile:profiledescription -colorSpace -a -G out.jpg
   ```
2) **ICC 없는 JPEG/PNG**
   - 토글 OFF: ICC 없음 → sRGB 가정
   - 토글 ON : 픽셀 동일, **sRGB ICC 부착** → 색 관리 뷰어에서 명시적 sRGB로 해석
3) **성능 회귀**
   - 대량 변환 시 **변환 시간(ms)/바이트** 로깅(파일명, 해상도, 변환 여부, 인코드 ms)

---

## 주의·팁

- **8bpc 정밀도**: 광색역(예: P3) → sRGB 축소 시, 하이라이트 클리핑이 드물게 보일 수 있습니다. 필요하면 lcms2에서 **16bpc 버퍼**(TYPE_RGB_16) 경로로 변환 후 8bpc로 내리세요.
- **Intent**: 사진은 `INTENT_PERCEPTUAL`, 로고/브랜드 컬러는 `RELATIVE_COLORIMETRIC+BPC` 선호 사례 많음.
- **태깅만(sRGB ICC 부착만) 하지 말 것**: 원본이 P3/AdobeRGB인데 픽셀 변환 없이 sRGB로 **잘못 태깅**하면 색상이 틀어집니다. 본 문서의 토글 ON은 **반드시 변환 + 태깅**을 의미합니다.
- **메타 크기**: 매우 큰 ICC(수백 KB)는 APP2가 여러 조각으로 분할됩니다. 위의 분할/재조립 로직은 그에 대응합니다.
- **다중 APP1**: EXIF와 XMP가 함께 있을 수 있습니다. 본 코드는 모두 보존합니다(Strip 정책은 별도 옵션으로).
- **CMYK JPEG**: CMYK/YPbPr 등 비-RGB 입력은 디코더에서 RGB로 풀리지만, 색차가 생길 수 있습니다. CMYK ICC→sRGB 변환이 꼭 필요하며, `JCS_CMYK` 디코드/별도 경로를 운영하는 편이 안전합니다.

---

## 요약

- JPEG을 열며 ICC(있으면 보존, 없으면 sRGB 가정)를 **정확히 감지**하고,
- “**sRGB 강제 변환하여 저장**”을 켜면 **픽셀 변환 + sRGB ICC 부착**으로 **색 일관성**을 확보합니다.
- 위 C++ 예제(ICC 수집/쓰기 + lcms2 변환)를 ImageTool 파이프라인에 그대로 연결하면,
  **웹/앱/문서 전용 자산의 색상 혼선**을 구조적으로 줄일 수 있습니다.
