---
layout: post
title: 파이썬 심화 - 데이터 인코딩과 프로세싱 (2)
date: 2025-11-28 22:25:23 +0900
category: 파이썬 심화
---
# 데이터 인코딩과 프로세싱 (2)

## 관계형 데이터베이스 작업

### SQLite를 이용한 데이터베이스 기본 작업
```python
import sqlite3
import datetime
from contextlib import closing

def basic_sqlite_operations():
    """SQLite 기본 데이터베이스 작업"""
    
    # 데이터베이스 연결 (파일이 없으면 새로 생성)
    conn = sqlite3.connect('example.db')
    
    # 커서 생성
    cursor = conn.cursor()
    
    # 테이블 생성
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT NOT NULL UNIQUE,
        email TEXT NOT NULL UNIQUE,
        age INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        is_active BOOLEAN DEFAULT 1
    )
    ''')
    
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS orders (
        order_id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER,
        product_name TEXT NOT NULL,
        amount REAL NOT NULL,
        order_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users (id)
    )
    ''')
    
    print("데이터베이스 테이블 생성 완료")
    
    # 데이터 삽입 (여러 방법)
    # 1. 기본 삽입
    cursor.execute(
        "INSERT INTO users (username, email, age) VALUES (?, ?, ?)",
        ('김철수', 'kim@example.com', 30)
    )
    
    # 2. 여러 레코드 한 번에 삽입
    users_data = [
        ('이영희', 'lee@example.com', 25),
        ('박민수', 'park@example.com', 35),
        ('최지우', 'choi@example.com', 28)
    ]
    
    cursor.executemany(
        "INSERT INTO users (username, email, age) VALUES (?, ?, ?)",
        users_data
    )
    
    # 주문 데이터 삽입
    orders_data = [
        (1, '노트북', 1200000),
        (1, '마우스', 35000),
        (2, '키보드', 85000),
        (3, '모니터', 500000),
        (4, '헤드셋', 120000)
    ]
    
    cursor.executemany(
        "INSERT INTO orders (user_id, product_name, amount) VALUES (?, ?, ?)",
        orders_data
    )
    
    conn.commit()
    print(f"데이터 삽입 완료: {len(users_data) + 1}명 사용자, {len(orders_data)}개 주문")
    
    # 데이터 조회
    print("\n1. 전체 사용자 조회:")
    cursor.execute("SELECT * FROM users")
    users = cursor.fetchall()
    
    for user in users:
        print(f"  ID: {user[0]}, 이름: {user[1]}, 이메일: {user[2]}, 나이: {user[3]}")
    
    # 조건부 조회
    print("\n2. 30세 이상 사용자 조회:")
    cursor.execute("SELECT username, email, age FROM users WHERE age >= ?", (30,))
    senior_users = cursor.fetchall()
    
    for user in senior_users:
        print(f"  {user[0]} ({user[1]}) - {user[2]}세")
    
    # JOIN 조회
    print("\n3. 사용자별 주문 내역 조회 (JOIN):")
    cursor.execute('''
    SELECT u.username, o.product_name, o.amount, o.order_date
    FROM users u
    JOIN orders o ON u.id = o.user_id
    ORDER BY u.username, o.order_date
    ''')
    
    orders = cursor.fetchall()
    for order in orders:
        print(f"  {order[0]} - {order[1]}: {order[2]:,}원 ({order[3]})")
    
    # 집계 함수
    print("\n4. 통계 정보:")
    
    # 총 사용자 수
    cursor.execute("SELECT COUNT(*) FROM users")
    total_users = cursor.fetchone()[0]
    print(f"  총 사용자 수: {total_users}명")
    
    # 평균 나이
    cursor.execute("SELECT AVG(age) FROM users")
    avg_age = cursor.fetchone()[0]
    print(f"  평균 나이: {avg_age:.1f}세")
    
    # 총 주문 금액
    cursor.execute("SELECT SUM(amount) FROM orders")
    total_sales = cursor.fetchone()[0]
    print(f"  총 주문 금액: {total_sales:,.0f}원")
    
    # 그룹별 통계
    print("\n5. 사용자별 주문 통계:")
    cursor.execute('''
    SELECT u.username, COUNT(o.order_id) as order_count, SUM(o.amount) as total_amount
    FROM users u
    LEFT JOIN orders o ON u.id = o.user_id
    GROUP BY u.id
    ORDER BY total_amount DESC
    ''')
    
    user_stats = cursor.fetchall()
    for stat in user_stats:
        orders = stat[1] if stat[1] else 0
        total = stat[2] if stat[2] else 0
        print(f"  {stat[0]}: {orders}개 주문, {total:,.0f}원")
    
    # 데이터 수정
    print("\n6. 데이터 수정:")
    cursor.execute("UPDATE users SET age = ? WHERE username = ?", (31, '김철수'))
    conn.commit()
    print("  김철수 나이를 30세에서 31세로 수정")
    
    # 데이터 삭제
    cursor.execute("DELETE FROM users WHERE username = ?", ('최지우',))
    conn.commit()
    print("  최지우 사용자 삭제")
    
    # 트랜잭션 처리
    print("\n7. 트랜잭션 처리 예제:")
    try:
        cursor.execute("BEGIN TRANSACTION")
        
        # 여러 작업 수행
        cursor.execute("INSERT INTO users (username, email, age) VALUES (?, ?, ?)",
                      ('신규사용자', 'new@example.com', 27))
        
        cursor.execute("UPDATE users SET is_active = 0 WHERE age > ?", (40,))
        
        # 의도적 오류 발생 (존재하지 않는 사용자)
        # cursor.execute("INSERT INTO orders (user_id, product_name, amount) VALUES (?, ?, ?)",
        #               (999, '테스트상품', 10000))
        
        conn.commit()
        print("  트랜잭션 커밋 성공")
        
    except sqlite3.Error as e:
        conn.rollback()
        print(f"  트랜잭션 롤백: {e}")
    
    # 데이터베이스 연결 종료
    conn.close()

basic_sqlite_operations()

### 고급 SQLite 기능과 데이터베이스 설계
```python
def advanced_sqlite_features():
    """SQLite 고급 기능"""
    
    print("\n" + "="*60)
    print("SQLite 고급 기능")
    print("="*60)
    
    # 메모리 데이터베이스 (임시 데이터베이스)
    conn = sqlite3.connect(':memory:')
    cursor = conn.cursor()
    
    # 복잡한 테이블 구조
    cursor.execute('''
    CREATE TABLE products (
        product_id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL,
        category TEXT NOT NULL,
        price REAL NOT NULL CHECK (price >= 0),
        stock INTEGER DEFAULT 0 CHECK (stock >= 0),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    )
    ''')
    
    # 인덱스 생성
    cursor.execute('CREATE INDEX idx_category ON products (category)')
    cursor.execute('CREATE INDEX idx_price ON products (price)')
    
    # 트리거 생성 (updated_at 자동 업데이트)
    cursor.execute('''
    CREATE TRIGGER update_timestamp 
    AFTER UPDATE ON products 
    BEGIN
        UPDATE products SET updated_at = CURRENT_TIMESTAMP 
        WHERE product_id = NEW.product_id;
    END;
    ''')
    
    # 제품 데이터 삽입
    products = [
        ('맥북 프로', '전자제품', 2500000, 10),
        ('아이폰 15', '전자제품', 1300000, 25),
        ('의자', '가구', 150000, 50),
        ('책상', '가구', 300000, 30),
        ('커피머신', '주방가전', 500000, 15),
        ('공기청정기', '생활가전', 700000, 20)
    ]
    
    cursor.executemany(
        "INSERT INTO products (name, category, price, stock) VALUES (?, ?, ?, ?)",
        products
    )
    
    conn.commit()
    
    # 창 함수 (Window Functions) - SQLite 3.25.0 이상
    print("\n1. 창 함수를 이용한 순위 매기기:")
    
    try:
        cursor.execute('''
        SELECT 
            name,
            category,
            price,
            ROW_NUMBER() OVER (PARTITION BY category ORDER BY price DESC) as rank_in_category,
            AVG(price) OVER (PARTITION BY category) as avg_category_price
        FROM products
        ORDER BY category, price DESC
        ''')
        
        ranked_products = cursor.fetchall()
        for product in ranked_products:
            print(f"  {product[0]} ({product[1]}) - {product[2]:,}원")
            print(f"    카테고리 내 순위: {product[3]}위, 카테고리 평균: {product[4]:,.0f}원\n")
            
    except sqlite3.OperationalError:
        print("  현재 SQLite 버전에서 창 함수를 지원하지 않습니다.")
    
    # 공통 테이블 표현식 (CTE)
    print("\n2. CTE(Common Table Expression) 사용:")
    
    cursor.execute('''
    WITH category_stats AS (
        SELECT 
            category,
            COUNT(*) as product_count,
            AVG(price) as avg_price,
            SUM(stock) as total_stock
        FROM products
        GROUP BY category
    ),
    high_value_products AS (
        SELECT *
        FROM products
        WHERE price > (SELECT AVG(price) FROM products)
    )
    SELECT 
        cs.category,
        cs.product_count,
        cs.avg_price,
        cs.total_stock,
        (SELECT COUNT(*) FROM high_value_products hvp 
         WHERE hvp.category = cs.category) as high_value_count
    FROM category_stats cs
    ORDER BY cs.avg_price DESC
    ''')
    
    category_analysis = cursor.fetchall()
    for analysis in category_analysis:
        print(f"  카테고리: {analysis[0]}")
        print(f"    제품 수: {analysis[1]}개")
        print(f"    평균 가격: {analysis[2]:,.0f}원")
        print(f"    총 재고: {analysis[3]}개")
        print(f"    고가 제품 수: {analysis[4]}개\n")
    
    # JSON 지원 (SQLite 3.38.0 이상)
    print("\n3. JSON 데이터 처리:")
    
    # JSON 데이터 저장 테이블
    cursor.execute('''
    CREATE TABLE IF NOT EXISTS json_data (
        id INTEGER PRIMARY KEY,
        data JSON,
        tags TEXT
    )
    ''')
    
    # JSON 데이터 삽입
    import json
    
    json_records = [
        (1, json.dumps({
            'name': '김철수',
            'age': 30,
            'skills': ['Python', 'SQL', 'Django'],
            'address': {'city': '서울', 'zipcode': '12345'}
        }, ensure_ascii=False), '개발자,파이썬'),
        
        (2, json.dumps({
            'name': '이영희',
            'age': 25,
            'skills': ['Design', 'Figma', 'Photoshop'],
            'address': {'city': '부산', 'zipcode': '54321'}
        }, ensure_ascii=False), '디자이너,UI/UX')
    ]
    
    cursor.executemany(
        "INSERT OR REPLACE INTO json_data (id, data, tags) VALUES (?, ?, ?)",
        json_records
    )
    
    # JSON 함수 사용
    try:
        cursor.execute('''
        SELECT 
            json_extract(data, '$.name') as name,
            json_extract(data, '$.age') as age,
            json_extract(data, '$.address.city') as city,
            json_array_length(json_extract(data, '$.skills')) as skill_count
        FROM json_data
        ''')
        
        json_results = cursor.fetchall()
        for result in json_results:
            print(f"  {result[0]} ({result[1]}세, {result[2]}) - {result[3]}개 기술")
            
    except sqlite3.OperationalError:
        print("  현재 SQLite 버전에서 JSON 함수를 지원하지 않습니다.")
    
    # 데이터베이스 백업
    print("\n4. 데이터베이스 백업:")
    
    backup_conn = sqlite3.connect('backup.db')
    with backup_conn:
        conn.backup(backup_conn)
    backup_conn.close()
    
    print("  데이터베이스 백업 완료: backup.db")
    
    # 데이터베이스 정보 조회
    print("\n5. 데이터베이스 메타정보:")
    
    # 테이블 목록
    cursor.execute("SELECT name FROM sqlite_master WHERE type='table'")
    tables = cursor.fetchall()
    print(f"  테이블 목록: {[table[0] for table in tables]}")
    
    # 각 테이블의 스키마
    for table in tables:
        table_name = table[0]
        cursor.execute(f"PRAGMA table_info({table_name})")
        columns = cursor.fetchall()
        print(f"\n  테이블: {table_name}")
        for col in columns:
            print(f"    컬럼: {col[1]} ({col[2]})")
    
    conn.close()

advanced_sqlite_features()

### PostgreSQL 연동 (실제 환경)
def postgresql_integration():
    """PostgreSQL 데이터베이스 연동"""
    
    print("\n" + "="*60)
    print("PostgreSQL 연동 (개념 설명)")
    print("="*60)
    
    # 실제 사용을 위한 패턴 (psycopg2가 설치되어 있어야 함)
    postgresql_code = '''
import psycopg2
from psycopg2 import pool
from contextlib import contextmanager

# 연결 풀 생성
connection_pool = psycopg2.pool.SimpleConnectionPool(
    minconn=1,
    maxconn=10,
    host='localhost',
    database='mydatabase',
    user='myuser',
    password='mypassword',
    port=5432
)

@contextmanager
def get_connection():
    """컨텍스트 매니저를 이용한 연결 관리"""
    conn = connection_pool.getconn()
    try:
        yield conn
    finally:
        connection_pool.putconn(conn)

@contextmanager
def get_cursor():
    """커서 자동 관리"""
    with get_connection() as conn:
        cursor = conn.cursor()
        try:
            yield cursor
            conn.commit()
        except Exception as e:
            conn.rollback()
            raise e
        finally:
            cursor.close()

# 사용 예제
with get_cursor() as cur:
    # 복잡한 쿼리 실행
    cur.execute('''
        SELECT u.username, COUNT(o.id) as order_count
        FROM users u
        LEFT JOIN orders o ON u.id = o.user_id
        WHERE u.created_at > %s
        GROUP BY u.id
        HAVING COUNT(o.id) > %s
        ORDER BY order_count DESC
    ''', ('2024-01-01', 0))
    
    results = cur.fetchall()
    for row in results:
        print(f"{row[0]}: {row[1]} orders")
    '''
    
    print("PostgreSQL 연동 패턴:")
    print("1. 연결 풀을 사용하여 연결 관리 최적화")
    print("2. 컨텍스트 매니저를 이용한 자원 관리")
    print("3. 매개변수화된 쿼리로 SQL 인젝션 방지")
    print("4. 트랜잭션 자동 관리")
    print("\n주의: 실제 사용 시 psycopg2 패키지 설치 필요")
    print("      pip install psycopg2-binary")

postgresql_integration()
```

## 16진수 인코딩과 디코딩

### 16진수 데이터 처리
```python
def hex_encoding_decoding():
    """16진수 인코딩과 디코딩"""
    
    print("\n" + "="*60)
    print("16진수 인코딩과 디코딩")
    print("="*60)
    
    # 1. 기본 16진수 변환
    print("1. 기본 16진수 변환:")
    
    data = b"Hello Hex!"
    hex_encoded = data.hex()
    print(f"  원본 데이터: {data}")
    print(f"  16진수 인코딩: {hex_encoded}")
    
    # 16진수 디코딩
    decoded = bytes.fromhex(hex_encoded)
    print(f"  디코딩된 데이터: {decoded}")
    print(f"  원본과 일치?: {data == decoded}")
    
    # 2. 다양한 데이터 타입의 16진수 변환
    print("\n2. 다양한 데이터 타입의 16진수 변환:")
    
    # 정수 → 16진수
    numbers = [255, 4096, 65535, 16777215]
    for num in numbers:
        hex_str = hex(num)
        hex_bytes = num.to_bytes((num.bit_length() + 7) // 8, 'big').hex()
        print(f"  {num:10,d} → hex(): {hex_str:>10} | bytes.hex(): {hex_bytes}")
    
    # 3. 유니코드 문자열의 16진수 표현
    print("\n3. 유니코드 문자열 16진수 변환:")
    
    korean_text = "안녕하세요 Hello 123"
    utf8_bytes = korean_text.encode('utf-8')
    hex_representation = utf8_bytes.hex()
    
    print(f"  원본 문자열: {korean_text}")
    print(f"  UTF-8 바이트: {utf8_bytes}")
    print(f"  16진수 표현: {hex_representation}")
    
    # 4. 16진수 문자열 포맷팅
    print("\n4. 16진수 문자열 포맷팅:")
    
    data = b"\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
    
    # 간단한 16진수 덤프
    print(f"  간단한 덤프: {data.hex()}")
    
    # 보기 좋은 16진수 덤프 (16바이트씩)
    print(f"  포맷팅된 덤프:")
    
    def hex_dump(data, bytes_per_line=16):
        """16진수 덤프 출력"""
        for i in range(0, len(data), bytes_per_line):
            chunk = data[i:i + bytes_per_line]
            
            # 16진수 부분
            hex_part = ' '.join(f'{b:02x}' for b in chunk)
            hex_part = hex_part.ljust(bytes_per_line * 3 - 1)
            
            # ASCII 부분
            ascii_part = ''.join(chr(b) if 32 <= b < 127 else '.' for b in chunk)
            
            # 오프셋
            offset = f'{i:08x}'
            
            print(f"    {offset}: {hex_part}  |{ascii_part}|")
    
    hex_dump(data)
    
    # 5. 대용량 파일의 16진수 덤프
    print("\n5. 파일의 16진수 덤프 (처음 256바이트):")
    
    # 샘플 파일 생성
    sample_data = bytes(range(256)) * 2  # 0-255 패턴 반복
    with open('sample.bin', 'wb') as f:
        f.write(sample_data)
    
    # 파일의 처음 256바이트 덤프
    with open('sample.bin', 'rb') as f:
        first_256 = f.read(256)
        hex_dump(first_256)
    
    # 6. 16진수 패턴 검색
    print("\n6. 16진수 패턴 검색:")
    
    # 특정 패턴 찾기
    pattern = b'\x00\x01\x02\x03'
    hex_pattern = pattern.hex()
    
    with open('sample.bin', 'rb') as f:
        content = f.read()
        
        # 패턴 위치 찾기
        positions = []
        search_index = 0
        
        while True:
            pos = content.find(pattern, search_index)
            if pos == -1:
                break
            positions.append(pos)
            search_index = pos + 1
        
        print(f"  패턴 '{hex_pattern}' 발견 위치: {positions[:5]}...")
        print(f"  총 발견 횟수: {len(positions)}")
    
    # 7. 16진수 데이터 조작
    print("\n7. 16진수 데이터 조작:")
    
    # 16진수 문자열 수정
    hex_data = '48656c6c6f20576f726c64'  # "Hello World"
    print(f"  원본 16진수: {hex_data}")
    
    # 특정 위치의 바이트 변경
    hex_list = list(hex_data)
    
    # 'W' (57) → 'w' (77)로 변경
    # 'World'에서 'W'는 12번째 문자 (6*2=12 인덱스)
    hex_list[12] = '7'
    hex_list[13] = '7'
    
    modified_hex = ''.join(hex_list)
    modified_data = bytes.fromhex(modified_hex)
    
    print(f"  수정된 16진수: {modified_hex}")
    print(f"  수정된 데이터: {modified_data}")
    
    # 8. CRC 검사 코드 계산 (16진수 활용)
    print("\n8. CRC 검사 코드 계산:")
    
    import binascii
    
    test_data = b"Test data for CRC"
    crc32_value = binascii.crc32(test_data)
    
    print(f"  테스트 데이터: {test_data}")
    print(f"  CRC32 값 (10진수): {crc32_value}")
    print(f"  CRC32 값 (16진수): {crc32_value:08x}")
    
    # 9. 커스텀 16진수 인코딩/디코딩 함수
    print("\n9. 커스텀 16진수 유틸리티:")
    
    class HexUtils:
        @staticmethod
        def hex_encode(data, separator=''):
            """데이터를 16진수 문자열로 인코딩"""
            if isinstance(data, str):
                data = data.encode('utf-8')
            hex_str = data.hex()
            
            if separator:
                # 구분자 추가 (예: ':' 또는 ' ')
                return separator.join(hex_str[i:i+2] for i in range(0, len(hex_str), 2))
            return hex_str
        
        @staticmethod
        def hex_decode(hex_str, separator=''):
            """16진수 문자열을 데이터로 디코딩"""
            if separator:
                # 구분자 제거
                hex_str = hex_str.replace(separator, '')
            return bytes.fromhex(hex_str)
        
        @staticmethod
        def hex_diff(hex1, hex2):
            """두 16진수 문자열 비교"""
            if len(hex1) != len(hex2):
                return "길이가 다릅니다"
            
            differences = []
            for i in range(0, len(hex1), 2):
                byte1 = hex1[i:i+2]
                byte2 = hex2[i:i+2]
                if byte1 != byte2:
                    differences.append(f"위치 {i//2}: {byte1} ≠ {byte2}")
            
            return differences if differences else ["동일함"]
    
    # 사용 예제
    utils = HexUtils()
    
    test_str = "테스트"
    encoded = utils.hex_encode(test_str, ':')
    decoded = utils.hex_decode(encoded, ':')
    
    print(f"  원본 문자열: {test_str}")
    print(f"  인코딩 (구분자 ':'): {encoded}")
    print(f"  디코딩 결과: {decoded.decode('utf-8')}")

hex_encoding_decoding()
```

## Base64 인코딩과 디코딩

### 다양한 Base64 변환
```python
import base64
import io

def base64_encoding_decoding():
    """Base64 인코딩과 디코딩"""
    
    print("\n" + "="*60)
    print("Base64 인코딩과 디코딩")
    print("="*60)
    
    # 1. 기본 Base64 인코딩/디코딩
    print("1. 기본 Base64 변환:")
    
    original_text = "Hello Base64! 안녕하세요!"
    print(f"  원본 텍스트: {original_text}")
    
    # 인코딩
    encoded_bytes = base64.b64encode(original_text.encode('utf-8'))
    encoded_text = encoded_bytes.decode('ascii')
    print(f"  Base64 인코딩: {encoded_text}")
    
    # 디코딩
    decoded_bytes = base64.b64decode(encoded_text)
    decoded_text = decoded_bytes.decode('utf-8')
    print(f"  Base64 디코딩: {decoded_text}")
    print(f"  원본과 일치?: {original_text == decoded_text}")
    
    # 2. 다양한 Base64 변종
    print("\n2. Base64 변종들:")
    
    test_data = b"Hello\nWorld\r\nTest Data\x00\x01"
    
    # Standard Base64
    std_base64 = base64.b64encode(test_data).decode('ascii')
    print(f"  Standard Base64: {std_base64[:30]}...")
    
    # URL-safe Base64 (+와 / 대신 -와 _ 사용)
    url_safe = base64.urlsafe_b64encode(test_data).decode('ascii')
    print(f"  URL-safe Base64: {url_safe[:30]}...")
    
    # Base32 인코딩
    base32_encoded = base64.b32encode(test_data).decode('ascii')
    print(f"  Base32 인코딩: {base32_encoded[:30]}...")
    
    # Base16 (16진수) 인코딩
    base16_encoded = base64.b16encode(test_data).decode('ascii')
    print(f"  Base16 인코딩: {base16_encoded[:30]}...")
    
    # 3. 파일을 Base64로 인코딩
    print("\n3. 파일 Base64 인코딩:")
    
    # 샘플 파일 생성
    sample_content = '''이것은 테스트 파일입니다.
여러 줄의 텍스트를 포함하고 있습니다.
Base64 인코딩을 테스트합니다.'''
    
    with open('sample.txt', 'w', encoding='utf-8') as f:
        f.write(sample_content)
    
    # 파일 읽고 Base64 인코딩
    with open('sample.txt', 'rb') as f:
        file_data = f.read()
        file_base64 = base64.b64encode(file_data).decode('ascii')
    
    print(f"  파일 크기: {len(file_data)} 바이트")
    print(f"  Base64 인코딩 크기: {len(file_base64)} 문자")
    print(f"  인코딩 오버헤드: {(len(file_base64)/len(file_data) - 1)*100:.1f}%")
    
    # Base64 문자열을 다시 파일로
    decoded_file_data = base64.b64decode(file_base64)
    with open('sample_decoded.txt', 'wb') as f:
        f.write(decoded_file_data)
    
    print("  Base64 디코딩 파일 생성: sample_decoded.txt")
    
    # 4. 이미지 파일 Base64 인코딩
    print("\n4. 이미지 데이터 Base64 인코딩:")
    
    # 간단한 BMP 이미지 생성 (24x24 픽셀, 3바이트 RGB)
    def create_simple_bmp():
        """간단한 BMP 이미지 생성"""
        # BMP 헤더 (14바이트)
        file_header = b'BM'  # 시그니처
        file_size = 14 + 40 + (24 * 24 * 3)  # 전체 파일 크기
        reserved = b'\x00\x00\x00\x00'
        data_offset = 54  # 픽셀 데이터 시작 위치
        
        # DIB 헤더 (40바이트)
        dib_size = 40
        width = 24
        height = 24
        planes = 1
        bits_per_pixel = 24
        compression = 0
        image_size = width * height * 3
        x_pixels_per_meter = 2835
        y_pixels_per_meter = 2835
        colors_used = 0
        important_colors = 0
        
        # 픽셀 데이터 (빨간색 그라데이션)
        pixel_data = bytearray()
        for y in range(height):
            for x in range(width):
                # 빨간색 그라데이션
                red = int((x / width) * 255)
                pixel_data.extend([0, 0, red])  # BMP는 BGR 순서
        
        # 패딩 (각 행은 4바이트 배수)
        row_size = width * 3
        padding = (4 - (row_size % 4)) % 4
        padded_data = bytearray()
        
        for row in range(height):
            start = row * row_size
            end = start + row_size
            padded_data.extend(pixel_data[start:end])
            padded_data.extend(b'\x00' * padding)
        
        # 전체 BMP 파일 조립
        bmp_data = (
            file_header +
            file_size.to_bytes(4, 'little') +
            reserved +
            data_offset.to_bytes(4, 'little') +
            dib_size.to_bytes(4, 'little') +
            width.to_bytes(4, 'little') +
            height.to_bytes(4, 'little') +
            planes.to_bytes(2, 'little') +
            bits_per_pixel.to_bytes(2, 'little') +
            compression.to_bytes(4, 'little') +
            image_size.to_bytes(4, 'little') +
            x_pixels_per_meter.to_bytes(4, 'little') +
            y_pixels_per_meter.to_bytes(4, 'little') +
            colors_used.to_bytes(4, 'little') +
            important_colors.to_bytes(4, 'little') +
            padded_data
        )
        
        return bmp_data
    
    # BMP 이미지 생성 및 Base64 인코딩
    bmp_image = create_simple_bmp()
    bmp_base64 = base64.b64encode(bmp_image).decode('ascii')
    
    print(f"  BMP 이미지 크기: {len(bmp_image)} 바이트")
    print(f"  Base64 길이: {len(bmp_base64)} 문자")
    
    # HTML에서 사용할 수 있는 Data URL 생성
    data_url = f"data:image/bmp;base64,{bmp_base64[:50]}..."
    print(f"  Data URL (일부): {data_url}")
    
    # 5. Base64 스트리밍 처리
    print("\n5. Base64 스트리밍 처리 (대용량 데이터):")
    
    def base64_stream_encode(input_stream, output_stream, chunk_size=8192):
        """스트리밍 방식 Base64 인코딩"""
        while True:
            chunk = input_stream.read(chunk_size)
            if not chunk:
                break
            
            encoded = base64.b64encode(chunk)
            output_stream.write(encoded)
    
    def base64_stream_decode(input_stream, output_stream, chunk_size=8192):
        """스트리밍 방식 Base64 디코딩"""
        # Base64는 4의 배수 단위로 처리 필요
        buffer = b''
        
        while True:
            chunk = input_stream.read(chunk_size)
            if not chunk and not buffer:
                break
            
            buffer += chunk
            
            # 4의 배수만큼 처리
            process_size = len(buffer) - (len(buffer) % 4)
            if process_size > 0:
                decoded = base64.b64decode(buffer[:process_size])
                output_stream.write(decoded)
                buffer = buffer[process_size:]
    
    # 스트리밍 테스트
    large_data = b'X' * 10000  # 10KB 테스트 데이터
    
    with io.BytesIO(large_data) as input_stream, \
         io.BytesIO() as encoded_stream, \
         io.BytesIO() as decoded_stream:
        
        # 인코딩
        base64_stream_encode(input_stream, encoded_stream)
        
        # 인코딩된 데이터로 리셋
        encoded_stream.seek(0)
        
        # 디코딩
        base64_stream_decode(encoded_stream, decoded_stream)
        
        decoded_stream.seek(0)
        decoded_data = decoded_stream.read()
        
        print(f"  원본 데이터 크기: {len(large_data)} 바이트")
        print(f"  인코딩 후 크기: {encoded_stream.tell()} 바이트")
        print(f"  디코딩 후 크기: {len(decoded_data)} 바이트")
        print(f"  데이터 무결성: {large_data == decoded_data}")
    
    # 6. Base64 검증 및 오류 처리
    print("\n6. Base64 검증 및 오류 처리:")
    
    def is_valid_base64(data):
        """Base64 문자열 유효성 검사"""
        try:
            # 디코딩 시도
            base64.b64decode(data, validate=True)
            return True
        except (ValueError, binascii.Error):
            return False
    
    test_cases = [
        "SGVsbG8gV29ybGQ=",  # 유효한 Base64
        "SGVsbG8gV29ybGQ",   # 패딩 없는 유효한 Base64
        "SGVsbG8gV29ybGQ===",  # 패딩 오류
        "SGVsbG8@V29ybGQ=",   # 잘못된 문자 포함
        "",  # 빈 문자열
    ]
    
    for test in test_cases:
        valid = is_valid_base64(test)
        print(f"  '{test[:20]}...': {'유효' if valid else '유효하지 않음'}")
    
    # 7. 커스텀 Base64 인코딩 (다른 문자셋)
    print("\n7. 커스텀 Base64 인코딩:")
    
    class CustomBase64:
        def __init__(self, alphabet=None):
            """사용자 정의 Base64 문자셋"""
            if alphabet is None:
                # 표준 Base64 문자셋
                self.alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
            else:
                if len(alphabet) != 64:
                    raise ValueError("알파벳은 64자여야 합니다")
                self.alphabet = alphabet
            
            # 디코딩을 위한 맵 생성
            self.decode_map = {char: idx for idx, char in enumerate(self.alphabet)}
            self.decode_map['='] = 0  # 패딩 문자
        
        def encode(self, data):
            """사용자 정의 Base64 인코딩"""
            if isinstance(data, str):
                data = data.encode('utf-8')
            
            # 표준 Base64 인코딩 후 문자 매핑
            std_encoded = base64.b64encode(data).decode('ascii')
            
            # 표준 Base64 문자를 커스텀 문자로 변환
            custom_encoded = ''.join(
                self.alphabet[self.decode_map[char]] if char in self.decode_map else char
                for char in std_encoded
            )
            
            return custom_encoded
        
        def decode(self, encoded_str):
            """사용자 정의 Base64 디코딩"""
            # 커스텀 문자를 표준 Base64 문자로 변환
            std_encoded = ''.join(
                chr(65 + self.alphabet.index(char)) if char in self.alphabet else char
                for char in encoded_str
            )
            
            # 표준 Base64 디코딩
            return base64.b64decode(std_encoded)
    
    # 커스텀 Base64 테스트 (URL-safe와 유사한 문자셋)
    custom_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
    custom_b64 = CustomBase64(custom_alphabet)
    
    test_string = "Custom Base64 Test 안녕"
    custom_encoded = custom_b64.encode(test_string)
    custom_decoded = custom_b64.decode(custom_encoded).decode('utf-8')
    
    print(f"  원본 문자열: {test_string}")
    print(f"  커스텀 Base64 인코딩: {custom_encoded}")
    print(f"  커스텀 Base64 디코딩: {custom_decoded}")
    print(f"  원본과 일치?: {test_string == custom_decoded}")

base64_encoding_decoding()
```

## 바이너리 배열 구조체 읽고 쓰기

### struct 모듈을 활용한 바이너리 데이터 처리
```python
import struct
import array

def binary_struct_operations():
    """바이너리 배열 구조체 처리"""
    
    print("\n" + "="*60)
    print("바이너리 배열 구조체 처리")
    print("="*60)
    
    # 1. 기본 구조체 패킹/언패킹
    print("1. 기본 구조체 패킹/언패킹:")
    
    # 포맷 문자열 설명:
    # <: 리틀 엔디안
    # >: 빅 엔디안
    # !: 네트워크 바이트 순서
    # i: 4바이트 정수
    # f: 4바이트 float
    # d: 8바이트 double
    # 10s: 10바이트 문자열
    # ?: 불리언
    
    # 단일 구조체
    packed_data = struct.pack('<i10sf', 123, b'Hello', 3.14)
    print(f"  패킹된 데이터 (hex): {packed_data.hex()}")
    
    unpacked = struct.unpack('<i10sf', packed_data)
    print(f"  언패킹된 데이터: {unpacked}")
    print(f"  문자열 복원: {unpacked[1].decode('ascii').rstrip(chr(0))}")
    
    # 2. 여러 데이터 일괄 처리
    print("\n2. 여러 데이터 일괄 처리:")
    
    # 여러 레코드 패킹
    records = [
        (1001, b'Product A', 29.99),
        (1002, b'Product B', 49.99),
        (1003, b'Product C', 19.99)
    ]
    
    fmt = '<i10sf'  # ID(4) + 이름(10) + 가격(4)
    record_size = struct.calcsize(fmt)
    
    packed_records = bytearray()
    for record in records:
        packed_records.extend(struct.pack(fmt, *record))
    
    print(f"  레코드 크기: {record_size} 바이트")
    print(f"  전체 데이터 크기: {len(packed_records)} 바이트")
    print(f"  패킹된 데이터 (처음 20바이트): {packed_records[:20].hex()}")
    
    # 레코드 언패킹
    print("\n  언패킹된 레코드:")
    for i in range(0, len(packed_records), record_size):
        chunk = packed_records[i:i + record_size]
        if len(chunk) == record_size:
            record_id, name, price = struct.unpack(fmt, chunk)
            name_str = name.decode('ascii').rstrip(chr(0))
            print(f"    ID: {record_id}, 이름: {name_str}, 가격: {price:.2f}")
    
    # 3. 구조체 배열 (array 모듈 사용)
    print("\n3. array 모듈을 이용한 구조체 배열:")
    
    # float 배열 생성 및 처리
    float_array = array.array('f', [1.1, 2.2, 3.3, 4.4, 5.5])
    print(f"  float 배열: {float_array}")
    print(f"  배열 타입코드: {float_array.typecode}")
    print(f"  배열 항목 크기: {float_array.itemsize} 바이트")
    
    # 배열을 바이너리 데이터로 변환
    binary_data = float_array.tobytes()
    print(f"  바이너리 데이터 크기: {len(binary_data)} 바이트")
    print(f"  바이너리 데이터 (hex): {binary_data[:20].hex()}...")
    
    # 바이너리 데이터에서 배열 복원
    restored_array = array.array('f')
    restored_array.frombytes(binary_data)
    print(f"  복원된 배열: {restored_array}")
    
    # 4. 복잡한 구조체 설계
    print("\n4. 복잡한 구조체 설계:")
    
    # 네트워크 패킷 구조체 예제
    class NetworkPacket:
        HEADER_FORMAT = '!HHH'  # 타입(2), 길이(2), 시퀀스(2)
        HEADER_SIZE = struct.calcsize(HEADER_FORMAT)
        
        def __init__(self, packet_type=1, sequence=0, payload=b''):
            self.packet_type = packet_type
            self.sequence = sequence
            self.payload = payload
        
        def pack(self):
            """패킷을 바이너리로 변환"""
            header = struct.pack(self.HEADER_FORMAT, 
                               self.packet_type, 
                               len(self.payload), 
                               self.sequence)
            return header + self.payload
        
        @classmethod
        def unpack(cls, data):
            """바이너리에서 패킷 생성"""
            if len(data) < cls.HEADER_SIZE:
                raise ValueError("데이터가 너무 짧습니다")
            
            header = data[:cls.HEADER_SIZE]
            payload = data[cls.HEADER_SIZE:]
            
            packet_type, length, sequence = struct.unpack(cls.HEADER_FORMAT, header)
            
            if len(payload) != length:
                raise ValueError(f"페이로드 길이 불일치: {len(payload)} != {length}")
            
            return cls(packet_type, sequence, payload)
        
        def __str__(self):
            return (f"Packet(type={self.packet_type}, "
                   f"seq={self.sequence}, "
                   f"payload_size={len(self.payload)})")
    
    # 패킷 생성 및 테스트
    packet = NetworkPacket(
        packet_type=1,
        sequence=100,
        payload=b'Hello Network Packet World!'
    )
    
    packed_packet = packet.pack()
    print(f"  패킷: {packet}")
    print(f"  패킷 크기: {len(packed_packet)} 바이트")
    print(f"  패킷 데이터 (hex): {packed_packet.hex()[:40]}...")
    
    # 패킷 언패킹
    unpacked_packet = NetworkPacket.unpack(packed_packet)
    print(f"  언패킹된 패킷: {unpacked_packet}")
    print(f"  페이로드: {unpacked_packet.payload.decode('ascii')}")
    
    # 5. 구조체와 메모리뷰를 이용한 고성능 처리
    print("\n5. 구조체와 memoryview 고성능 처리:")
    
    class HighPerformanceBuffer:
        """고성능 바이너리 버퍼"""
        
        def __init__(self, buffer_size=1024):
            self.buffer = bytearray(buffer_size)
            self.view = memoryview(self.buffer)
            self.position = 0
        
        def write_int(self, value, endian='<'):
            """정수 쓰기"""
            fmt = f'{endian}i'
            struct.pack_into(fmt, self.buffer, self.position, value)
            self.position += struct.calcsize(fmt)
            return self
        
        def write_float(self, value, endian='<'):
            """실수 쓰기"""
            fmt = f'{endian}f'
            struct.pack_into(fmt, self.buffer, self.position, value)
            self.position += struct.calcsize(fmt)
            return self
        
        def write_string(self, value, max_length=50, encoding='utf-8'):
            """문자열 쓰기"""
            encoded = value.encode(encoding)[:max_length]
            length = len(encoded)
            
            # 길이 정보 먼저 쓰기
            self.write_int(length)
            
            # 문자열 데이터 쓰기
            self.buffer[self.position:self.position + length] = encoded
            self.position += max_length
            
            # 남은 공간을 0으로 채우기
            if length < max_length:
                padding = max_length - length
                self.buffer[self.position - padding:self.position] = b'\x00' * padding
            
            return self
        
        def read_int(self, endian='<'):
            """정수 읽기"""
            fmt = f'{endian}i'
            size = struct.calcsize(fmt)
            value = struct.unpack_from(fmt, self.buffer, self.position)[0]
            self.position += size
            return value
        
        def read_float(self, endian='<'):
            """실수 읽기"""
            fmt = f'{endian}f'
            size = struct.calcsize(fmt)
            value = struct.unpack_from(fmt, self.buffer, self.position)[0]
            self.position += size
            return value
        
        def read_string(self, max_length=50, encoding='utf-8'):
            """문자열 읽기"""
            # 길이 정보 읽기
            length = self.read_int()
            
            # 문자열 데이터 읽기
            start_pos = self.position
            end_pos = self.position + max_length
            
            encoded = self.buffer[start_pos:start_pos + length]
            self.position += max_length
            
            return encoded.decode(encoding)
        
        def reset_position(self):
            """위치 초기화"""
            self.position = 0
        
        def get_data(self):
            """현재까지 쓴 데이터 반환"""
            return self.buffer[:self.position]
    
    # 고성능 버퍼 테스트
    buffer = HighPerformanceBuffer(256)
    
    buffer.write_int(1001) \
          .write_float(3.14159) \
          .write_string("테스트 문자열", max_length=30) \
          .write_int(2002) \
          .write_float(2.71828)
    
    print(f"  버퍼 사용량: {buffer.position}/{len(buffer.buffer)} 바이트")
    print(f"  버퍼 데이터 (hex): {buffer.get_data().hex()[:60]}...")
    
    # 데이터 읽기
    buffer.reset_position()
    
    int1 = buffer.read_int()
    float1 = buffer.read_float()
    string1 = buffer.read_string(max_length=30)
    int2 = buffer.read_int()
    float2 = buffer.read_float()
    
    print(f"\n  읽은 데이터:")
    print(f"    정수1: {int1}")
    print(f"    실수1: {float1:.5f}")
    print(f"    문자열: {string1}")
    print(f"    정수2: {int2}")
    print(f"    실수2: {float2:.5f}")
    
    # 6. 이진 파일에 구조체 배열 저장
    print("\n6. 이진 파일에 구조체 배열 저장:")
    
    # 학생 레코드 구조체
    student_format = '<i20sff'  # ID(4) + 이름(20) + 점수1(4) + 점수2(4)
    student_size = struct.calcsize(student_format)
    
    students = [
        (1001, b'김철수', 85.5, 92.0),
        (1002, b'이영희', 92.5, 88.0),
        (1003, b'박민수', 78.0, 85.5),
        (1004, b'최지우', 95.0, 96.5)
    ]
    
    # 이진 파일로 저장
    with open('students.bin', 'wb') as f:
        for student in students:
            packed_student = struct.pack(student_format, *student)
            f.write(packed_student)
    
    print(f"  학생 레코드 크기: {student_size} 바이트")
    print(f"  파일 크기: {len(students) * student_size} 바이트")
    
    # 이진 파일에서 읽기
    print("\n  파일에서 읽은 학생 데이터:")
    with open('students.bin', 'rb') as f:
        record_count = 0
        
        while True:
            chunk = f.read(student_size)
            if not chunk or len(chunk) < student_size:
                break
            
            student_id, name_bytes, score1, score2 = struct.unpack(student_format, chunk)
            name = name_bytes.decode('utf-8').rstrip('\x00')
            
            print(f"    ID: {student_id}, 이름: {name}, 점수: {score1:.1f}, {score2:.1f}")
            record_count += 1
        
        print(f"\n  총 {record_count}명의 학생 데이터를 읽었습니다.")

binary_struct_operations()
```

## 중첩, 가변 바이너리 구조체 읽기

### 복잡한 바이너리 구조체 처리
```python
def nested_variable_binary_structures():
    """중첩 및 가변 바이너리 구조체 처리"""
    
    print("\n" + "="*60)
    print("중첩 및 가변 바이너리 구조체 처리")
    print("="*60)
    
    # 1. 가변 길이 문자열이 포함된 구조체
    print("1. 가변 길이 문자열 구조체:")
    
    def pack_variable_string(data, encoding='utf-8'):
        """가변 길이 문자열 패킹"""
        if isinstance(data, str):
            data = data.encode(encoding)
        
        # 길이 + 데이터 형식
        length = len(data)
        return struct.pack(f'<I{length}s', length, data)
    
    def unpack_variable_string(binary_data, encoding='utf-8'):
        """가변 길이 문자열 언패킹"""
        # 길이 읽기
        length = struct.unpack_from('<I', binary_data)[0]
        length_size = struct.calcsize('<I')
        
        # 문자열 데이터 읽기
        string_data = struct.unpack_from(f'{length}s', binary_data, length_size)[0]
        
        total_size = length_size + length
        return string_data.decode(encoding), total_size
    
    # 테스트
    test_string = "안녕하세요! Hello World!"
    packed_var_str = pack_variable_string(test_string)
    
    print(f"  원본 문자열: {test_string}")
    print(f"  원본 길이: {len(test_string)} 문자")
    print(f"  패킹된 크기: {len(packed_var_str)} 바이트")
    print(f"  패킹된 데이터 (hex): {packed_var_str.hex()[:40]}...")
    
    unpacked_str, size = unpack_variable_string(packed_var_str)
    print(f"  언패킹된 문자열: {unpacked_str}")
    print(f"  읽은 바이트 수: {size}")
    
    # 2. 중첩된 구조체 배열
    print("\n2. 중첩된 구조체 배열:")
    
    class Point3D:
        """3D 점 구조체"""
        FORMAT = '<fff'  # x, y, z
        SIZE = struct.calcsize(FORMAT)
        
        def __init__(self, x=0.0, y=0.0, z=0.0):
            self.x = x
            self.y = y
            self.z = z
        
        def pack(self):
            return struct.pack(self.FORMAT, self.x, self.y, self.z)
        
        @classmethod
        def unpack(cls, data):
            x, y, z = struct.unpack(cls.FORMAT, data)
            return cls(x, y, z)
        
        def __str__(self):
            return f"Point({self.x:.2f}, {self.y:.2f}, {self.z:.2f})"
    
    class Mesh:
        """메시 구조체 (점 배열)"""
        def __init__(self):
            self.points = []
        
        def add_point(self, point):
            self.points.append(point)
        
        def pack(self):
            """메시 데이터 패킹"""
            # 점 개수 + 점 데이터들
            point_count = len(self.points)
            header = struct.pack('<I', point_count)
            
            point_data = bytearray()
            for point in self.points:
                point_data.extend(point.pack())
            
            return header + point_data
        
        @classmethod
        def unpack(cls, data):
            """메시 데이터 언패킹"""
            mesh = cls()
            
            # 점 개수 읽기
            point_count = struct.unpack_from('<I', data)[0]
            offset = struct.calcsize('<I')
            
            # 각 점 읽기
            for _ in range(point_count):
                point_data = data[offset:offset + Point3D.SIZE]
                point = Point3D.unpack(point_data)
                mesh.add_point(point)
                offset += Point3D.SIZE
            
            return mesh
        
        def __str__(self):
            points_str = ', '.join(str(p) for p in self.points[:3])
            if len(self.points) > 3:
                points_str += f", ... ({len(self.points)}개 점)"
            return f"Mesh[{points_str}]"
    
    # 메시 생성 및 테스트
    mesh = Mesh()
    mesh.add_point(Point3D(1.0, 2.0, 3.0))
    mesh.add_point(Point3D(4.0, 5.0, 6.0))
    mesh.add_point(Point3D(7.0, 8.0, 9.0))
    mesh.add_point(Point3D(10.0, 11.0, 12.0))
    
    packed_mesh = mesh.pack()
    print(f"  메시: {mesh}")
    print(f"  패킹된 크기: {len(packed_mesh)} 바이트")
    
    unpacked_mesh = Mesh.unpack(packed_mesh)
    print(f"  언패킹된 메시: {unpacked_mesh}")
    
    # 3. 태그된 가변 구조체 (TLV: Type-Length-Value)
    print("\n3. TLV (Type-Length-Value) 구조체:")
    
    class TLVRecord:
        """TLV 레코드"""
        
        # 타입 정의
        TYPE_INT = 1
        TYPE_STRING = 2
        TYPE_FLOAT = 3
        TYPE_BOOL = 4
        
        def __init__(self, data_type, value):
            self.data_type = data_type
            self.value = value
        
        def pack(self):
            """TLV 패킹"""
            if self.data_type == self.TYPE_INT:
                value_data = struct.pack('<i', self.value)
            elif self.data_type == self.TYPE_STRING:
                if isinstance(self.value, str):
                    value_data = self.value.encode('utf-8')
                else:
                    value_data = self.value
            elif self.data_type == self.TYPE_FLOAT:
                value_data = struct.pack('<f', self.value)
            elif self.data_type == self.TYPE_BOOL:
                value_data = struct.pack('<?', self.value)
            else:
                raise ValueError(f"지원하지 않는 타입: {self.data_type}")
            
            # TLV 형식으로 패킹
            length = len(value_data)
            return struct.pack('<BH', self.data_type, length) + value_data
        
        @classmethod
        def unpack(cls, data, offset=0):
            """TLV 언패킹"""
            # 타입과 길이 읽기
            data_type, length = struct.unpack_from('<BH', data, offset)
            header_size = struct.calcsize('<BH')
            offset += header_size
            
            # 값 읽기
            value_data = data[offset:offset + length]
            offset += length
            
            # 타입에 따라 값 변환
            if data_type == cls.TYPE_INT:
                value = struct.unpack('<i', value_data)[0]
            elif data_type == cls.TYPE_STRING:
                value = value_data.decode('utf-8')
            elif data_type == cls.TYPE_FLOAT:
                value = struct.unpack('<f', value_data)[0]
            elif data_type == cls.TYPE_BOOL:
                value = struct.unpack('<?', value_data)[0]
            else:
                value = value_data  # 알 수 없는 타입은 바이너리로 저장
            
            return cls(data_type, value), offset
        
        def __str__(self):
            type_names = {
                self.TYPE_INT: 'INT',
                self.TYPE_STRING: 'STRING',
                self.TYPE_FLOAT: 'FLOAT',
                self.TYPE_BOOL: 'BOOL'
            }
            return f"TLV[{type_names.get(self.data_type, 'UNKNOWN')}: {self.value}]"
    
    class TLVContainer:
        """TLV 레코드 컨테이너"""
        
        def __init__(self):
            self.records = []
        
        def add_record(self, record):
            self.records.append(record)
        
        def pack(self):
            """모든 레코드 패킹"""
            data = bytearray()
            for record in self.records:
                data.extend(record.pack())
            return bytes(data)
        
        @classmethod
        def unpack(cls, data):
            """모든 레코드 언패킹"""
            container = cls()
            offset = 0
            
            while offset < len(data):
                record, offset = TLVRecord.unpack(data, offset)
                container.add_record(record)
            
            return container
        
        def __str__(self):
            records_str = '\n  '.join(str(r) for r in self.records)
            return f"TLVContainer[\n  {records_str}\n]"
    
    # TLV 컨테이너 테스트
    container = TLVContainer()
    container.add_record(TLVRecord(TLVRecord.TYPE_INT, 42))
    container.add_record(TLVRecord(TLVRecord.TYPE_STRING, "안녕하세요"))
    container.add_record(TLVRecord(TLVRecord.TYPE_FLOAT, 3.14159))
    container.add_record(TLVRecord(TLVRecord.TYPE_BOOL, True))
    
    print(f"  컨테이너: {container}")
    
    packed_container = container.pack()
    print(f"  패킹된 크기: {len(packed_container)} 바이트")
    print(f"  패킹된 데이터 (hex): {packed_container.hex()[:60]}...")
    
    unpacked_container = TLVContainer.unpack(packed_container)
    print(f"  언패킹된 컨테이너: {unpacked_container}")
    
    # 4. 이진 트리 구조 저장 및 로드
    print("\n4. 이진 트리 구조 저장:")
    
    class BinaryTreeNode:
        """이진 트리 노드"""
        
        def __init__(self, value=0):
            self.value = value
            self.left = None
            self.right = None
        
        def pack(self):
            """노드와 하위 트리 패킹"""
            # 노드 값과 자식 존재 여부
            has_left = 1 if self.left else 0
            has_right = 1 if self.right else 0
            
            header = struct.pack('<iBB', self.value, has_left, has_right)
            data = bytearray(header)
            
            # 왼쪽 자식 패킹
            if self.left:
                data.extend(self.left.pack())
            
            # 오른쪽 자식 패킹
            if self.right:
                data.extend(self.right.pack())
            
            return bytes(data)
        
        @classmethod
        def unpack(cls, data, offset=0):
            """노드와 하위 트리 언패킹"""
            # 헤더 읽기
            value, has_left, has_right = struct.unpack_from('<iBB', data, offset)
            offset += struct.calcsize('<iBB')
            
            # 노드 생성
            node = cls(value)
            
            # 왼쪽 자식 언패킹
            if has_left:
                node.left, offset = cls.unpack(data, offset)
            
            # 오른쪽 자식 언패킹
            if has_right:
                node.right, offset = cls.unpack(data, offset)
            
            return node, offset
        
        def __str__(self):
            left_val = self.left.value if self.left else None
            right_val = self.right.value if self.right else None
            return f"Node({self.value}, L:{left_val}, R:{right_val})"
    
    # 이진 트리 생성
    root = BinaryTreeNode(1)
    root.left = BinaryTreeNode(2)
    root.right = BinaryTreeNode(3)
    root.left.left = BinaryTreeNode(4)
    root.left.right = BinaryTreeNode(5)
    root.right.left = BinaryTreeNode(6)
    
    print(f"  이진 트리 구조:")
    print(f"        {root.value}")
    print(f"       /    \\")
    print(f"      {root.left.value}      {root.right.value}")
    print(f"     / \\    /")
    print(f"    {root.left.left.value}   {root.left.right.value}   {root.right.left.value}")
    
    packed_tree = root.pack()
    print(f"  패킹된 트리 크기: {len(packed_tree)} 바이트")
    
    unpacked_tree, _ = BinaryTreeNode.unpack(packed_tree)
    print(f"  언패킹된 트리 루트: {unpacked_tree}")
    print(f"  왼쪽 자식: {unpacked_tree.left}")
    print(f"  오른쪽 자식: {unpacked_tree.right}")
    
    # 5. 효율적인 대량 데이터 처리를 위한 슬라이딩 윈도우
    print("\n5. 슬라이딩 윈도우를 이용한 대용량 구조체 처리:")
    
    class SlidingWindowProcessor:
        """슬라이딩 윈도우 구조체 처리기"""
        
        def __init__(self, chunk_size=4096):
            self.chunk_size = chunk_size
            self.buffer = bytearray()
        
        def process_stream(self, stream, record_format, callback):
            """스트림에서 구조체 레코드 처리"""
            record_size = struct.calcsize(record_format)
            
            while True:
                # 버퍼에 데이터 읽기
                chunk = stream.read(self.chunk_size)
                if not chunk:
                    break
                
                self.buffer.extend(chunk)
                
                # 완전한 레코드들 처리
                while len(self.buffer) >= record_size:
                    record_data = self.buffer[:record_size]
                    record = struct.unpack(record_format, record_data)
                    
                    # 콜백으로 레코드 처리
                    callback(record)
                    
                    # 처리된 레코드 제거
                    del self.buffer[:record_size]
            
            # 남은 데이터 처리
            if self.buffer:
                print(f"  남은 데이터: {len(self.buffer)} 바이트 (불완전 레코드)")
    
    # 테스트용 스트림 생성
    record_format = '<Qd'  # 타임스탬프(8) + 값(8)
    test_records = [
        (1000, 23.5),
        (1001, 24.1),
        (1002, 22.8),
        (1003, 25.3),
        (1004, 21.9)
    ]
    
    # 테스트 데이터 생성
    test_data = bytearray()
    for record in test_records:
        test_data.extend(struct.pack(record_format, *record))
    
    # 스트림 처리 테스트
    stream = io.BytesIO(test_data)
    processor = SlidingWindowProcessor(chunk_size=10)  # 작은 청크로 테스트
    
    processed_records = []
    def record_callback(record):
        processed_records.append(record)
    
    processor.process_stream(stream, record_format, record_callback)
    
    print(f"  처리된 레코드 수: {len(processed_records)}")
    for i, record in enumerate(processed_records):
        print(f"    레코드 {i}: 타임스탬프={record[0]}, 값={record[1]:.1f}")

nested_variable_binary_structures()
```

## 데이터 요약과 통계 수행

### 다양한 데이터 통계 분석 기법
```python
import statistics
import numpy as np
from collections import Counter, defaultdict
from datetime import datetime, timedelta

def data_summary_statistics():
    """데이터 요약과 통계 수행"""
    
    print("\n" + "="*60)
    print("데이터 요약과 통계 수행")
    print("="*60)
    
    # 1. 기본 통계 계산
    print("1. 기본 통계 계산:")
    
    # 샘플 데이터
    sales_data = [125000, 98000, 156000, 112000, 89000, 145000, 178000, 
                  99000, 132000, 167000, 101000, 189000, 123000, 155000, 176000]
    
    print(f"  판매 데이터: {sales_data}")
    print(f"  데이터 개수: {len(sales_data)}")
    
    # 기본 통계
    print(f"  최소값: {min(sales_data):,}")
    print(f"  최대값: {max(sales_data):,}")
    print(f"  합계: {sum(sales_data):,}")
    print(f"  평균: {statistics.mean(sales_data):,.0f}")
    print(f"  중앙값: {statistics.median(sales_data):,}")
    print(f"  표준편차: {statistics.stdev(sales_data):,.0f}")
    print(f"  분산: {statistics.variance(sales_data):,.0f}")
    
    # 사분위수
    quartiles = np.percentile(sales_data, [25, 50, 75])
    print(f"  1사분위수 (Q1): {quartiles[0]:,.0f}")
    print(f"  2사분위수 (Q2, 중앙값): {quartiles[1]:,.0f}")
    print(f"  3사분위수 (Q3): {quartiles[2]:,.0f}")
    print(f"  사분위간 범위 (IQR): {quartiles[2] - quartiles[0]:,.0f}")
    
    # 2. 빈도 분석
    print("\n2. 빈도 분석:")
    
    # 카테고리별 데이터
    categories = ['전자제품', '의류', '가구', '전자제품', '의류', '가구',
                  '전자제품', '생활용품', '의류', '전자제품', '가구', '의류',
                  '생활용품', '전자제품', '가구']
    
    category_counts = Counter(categories)
    print(f"  카테고리별 빈도:")
    for category, count in category_counts.most_common():
        percentage = (count / len(categories)) * 100
        print(f"    {category}: {count}회 ({percentage:.1f}%)")
    
    # 3. 시계열 데이터 통계
    print("\n3. 시계열 데이터 분석:")
    
    # 시간별 판매 데이터 생성
    time_series_data = []
    base_time = datetime(2024, 1, 1, 9, 0)  # 오전 9시 시작
    
    hourly_sales = [120, 85, 95, 110, 150, 210, 180, 160, 
                    140, 130, 115, 100, 90, 80, 95, 110]
    
    for i, sales in enumerate(hourly_sales):
        current_time = base_time + timedelta(hours=i)
        time_series_data.append((current_time, sales))
    
    print(f"  시간별 판매 데이터 (첫 5개):")
    for time, sales in time_series_data[:5]:
        print(f"    {time.strftime('%H:%M')}: {sales:,}개")
    
    # 이동 평균 계산
    window_size = 3
    moving_averages = []
    
    for i in range(len(hourly_sales) - window_size + 1):
        window = hourly_sales[i:i + window_size]
        moving_averages.append(statistics.mean(window))
    
    print(f"\n  {window_size}시간 이동 평균 (첫 5개):")
    for i, avg in enumerate(moving_averages[:5]):
        print(f"    시간 {i+1}-{i+3}: {avg:.1f}")
    
    # 4. 그룹별 통계
    print("\n4. 그룹별 통계 분석:")
    
    # 제품별 판매 데이터
    product_sales = [
        {'product': '노트북', 'category': '전자제품', 'sales': 15, 'revenue': 37500000},
        {'product': '의자', 'category': '가구', 'sales': 45, 'revenue': 6750000},
        {'product': '스마트폰', 'category': '전자제품', 'sales': 32, 'revenue': 44800000},
        {'product': '책상', 'category': '가구', 'sales': 28, 'revenue': 8400000},
        {'product': '티셔츠', 'category': '의류', 'sales': 120, 'revenue': 3600000},
        {'product': '모니터', 'category': '전자제품', 'sales': 18, 'revenue': 12600000},
        {'product': '청바지', 'category': '의류', 'sales': 85, 'revenue': 6800000},
    ]
    
    # 카테고리별 통계
    category_stats = defaultdict(lambda: {'total_sales': 0, 'total_revenue': 0, 'products': []})
    
    for item in product_sales:
        category = item['category']
        category_stats[category]['total_sales'] += item['sales']
        category_stats[category]['total_revenue'] += item['revenue']
        category_stats[category]['products'].append(item['product'])
    
    print(f"  카테고리별 통계:")
    for category, stats in category_stats.items():
        avg_revenue_per_sale = stats['total_revenue'] / stats['total_sales'] if stats['total_sales'] > 0 else 0
        print(f"\n    {category}:")
        print(f"      총 판매량: {stats['total_sales']:,}개")
        print(f"      총 매출: {stats['total_revenue']:,}원")
        print(f"      평균 단가: {avg_revenue_per_sale:,.0f}원")
        print(f"      제품 수: {len(stats['products'])}개")
    
    # 5. 상관관계 분석
    print("\n5. 상관관계 분석:")
    
    # 온도와 판매량 데이터
    temperatures = [22, 25, 28, 30, 26, 24, 27, 29, 31, 23]
    icecream_sales = [150, 180, 210, 230, 190, 170, 200, 220, 240, 160]
    umbrella_sales = [10, 5, 3, 2, 4, 8, 5, 3, 2, 12]
    
    # 상관계수 계산
    def calculate_correlation(x, y):
        """피어슨 상관계수 계산"""
        n = len(x)
        
        mean_x = sum(x) / n
        mean_y = sum(y) / n
        
        numerator = sum((xi - mean_x) * (yi - mean_y) for xi, yi in zip(x, y))
        denominator_x = sum((xi - mean_x) ** 2 for xi in x)
        denominator_y = sum((yi - mean_y) ** 2 for yi in y)
        
        if denominator_x == 0 or denominator_y == 0:
            return 0
        
        return numerator / ((denominator_x * denominator_y) ** 0.5)
    
    corr_temp_icecream = calculate_correlation(temperatures, icecream_sales)
    corr_temp_umbrella = calculate_correlation(temperatures, umbrella_sales)
    
    print(f"  온도와 아이스크림 판매량 상관계수: {corr_temp_icecream:.3f}")
    print(f"  온도와 우산 판매량 상관계수: {corr_temp_umbrella:.3f}")
    
    # 상관관계 해석
    def interpret_correlation(corr):
        """상관계수 해석"""
        abs_corr = abs(corr)
        if abs_corr >= 0.7:
            strength = "강한"
        elif abs_corr >= 0.3:
            strength = "중간"
        else:
            strength = "약한"
        
        direction = "양의" if corr > 0 else "음의" if corr < 0 else "없음"
        
        return f"{strength} {direction} 상관관계"
    
    print(f"\n  해석:")
    print(f"    온도-아이스크림: {interpret_correlation(corr_temp_icecream)}")
    print(f"    온도-우산: {interpret_correlation(corr_temp_umbrella)}")
    
    # 6. 이상치 탐지
    print("\n6. 이상치 탐지:")
    
    # 데이터에 이상치 추가
    normal_data = [125, 130, 128, 132, 127, 129, 131, 126, 130, 128]
    data_with_outliers = normal_data + [200, 50, 210]  # 이상치 추가
    
    print(f"  정상 데이터: {normal_data}")
    print(f"  이상치 포함 데이터: {data_with_outliers}")
    
    # IQR 방법으로 이상치 탐지
    q1 = np.percentile(data_with_outliers, 25)
    q3 = np.percentile(data_with_outliers, 75)
    iqr = q3 - q1
    
    lower_bound = q1 - 1.5 * iqr
    upper_bound = q3 + 1.5 * iqr
    
    outliers = [x for x in data_with_outliers if x < lower_bound or x > upper_bound]
    normal_values = [x for x in data_with_outliers if lower_bound <= x <= upper_bound]
    
    print(f"\n  이상치 탐지 결과:")
    print(f"    Q1: {q1:.1f}")
    print(f"    Q3: {q3:.1f}")
    print(f"    IQR: {iqr:.1f}")
    print(f"    하한 경계: {lower_bound:.1f}")
    print(f"    상한 경계: {upper_bound:.1f}")
    print(f"    탐지된 이상치: {outliers}")
    print(f"    정상값 범위 데이터: {len(normal_values)}개")
    
    # 7. 데이터 집계 및 요약
    print("\n7. 데이터 집계 및 요약 리포트:")
    
    class DataAnalyzer:
        """데이터 분석 및 요약 클래스"""
        
        def __init__(self, data):
            self.data = data
        
        def generate_summary(self):
            """데이터 요약 리포트 생성"""
            summary = {
                'count': len(self.data),
                'mean': statistics.mean(self.data),
                'median': statistics.median(self.data),
                'mode': statistics.mode(self.data) if len(self.data) > 0 else None,
                'stdev': statistics.stdev(self.data) if len(self.data) > 1 else 0,
                'min': min(self.data),
                'max': max(self.data),
                'range': max(self.data) - min(self.data),
                'sum': sum(self.data)
            }
            
            # 사분위수
            quartiles = np.percentile(self.data, [0, 25, 50, 75, 100])
            summary['percentiles'] = {
                '0%': quartiles[0],
                '25%': quartiles[1],
                '50%': quartiles[2],
                '75%': quartiles[3],
                '100%': quartiles[4]
            }
            
            return summary
        
        def print_report(self):
            """분석 리포트 출력"""
            summary = self.generate_summary()
            
            print(f"  데이터 분석 리포트")
            print(f"  {'='*40}")
            print(f"  데이터 개수: {summary['count']:,}")
            print(f"  합계: {summary['sum']:,.0f}")
            print(f"  평균: {summary['mean']:,.2f}")
            print(f"  중앙값: {summary['median']:,.2f}")
            print(f"  표준편차: {summary['stdev']:,.2f}")
            print(f"  범위: {summary['range']:,.2f}")
            print(f"\n  사분위수:")
            for perc, value in summary['percentiles'].items():
                print(f"    {perc}: {value:,.2f}")
            
            # 히스토그램 (간단한 텍스트 버전)
            print(f"\n  분포 히스토그램:")
            self.print_histogram()
        
        def print_histogram(self, bins=10):
            """텍스트 히스토그램 출력"""
            if not self.data:
                return
            
            min_val = min(self.data)
            max_val = max(self.data)
            bin_width = (max_val - min_val) / bins
            
            # 빈도 계산
            frequencies = [0] * bins
            for value in self.data:
                if value == max_val:
                    bin_index = bins - 1
                else:
                    bin_index = int((value - min_val) / bin_width)
                frequencies[bin_index] += 1
            
            # 최대 빈도 (스케일링용)
            max_freq = max(frequencies)
            scale = 50 / max_freq if max_freq > 0 else 1
            
            # 히스토그램 출력
            for i in range(bins):
                lower = min_val + i * bin_width
                upper = lower + bin_width
                count = frequencies[i]
                bar = '█' * int(count * scale)
                percentage = (count / len(self.data)) * 100
                
                print(f"    [{lower:6.1f} - {upper:6.1f}]: {bar} {count:3d} ({percentage:5.1f}%)")
    
    # 데이터 분석 테스트
    analyzer = DataAnalyzer(sales_data)
    analyzer.print_report()
    
    # 8. 실시간 스트리밍 통계
    print("\n8. 실시간 스트리밍 통계:")
    
    class StreamingStatistics:
        """실시간 스트리밍 데이터 통계"""
        
        def __init__(self):
            self.count = 0
            self.sum = 0
            self.sum_squares = 0
            self.min = float('inf')
            self.max = float('-inf')
        
        def update(self, value):
            """새 데이터 추가"""
            self.count += 1
            self.sum += value
            self.sum_squares += value * value
            
            if value < self.min:
                self.min = value
            if value > self.max:
                self.max = value
        
        @property
        def mean(self):
            """평균"""
            return self.sum / self.count if self.count > 0 else 0
        
        @property
        def variance(self):
            """분산"""
            if self.count <= 1:
                return 0
            return (self.sum_squares - self.sum * self.sum / self.count) / (self.count - 1)
        
        @property
        def stdev(self):
            """표준편차"""
            return self.variance ** 0.5
        
        def get_summary(self):
            """요약 통계"""
            return {
                'count': self.count,
                'mean': self.mean,
                'stdev': self.stdev,
                'min': self.min,
                'max': self.max,
                'sum': self.sum
            }
    
    # 스트리밍 데이터 시뮬레이션
    stream_stats = StreamingStatistics()
    
    # 랜덤 데이터 스트림
    import random
    stream_data = [random.uniform(100, 200) for _ in range(100)]
    
    print(f"  스트리밍 데이터 처리 (100개 데이터):")
    for i, value in enumerate(stream_data):
        stream_stats.update(value)
        
        # 10개 단위로 중간 결과 출력
        if (i + 1) % 10 == 0:
            summary = stream_stats.get_summary()
            print(f"\n    데이터 {i+1}개 처리 후:")
            print(f"      평균: {summary['mean']:.2f}")
            print(f"      표준편차: {summary['stdev']:.2f}")
            print(f"      범위: {summary['min']:.2f} ~ {summary['max']:.2f}")
    
    print(f"\n  최종 통계:")
    final_summary = stream_stats.get_summary()
    for key, value in final_summary.items():
        if isinstance(value, float):
            print(f"    {key}: {value:.2f}")
        else:
            print(f"    {key}: {value}")

data_summary_statistics()
```

## 결론

Python은 데이터베이스 작업부터 바이너리 데이터 처리, 통계 분석까지 다양한 데이터 처리 작업을 위한 풍부한 도구들을 제공합니다. 관계형 데이터베이스 작업에서는 SQLite가 내장되어 있어 간단한 데이터 저장에 유용하며, `sqlite3` 모듈을 통해 완전한 SQL 기능을 활용할 수 있습니다. 실제 프로덕션 환경에서는 PostgreSQL, MySQL 등의 외부 데이터베이스와의 연동이 필요하며, 이때는 `psycopg2`, `mysql-connector-python` 등의 라이브러리를 사용합니다.

16진수와 Base64 인코딩은 데이터를 텍스트 형식으로 안전하게 전송하거나 저장할 때 필수적입니다. `bytes.hex()`와 `bytes.fromhex()` 메서드는 16진수 변환을 간단히 처리할 수 있으며, `base64` 모듈은 다양한 Base64 변종을 지원합니다. 특히 URL-safe Base64는 웹 애플리케이션에서 자주 사용됩니다.

바이너리 배열 구조체 처리는 `struct` 모듈이 핵심입니다. 포맷 문자열을 이용해 다양한 데이터 타입을 패킹하고 언패킹할 수 있으며, `array` 모듈을 함께 사용하면 메모리 효율적인 배열 처리가 가능합니다. 중첩되고 가변적인 구조체의 경우 재귀적인 접근 방식이나 TLV(Type-Length-Value) 패턴이 유용합니다.

데이터 요약과 통계 수행은 `statistics` 모듈이 기본적인 통계 계산을 제공하며, 더 고급 분석에는 `numpy`와 `pandas`가 필수적입니다. 이상치 탐지, 상관관계 분석, 이동 평균 계산 등의 기법은 데이터의 의미를 이해하는 데 도움을 줍니다.

이러한 기술들을 효과적으로 조합하면 데이터 수집, 저장, 처리, 분석의 전 과정을 Python으로 구현할 수 있습니다. 각 도구의 특성과 적절한 사용 시나리오를 이해하는 것이 효율적인 데이터 처리 시스템 구축의 핵심입니다. 실제 프로젝트에서는 데이터 크기, 처리 속도 요구사항, 유지보수성 등을 고려하여 적절한 기술 스택을 선택해야 합니다.