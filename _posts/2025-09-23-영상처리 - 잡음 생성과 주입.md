---
layout: post
title: 영상처리 - 잡음 생성과 주입
date: 2025-09-23 19:25:23 +0900
category: 영상처리
---
# 잡음(Noise) 생성과 주입

## 1. 잡음 모델의 기본 개념

### 1.1 가우시안(정규) 잡음
픽셀 값 \(I\)에 **연속 확률 변수** \(n \sim \mathcal{N}(\mu,\sigma^2)\) 를 더합니다.
\[
I' = I + n,\quad n \sim \mathcal{N}(\mu,\sigma^2)
\]
- \(\mu\): 평균(오프셋), \(\sigma\): 표준편차(세기).  
- **그레이스케일 노이즈**: B/G/R 모두에 **같은** \(n\) 을 더해 색 변화 최소화(휘도 노이즈).  
- **채널별 노이즈**: B/G/R에 **각기 다른** \(n_b,n_g,n_r\) 적용(컬러 그레인).

### 1.2 소금&후추(Impulse, Salt & Pepper) 잡음
확률 \(p\) 로 픽셀을 **0(후추)** 또는 **255(소금)** 으로 치환:
\[
I' = \begin{cases}
0 & \text{with prob. } p_\text{pepper} \\
255 & \text{with prob. } p_\text{salt} \\
I & \text{with prob. } 1 - p_\text{salt} - p_\text{pepper}
\end{cases}
\]
- **밀도(density)** \(d=p_\text{salt}+p_\text{pepper}\), **소금비율** \(r=p_\text{salt}/d\).  
- 기본값: \(d=0.02\) (2%), \(r=0.5\) (소금/후추 반반).  
- 컬러에서 실제 임펄스 느낌을 위해 **픽셀 단위**로 B/G/R 동시에 치환(기본). 필요시 채널별 모드 지원.

---

## 2. 잡음 주입 코어 구현

- 시드(정수)로 **재현성** 보장. `seed=0`이면 `std::random_device` 로 비결정 랜덤.  
- **클램프**(0~255) 보장.  
- **알파 채널 보존**.

```cpp
// Noise.h
#pragma once
#include <random>
#include <cstdint>
#include <algorithm>
#include "IppDib.h"

// ---------- 공통 유틸 ----------
inline uint8_t clamp_u8_int(int v) { return (uint8_t)std::min(255, std::max(0, v)); }
inline int     clamp255(int v)     { return v<0?0:(v>255?255:v); }
inline int     to_int(uint8_t u)   { return (int)u; }

// ---------- RNG 헬퍼 ----------
struct NoiseRNG {
    std::mt19937_64 eng;
    explicit NoiseRNG(uint64_t seed) {
        if (seed==0) {
            std::random_device rd;
            std::seed_seq seq{ rd(), rd(), rd(), rd() };
            eng.seed(seq);
        } else {
            eng.seed(seed);
        }
    }
};

// =============================================================
// 2.1 가우시안 잡음
// modeGray=true  : 모든 채널에 '같은' n (휘도/그레이스케일 노이즈)
// modeGray=false : 채널별 독립 n_b, n_g, n_r (컬러 노이즈)
// mean: μ, sigma: σ
// =============================================================
inline void AddGaussianNoise_BGRA32(IppDib& img, double mean, double sigma,
                                    bool modeGray, uint64_t seed)
{
    if (!img || sigma<=0.0) return;

    NoiseRNG rng(seed);
    std::normal_distribution<double> norm(mean, sigma);

    const int W=img.width(), H=img.height(), stride=img.stride();
    for (int y=0; y<H; ++y) {
        uint8_t* row = (uint8_t*)img.bits() + (size_t)y*stride;
        for (int x=0; x<W; ++x) {
            uint8_t* p = &row[x*4];
            const int B=to_int(p[0]), G=to_int(p[1]), R=to_int(p[2]);
            if (modeGray) {
                int n = (int)std::lround(norm(rng.eng));
                p[0] = clamp_u8_int(B + n);
                p[1] = clamp_u8_int(G + n);
                p[2] = clamp_u8_int(R + n);
            } else {
                int nb = (int)std::lround(norm(rng.eng));
                int ng = (int)std::lround(norm(rng.eng));
                int nr = (int)std::lround(norm(rng.eng));
                p[0] = clamp_u8_int(B + nb);
                p[1] = clamp_u8_int(G + ng);
                p[2] = clamp_u8_int(R + nr);
            }
            // alpha 보존
        }
    }
}

// =============================================================
// 2.2 소금&후추 잡음
// density d ∈ [0,1], saltRatio r ∈ [0,1] (p_salt=d*r, p_pepper=d*(1-r))
// applyPerChannel=true  : 채널별로 독립 치환(컬러 임펄스)
// applyPerChannel=false : 픽셀 단위로 B/G/R 동시에 치환(기본)
// =============================================================
inline void AddSaltPepperNoise_BGRA32(IppDib& img, double density, double saltRatio,
                                      bool applyPerChannel, uint64_t seed)
{
    if (!img || density<=0.0) return;
    density   = std::min(1.0, std::max(0.0, density));
    saltRatio = std::min(1.0, std::max(0.0, saltRatio));

    double pSalt   = density * saltRatio;
    double pPepper = density * (1.0 - saltRatio);

    NoiseRNG rng(seed);
    std::uniform_real_distribution<double> uni(0.0, 1.0);

    const int W=img.width(), H=img.height(), stride=img.stride();
    for (int y=0; y<H; ++y) {
        uint8_t* row = (uint8_t*)img.bits() + (size_t)y*stride;
        for (int x=0; x<W; ++x) {
            uint8_t* p = &row[x*4];
            if (applyPerChannel) {
                // B,G,R 각각 독립
                for (int c=0; c<3; ++c) {
                    double r = uni(rng.eng);
                    if (r < pSalt)      p[c] = 255;
                    else if (r < pSalt + pPepper) p[c] = 0;
                    // else unchanged
                }
            } else {
                // 픽셀 단위 공동 치환
                double r = uni(rng.eng);
                if (r < pSalt) {
                    p[0]=p[1]=p[2]=255;
                } else if (r < pSalt + pPepper) {
                    p[0]=p[1]=p[2]=0;
                }
            }
            // alpha 보존
        }
    }
}
```

---

## 3. 잡음 추가 대화 상자(UI)

- **Noise Type**: Gaussian / Salt & Pepper  
- **Gaussian**: mean(μ), sigma(σ), **Gray vs Channel** 모드, **Seed**  
- **Salt&Pepper**: density(d), saltRatio(r), **Per-Channel** 여부, **Seed**  
- **Randomize** 버튼: seed를 `random_device` 로 갱신  
- OK 시 **현재 창에 적용**(Undo 스택을 쓰는 프로젝트라면 거기에 push)

### 3.1 리소스 정의

```cpp
// resource.h (추가)
#define IDD_NOISE_DIALOG            800

// Type
#define IDC_RAD_NOISE_GAUSS         1801
#define IDC_RAD_NOISE_SP            1802

// Gaussian
#define IDC_EDIT_G_MEAN             1811
#define IDC_EDIT_G_SIGMA            1812
#define IDC_CHK_G_GRAY              1813  // Gray noise (same n on BGR)
#define IDC_EDIT_G_SEED             1814
#define IDC_BTN_G_RAND              1815

// Salt & Pepper
#define IDC_EDIT_SP_DENS            1821
#define IDC_EDIT_SP_RATIO           1822
#define IDC_CHK_SP_PERCHAN          1823
#define IDC_EDIT_SP_SEED            1824
#define IDC_BTN_SP_RAND             1825

// 메뉴
#define ID_IMAGE_NOISE_DIALOG       53010
```

```rc
// ImageTool.rc (추가)
IDD_NOISE_DIALOG DIALOGEX 0,0, 300, 190
STYLE DS_SETFONT | DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENU
CAPTION "Add Noise"
FONT 9, "Segoe UI"
BEGIN
    GROUPBOX "Type", -1, 8, 8, 70, 42
    AUTORADIOBUTTON "Gaussian", IDC_RAD_NOISE_GAUSS, 14, 22, 56, 10, WS_TABSTOP
    AUTORADIOBUTTON "Salt&Pepper", IDC_RAD_NOISE_SP, 14, 36, 56, 10

    GROUPBOX "Gaussian", -1, 84, 8, 206, 68
    LTEXT "mean:", -1, 92, 22, 28, 10
    EDITTEXT IDC_EDIT_G_MEAN, 122, 20, 36, 14, ES_AUTOHSCROLL
    LTEXT "sigma:", -1, 162, 22, 28, 10
    EDITTEXT IDC_EDIT_G_SIGMA, 194, 20, 36, 14, ES_AUTOHSCROLL
    AUTOCHECKBOX "Gray noise", IDC_CHK_G_GRAY, 92, 40, 60, 12
    LTEXT "seed:", -1, 156, 40, 24, 10
    EDITTEXT IDC_EDIT_G_SEED, 186, 38, 44, 14, ES_NUMBER
    PUSHBUTTON "Randomize", IDC_BTN_G_RAND, 198, 56, 54, 14

    GROUPBOX "Salt & Pepper", -1, 84, 80, 206, 68
    LTEXT "density(0..1):", -1, 92, 94, 64, 10
    EDITTEXT IDC_EDIT_SP_DENS, 160, 92, 30, 14, ES_AUTOHSCROLL
    LTEXT "salt ratio(0..1):", -1, 92, 112, 68, 10
    EDITTEXT IDC_EDIT_SP_RATIO, 160, 110, 30, 14, ES_AUTOHSCROLL
    AUTOCHECKBOX "Per-channel", IDC_CHK_SP_PERCHAN, 92, 128, 60, 12
    LTEXT "seed:", -1, 156, 128, 24, 10
    EDITTEXT IDC_EDIT_SP_SEED, 186, 126, 44, 14, ES_NUMBER
    PUSHBUTTON "Randomize", IDC_BTN_SP_RAND, 198, 144, 54, 14

    DEFPUSHBUTTON "OK", IDOK, 170, 160, 50, 16
    PUSHBUTTON    "Cancel", IDCANCEL, 230, 160, 50, 16
END

// 메뉴 (일부)
POPUP "&Image"
BEGIN
    POPUP "Noise"
    BEGIN
        MENUITEM "Add Noise...\tCtrl+N", ID_IMAGE_NOISE_DIALOG
    END
END

IDR_ACCEL ACCELERATORS
BEGIN
    "N", ID_IMAGE_NOISE_DIALOG, VIRTKEY, CONTROL
END
```

### 3.2 대화 상자 로직

```cpp
// NoiseDlg.h
#pragma once
#include <windows.h>
#include <string>
#include <random>
#include "resource.h"
#include "Noise.h"

class NoiseDlg {
public:
    NoiseDlg(HWND owner, IppDib& dib) : owner_(owner), dib_(dib) {}
    INT_PTR DoModal();

private:
    static INT_PTR CALLBACK DlgProc(HWND h, UINT m, WPARAM w, LPARAM l);
    INT_PTR OnInit(HWND h);
    INT_PTR OnCommand(HWND h, WPARAM w, LPARAM l);

    double ReadDouble(HWND h, int id, double def) const;
    uint64_t ReadSeed(HWND h, int id, uint64_t def) const;
    void WriteSeed(HWND h, int id, uint64_t seed) const;
    uint64_t RandomSeed() const;

private:
    HWND   owner_ = nullptr;
    IppDib& dib_;
};
```

```cpp
// NoiseDlg.cpp
#include "NoiseDlg.h"

INT_PTR NoiseDlg::DoModal() {
    return DialogBoxParamW(GetModuleHandleW(nullptr), MAKEINTRESOURCEW(IDD_NOISE_DIALOG),
                           owner_, DlgProc, (LPARAM)this);
}
INT_PTR CALLBACK NoiseDlg::DlgProc(HWND h, UINT m, WPARAM w, LPARAM l) {
    if (m==WM_INITDIALOG) {
        SetWindowLongPtrW(h, GWLP_USERDATA, l);
        auto* self=(NoiseDlg*)l; return self->OnInit(h);
    }
    auto* self=(NoiseDlg*)GetWindowLongPtrW(h, GWLP_USERDATA);
    if (!self) return FALSE;
    switch (m) {
    case WM_COMMAND: return self->OnCommand(h, w, l);
    default: return FALSE;
    }
}

INT_PTR NoiseDlg::OnInit(HWND h) {
    // 기본: Gaussian
    CheckRadioButton(h, IDC_RAD_NOISE_GAUSS, IDC_RAD_NOISE_SP, IDC_RAD_NOISE_GAUSS);
    SetDlgItemTextW(h, IDC_EDIT_G_MEAN,  L"0.0");
    SetDlgItemTextW(h, IDC_EDIT_G_SIGMA, L"10.0"); // 8-bit 권장 시작점
    CheckDlgButton(h, IDC_CHK_G_GRAY, BST_CHECKED);
    SetDlgItemTextW(h, IDC_EDIT_G_SEED, L"0");     // 0=랜덤

    SetDlgItemTextW(h, IDC_EDIT_SP_DENS,  L"0.02");
    SetDlgItemTextW(h, IDC_EDIT_SP_RATIO, L"0.5");
    CheckDlgButton(h, IDC_CHK_SP_PERCHAN, BST_UNCHECKED);
    SetDlgItemTextW(h, IDC_EDIT_SP_SEED,  L"0");
    return TRUE;
}

double NoiseDlg::ReadDouble(HWND h, int id, double def) const {
    wchar_t buf[64]; GetDlgItemTextW(h, id, buf, 64);
    wchar_t* e=nullptr; double v=wcstod(buf, &e);
    if (e==buf) return def; return v;
}
uint64_t NoiseDlg::ReadSeed(HWND h, int id, uint64_t def) const {
    BOOL ok=FALSE; UINT v=(UINT)GetDlgItemInt(h, id, &ok, FALSE);
    if (!ok) return def; return (uint64_t)v;
}
void NoiseDlg::WriteSeed(HWND h, int id, uint64_t seed) const {
    wchar_t buf[32]; swprintf(buf, 32, L"%llu", (unsigned long long)seed);
    SetDlgItemTextW(h, id, buf);
}
uint64_t NoiseDlg::RandomSeed() const {
    std::random_device rd; return ((uint64_t)rd()<<32) ^ rd();
}

INT_PTR NoiseDlg::OnCommand(HWND h, WPARAM w, LPARAM) {
    switch (LOWORD(w)) {
    case IDC_BTN_G_RAND:
        WriteSeed(h, IDC_EDIT_G_SEED, RandomSeed());
        return TRUE;
    case IDC_BTN_SP_RAND:
        WriteSeed(h, IDC_EDIT_SP_SEED, RandomSeed());
        return TRUE;

    case IDOK: {
        if (IsDlgButtonChecked(h, IDC_RAD_NOISE_GAUSS)==BST_CHECKED) {
            double mean  = ReadDouble(h, IDC_EDIT_G_MEAN, 0.0);
            double sigma = ReadDouble(h, IDC_EDIT_G_SIGMA, 10.0);
            bool   gray  = (IsDlgButtonChecked(h, IDC_CHK_G_GRAY)==BST_CHECKED);
            uint64_t seed= ReadSeed(h, IDC_EDIT_G_SEED, 0);
            AddGaussianNoise_BGRA32(dib_, mean, sigma, gray, seed);
            EndDialog(h, IDOK);
            return TRUE;
        } else {
            double density   = ReadDouble(h, IDC_EDIT_SP_DENS,  0.02);
            double saltRatio = ReadDouble(h, IDC_EDIT_SP_RATIO, 0.5);
            bool perChan     = (IsDlgButtonChecked(h, IDC_CHK_SP_PERCHAN)==BST_CHECKED);
            uint64_t seed    = ReadSeed(h, IDC_EDIT_SP_SEED, 0);
            AddSaltPepperNoise_BGRA32(dib_, density, saltRatio, perChan, seed);
            EndDialog(h, IDOK);
            return TRUE;
        }
    }
    case IDCANCEL:
        EndDialog(h, IDCANCEL);
        return TRUE;
    }
    return FALSE;
}
```

---

## 4. 잡음 추가 메뉴/이벤트 연동

```cpp
// main_multiwin.cpp (발췌)
#include "NoiseDlg.h"

// ...
case ID_IMAGE_NOISE_DIALOG:
    if (st && st->dib) {
        NoiseDlg dlg(hWnd, st->dib);
        if (dlg.DoModal()==IDOK) {
            InvalidateRect(hWnd, nullptr, FALSE);
            OutputBasicInfo(st);
            UpdateStatusBasic(hWnd, st);
        }
    }
    return 0;
```

---

## 5. 실전 예제 & 상황

### 상황 A) 영화 필름 그레인 느낌 만들기 (가우시안, 그레이 모드)
- **입력**: 컬러 풍경 사진(디지털 느낌이 너무 깨끗).  
- **동작**: `Noise → Add Noise…` → **Gaussian**, mean=0, sigma=6~10, **Gray noise 체크**.  
- **결과**: 휘도 기반의 미세 그레인으로 필름 같은 질감. 색번짐이 거의 없음.

### 상황 B) 저조도 촬영 시뮬레이션 (가우시안, 채널별)
- **입력**: 실내 정물 사진(밝음).  
- **동작**: Gaussian, mean=0, sigma=12~18, Gray 체크 해제(채널별).  
- **결과**: 컬러 그레인이 섞여 더 거친 저조도 감성. 후처리(가우시안 블러 σ≈0.6)로 살짝 스무딩.

### 상황 C) 문서 스캔 오류 재현 (Salt&Pepper, 픽셀 단위)
- **입력**: 이진화 전 흑백 문서.  
- **동작**: S&P, density=0.01~0.03, saltRatio=0.5, **Per-channel 해제**.  
- **결과**: 흰 점(소금)/검은 점(후추) 노이즈가 산발적으로 발생. **미디언 필터**로 복원 실습에 적합.

### 상황 D) 센서 핫픽셀/데드픽셀 시뮬레이션 (Salt&Pepper, Per-channel)
- **입력**: 야경 사진.  
- **동작**: S&P, density=0.002~0.005, saltRatio≈0.8, **Per-channel 체크**.  
- **결과**: 별처럼 보이는 화이트 임펄스 발생. 그린/블루 채널만 튀는 픽셀도 자연스럽게 재현.

---

## 6. 파라미터 가이드 & 주의점

- **가우시안 sigma**: 8-bit 기준 4~20가 실용 범위. 너무 크면 디테일이 묻힘.  
- **Gray vs Channel**:  
  - **Gray**: 색 균형 유지, 휘도만 요동 → 자연스러운 그레인.  
  - **Channel**: 컬러 노이즈(ISO 높은 사진 느낌).  
- **S&P density**: 0.005(0.5%)만 넘어도 꽤 눈에 띎.  
- **S&P per-channel**: 사실적이지만 **컬러 점**이 튀어 보일 수 있음. 문서/흑백에선 **픽셀 단위** 권장.  
- **시드**: 테스트 재현성 필요 시 고정(seed≠0), 랜덤 효과 원하면 0 또는 Randomize.  
- **알파 채널**: 본 구현은 A를 보존. 합성 파이프라인에 따라 프리멀티플라이 고려 가능.  
- **성능**: 전 픽셀 루프 \(O(WH)\). 가우시안은 난수 1~3회/픽셀 생성(Gray=1회, Channel=3회). S&P는 균일분포 1회(픽셀 단위)~3회(채널 단위).

---

## 7. 검증/테스트 체크리스트

- [ ] 동일 시드로 **동일 결과** 재현되는지  
- [ ] sigma/density/ratio 변경 시 **체감 변화**가 직관적인지  
- [ ] Gray/Per-channel 토글이 **색감 변화**에 미치는 영향 확인  
- [ ] 큰 이미지(예: 6K)에서 **프레임 드롭/프리징** 없는지  
- [ ] Undo/Redo를 사용하는 경우 커맨드 스택과 연동되는지

---

## 8. 수학 메모

- 정규 분포(가우시안) PDF:
\[
f(n)=\frac{1}{\sqrt{2\pi}\sigma}\exp\!\left(-\frac{(n-\mu)^2}{2\sigma^2}\right)
\]
- Box–Muller(참고): 두 균일 \(u_1,u_2\sim \mathcal{U}(0,1)\)로
\[
z_1 = \sqrt{-2\ln u_1}\cos(2\pi u_2),\quad
z_2 = \sqrt{-2\ln u_1}\sin(2\pi u_2)
\]
\(\Rightarrow z_{1,2}\sim\mathcal{N}(0,1)\). (실제 구현은 `std::normal_distribution` 사용)

---

## 9. 확장 아이디어

- **포아송(Poisson) 잡음**(광자 카운트 기반) · **스페클(Speckle)**(곱셈 잡음)  
- **카메라 모델**: \(\alpha\sqrt{I} + \beta\) 형태의 신호의존(heteroscedastic) 노이즈  
- **노이즈 맵 생성 후 합성**: 노이즈 영상 별도 생성 → 마스킹/영역별 강도 차등  
- **미리보기(Preview)**: 슬라이더/시드 변경 시 즉시 적용(원본 백업 + 디바운스)  
- **노이즈 제거 학습용 세트**: 시드/파라미터 고정으로 Pair(깨끗/오염) 자동 생성

---

## 10. 요약

- **Gaussian**: 평균/표준편차, 채널/그레이 모드, 시드 → 연속형 잡음.  
- **Salt & Pepper**: 밀도/소금비율, 픽셀/채널 모드, 시드 → 임펄스 잡음.  
- **대화 상자/메뉴**로 손쉽게 주입 · 테스트 · 학습 데이터 제작까지 가능.
