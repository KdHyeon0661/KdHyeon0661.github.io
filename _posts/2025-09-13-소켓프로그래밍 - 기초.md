---
layout: post
title: 소켓프로그래밍 - 기초
date: 2025-09-13 22:25:23 +0900
category: 소켓프로그래밍
---
# 프롤로그 — 왜 '저수준 소켓'인가

## 1. 이 글의 전체 목표와 학습 지도

### 1.1 왜 '‘'저수준(low-level) 소켓'부터 시작하는가

고수준 라이브러리/프레임워크(Boost.Asio, gRPC, HTTP/REST 프레임워크 등)는 네트워킹의 **80%**를 감춰준다.

- 연결 수립/종료, 재시도, 타임아웃, 쓰레드 풀, 이벤트 루프, TLS까지 한 번에 제공한다.
- 코드도 훨씬 짧고, 생산성이 좋다.

하지만 **실전 운영**에서 문제는 남은 **20%**에서 터진다.

- “왜 지연(latency)이 갑자기 튀지?”  
- “왜 CPU는 남는데 QPS가 안 올라가지?”  
- “왜 `send()`는 성공인데 상대는 데이터를 못 받았다고 할까?”  
- “왜 서버는 멀쩡해 보이는데 클라이언트는 타임아웃이 날까?”  

이 20%는 결국 **커널 내부 상태**와 **TCP 스택 동작**을 이해해야 한다.

저수준 소켓을 직접 다루면, 다음 질문들을 스스로 검증할 수 있다.

- “`send()`는 곧바로 **네트워크로** 나가는가?”
  - **아니다.** 먼저 **커널 송신 버퍼**로 들어간다. 네트워크로 나가는 시점은 **커널/ NIC /혼잡 제어**가 결정한다.
- “TCP는 메시지 경계를 보장하는가?”
  - **아니다.** TCP는 **바이트 스트림**이다. **프레이밍(framing)** 은 애플리케이션의 책임이다.
- “느린 수신자/혼잡 시 어떤 현상이 보이는가?”
  - **윈도우 축소, 재전송, 지연 증가, 큐 길이 증가(Recv-Q/Send-Q)** 로 나타난다.  
    이것을 `ss`, `tcpdump`, `Wireshark`, `strace` 로 직접 확인해야 한다.

> **철학**: “모르면 **관측**한다.”  
> 모든 이론은 **패킷 / 시스템 콜 / 큐 길이 / 버퍼 사용량**으로 검증한다.

---

### 1.2 이 프롤로그에서 다루는 것과 앞으로 이어질 내용

이 프롤로그에서는:

1. **사용자 공간 ↔ 시스템 콜 ↔ 커널 ↔ NIC ↔ 네트워크**의 큰 그림
2. “패킷”과 “스트림”의 차이, 그리고 **프레이밍의 필연성**
3. `send()` / `recv()` 가 실제로 하는 일 (커널 버퍼, 백프레셔)
4. **C++23 + POSIX** 기반 **초소형 서버/클라이언트** 코드
5. `tcpdump` / Wireshark / `ss` / `strace` 로 **직접 눈으로 네트워크를 보는 법**
6. BDP/처리량 직관 수식과, **작은 메시지 빈발 → Nagle/지연 ACK** 문제

그리고 **다음 장**들에서는:

- `std::expected` + `std::span<std::byte>` + RAII로 **I/O 레이어 정리**
- **길이-프리픽스 프레이밍**을 라이브러리로 정식화(`send_frame`, `recv_frame`)
- 타임아웃/논블로킹/epoll + 멀티스레드 + TLS로 확장

으로 이어진다.

---

## 2. 운영체제 관점의 큰 그림: User ↔ Kernel ↔ NIC ↔ Network

### 2.1 계층 구조를 머리에 그리기

아주 거칠게 줄이면, 다음 그림 하나로 요약할 수 있다.

```text
[사용자 공간 프로세스]
    |  (read/write, send/recv, connect, accept)
    v
[시스템 콜 인터페이스]
    v
[커널 공간]
    ├─ 소켓 테이블 (TCP/UDP 상태, 버퍼)
    ├─ 라우팅 테이블
    ├─ TCP/IP 스택 (flow control, congestion control)
    └─ NIC 드라이버
        v
    [NIC 하드웨어] <----> [스위치/라우터/인터넷] ...
```

- **사용자 공간(User space)**: C++ 코드가 돌아가는 영역.
- **시스템 콜(syscall)**: `send()`, `recv()`, `connect()`, `accept()` 등.
- **커널(Kernel)**: 소켓 테이블(TCB), 버퍼, 라우팅, TCP/UDP 스택이 존재.
- **NIC(Network Interface Card)**: 실제 전기/광 신호가 드나드는 곳.

네트워크를 제대로 이해하려면:

- “**코드가 호출하는 함수**”만 보지 말고
- “**그 함수가 커널 안에서 무엇을 바꾸는지**”를 봐야 한다.

---

### 2.2 소켓(socket)은 무엇인가: 파일 디스크립터로서의 엔드포인트

유닉스 철학에서 **대부분의 I/O 객체는 파일 디스크립터(fd)** 로 표현된다.

- 정규 파일, 파이프, 터미널, 소켓… 모두 fd 하나로 접근한다.
- 그래서 `read`, `write`, `close` 가 소켓에도 그대로 동작한다.

TCP 소켓은:

- **커널이 관리하는 “통신 끝점(endpoint)”** 에 대한 핸들이다.
- 이 끝점에는:
  - 로컬 IP/포트
  - 원격 IP/포트
  - 송·수신 버퍼
  - 상태(ESTABLISHED, LISTEN, TIME_WAIT, CLOSE_WAIT, …)
  - 타이머(RTO, keepalive, …)
- 등의 정보가 붙어 있다.

코드에서는 그저 `int fd`로 보이지만:

- `fd`는 커널 내부의 **거대한 구조체**에 대한 인덱스일 뿐이다.

---

## 3. `send()`는 정확히 무엇을 하는가 — 커널 송신 버퍼와 백프레셔

### 3.1 “send 성공 = 상대가 받았다”가 아니다

`send()`의 일반적인 시그니처(POSIX):

```c
ssize_t send(int sockfd, const void *buf, size_t len, int flags);
```

정상적인 반환:

- 양수 `n > 0`: **buf[0..n-1]** 바이트를 **커널 송신 버퍼에 적재**(enqueue).
- **상대가 읽었는지 여부**는 전혀 모른다.
- 심지어 **커널이 아직 NIC로 내보내지 않았다** 해도 `send`는 성공할 수 있다.

즉, `send()` 성공은:

- “내가 요청한 바이트 중 일부(혹은 전부)를 **커널 송신 큐에 올려두는 데 성공했다**”는 뜻일 뿐이다.

### 3.2 즉석 실험: 읽지 않는 서버 vs 계속 쓰는 클라이언트

다음과 같은 실험을 해보자.

#### 3.2.1 서버 — 데이터를 **읽지 않는** TCP 서버

```cpp
// slow_server.cpp — 연결만 받아놓고, 일부러 읽지 않는다.
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cstring>
#include <iostream>

int main() {
    addrinfo hints{}, *res=nullptr;
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG;

    if (getaddrinfo(nullptr, "9001", &hints, &res) != 0) {
        std::perror("getaddrinfo");
        return 1;
    }

    int s = -1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        int yes=1;
        ::setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(yes));
        if (::bind(s,ai->ai_addr,ai->ai_addrlen)==0 &&
            ::listen(s,128)==0) break;
        ::close(s); s=-1;
    }
    freeaddrinfo(res);
    if (s<0) {
        std::cerr << "listen fail\n";
        return 2;
    }

    std::cout << "[server] listening on 9001\n";
    int c = ::accept(s,nullptr,nullptr);
    if (c<0) {
        std::perror("accept");
        return 3;
    }
    std::cout << "[server] accepted, but will not read()\n";

    // 핵심: 여기서 read/recv를 전혀 호출하지 않는다.
    // 단지 sleep으로 버틴다.
    while (true) {
        ::sleep(1);
    }
}
```

#### 3.2.2 클라이언트 — 큰 버퍼를 계속 send()

```cpp
// sender.cpp — 서버가 읽지 않는 상황에서 계속 send()
// 빌드: g++ -std=c++23 sender.cpp -o sender
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <vector>
#include <iostream>
#include <cstring>

int main() {
    addrinfo hints{}, *res=nullptr;
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    if (getaddrinfo("127.0.0.1", "9001", &hints, &res) != 0) {
        std::perror("getaddrinfo");
        return 1;
    }
    int s=-1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        if (::connect(s, ai->ai_addr, ai->ai_addrlen)==0) break;
        ::close(s); s=-1;
    }
    freeaddrinfo(res);
    if (s<0) {
        std::cerr << "connect fail\n";
        return 2;
    }

    std::cout << "[client] connected, start sending...\n";
    std::vector<char> buf(1024*1024, 'X'); // 1MB
    size_t total = 0;
    while (true) {
        ssize_t n = ::send(s, buf.data(), buf.size(), 0);
        if (n > 0) {
            total += (size_t)n;
            std::cout << "sent=" << n << " total=" << total << "\n";
        } else if (n == 0) {
            std::cout << "send returned 0 (rare)\n";
            break;
        } else {
            std::perror("send");
            break;
        }
    }
    ::close(s);
    return 0;
}
```

실행 순서:

```bash
# 터미널 1
g++ -std=c++23 slow_server.cpp -o slow_server
./slow_server

# 터미널 2
g++ -std=c++23 sender.cpp -o sender
./sender
```

관측:

- 처음에는 `send()`가 큰 버퍼를 잘 받아준다.
- 어느 순간부터:
  - **블로킹 소켓**이면 `send()`에서 **오랫동안 반환되지 않거나**,
  - **논블로킹** 소켓이면 `-1`과 함께 `EAGAIN` / `EWOULDBLOCK` 이 발생한다.

이것은:

- 서버가 `recv`를 호출하지 않아서 **서버 수신 버퍼가 꽉 찼고**,  
- TCP 윈도우/혼잡 제어로 인해 클라이언트 송신 버퍼까지 가득 차서  
- 더 이상 데이터를 넣을 수 없는 상황이 된 것이다.

즉, 이것이 **백프레셔(backpressure)** 이다.

---

### 3.3 Send-Q / Recv-Q를 `ss`로 함께 관측하기

위 실험을 할 때, 별도 터미널에서:

```bash
ss -tanp '( sport = :9001 or dport = :9001 )'
```

를 반복해서 보면:

- `Recv-Q`: 해당 소켓의 **수신 큐 길이**(커널 버퍼 기준)
- `Send-Q`: 해당 소켓의 **송신 큐 길이**

서버/클라이언트 양쪽에서:

- `Recv-Q`가 증가하고 `Send-Q`가 변하는 모습을 볼 수 있다.
- 서버가 `recv`를 하지 않으면 서버 측 `Recv-Q`는 **계속 증가**하다 어느 지점에서 포화.
- 그 후에는 **클라이언트** 입장에서 `send()`가 막히기 시작한다.

이 과정을 직접 관측하면:

- “TCP가 **흐름 제어**와 **혼잡 제어**를 통해 **전송량을 조절**한다”는 말을 **눈으로 이해할 수 있다.**

---

## 4. “패킷”과 “스트림”의 차이, 그리고 프레이밍의 필연성

### 4.1 용어 정리: 패킷 vs 스트림

**패킷(packet)**:

- 계층에 따라 Frame / Packet / Segment / Datagram이라고 나뉘지만,
- 흔히 `tcpdump`/Wireshark에서 보이는 **전송 단위**를 통칭해서 “패킷”이라 부른다.
- 예:
  - 이더넷 프레임
  - IP 패킷
  - TCP 세그먼트
  - UDP 데이터그램

**스트림(stream, TCP)**:

- 응용 프로그램 입장에서는 단순히 **“연속된 바이트”** 이다.
- “몇 바이트씩 끊겨 들어오는지”는 OS/네트워크의 상황에 따라 달라진다.
- TCP는 **바이트 순서**만 보장할 뿐, **메시지 경계**는 보장하지 않는다.

### 4.2 예제 시나리오 — 같은 메시지, 서로 다른 수신 패턴

클라이언트 코드:

```cpp
const char* msg = "HELLO-WORLD"; // 11 bytes
::send(fd, msg, 11, 0);
```

수신 측에서:

```cpp
char buf[1024];

// 1차 호출
ssize_t n1 = ::recv(fd, buf, sizeof(buf), 0);
// 2차 호출
ssize_t n2 = ::recv(fd, buf + n1, sizeof(buf)-n1, 0);
```

**가능한 다양한 패턴**들:

1. 한 번에 다 받는 경우
   - `n1 = 11`  
     → 첫 `recv`에서 `"HELLO-WORLD"`를 모두 받음.
2. 나눠 받는 경우
   - `n1 = 3`, `n2 = 8`  
     → `"HEL"`, `"LO-WORLD"`.
3. 더 나뉘는 경우:
   - `n1 = 1`, `n2 = 1`, `n3 = 9` …

반대로, 클라이언트가:

```cpp
send(fd, "HELLO-", 6, 0);
send(fd, "WORLD", 5, 0);
```

로 나눠 보내도,

- 수신 측에서는 **한 번의 `recv`** 에서 11바이트를 한꺼번에 받기도 한다.

**중요한 결론**:

- `send()` 호출 횟수와 `recv()`에서 실제로 끊겨 들어오는 경계는 **무관**하다.
- 그러므로 **“한 번의 send = 한 메시지”** 라는 가정은 **완전히 틀렸다**.
- TCP 스트림 위에는 **프레이밍(framing)** 이 반드시 필요하다.

---

### 4.3 길이-프리픽스(4B 빅엔디안) 프레이밍

가장 간단한 프레이밍 전략:

1. **헤더**: 4바이트 정수(네트워크 바이트 오더, 빅엔디안)로 **payload 길이**를 보낸다.
2. **바디**: 해당 길이만큼의 payload 바이트를 보낸다.
3. 수신자는:
   - 먼저 4바이트를 **정확히 N바이트** 읽고,
   - 그 뒤 payload를 **정확히 길이만큼** 읽는다.

C++23 관점에서 인터페이스는 대략 이렇게 둘 수 있다.

```cpp
std::expected<void, std::error_code>
send_frame(int fd, std::span<const std::byte> payload);

std::expected<std::vector<std::byte>, std::error_code>
recv_frame(int fd, std::size_t cap = (1u<<20)); // 기본 cap: 1MB
```

- `cap`은 **최대 허용 메시지 길이**:  
  악의적 입력(예: 길이 필드에 수 GB)을 방지하려면 필수다.

이 프레이밍에 기반한 구현 예시는 뒤에서 다시 자세히 다룬다.  
여기서는 “**TCP를 쓸 때는 이 정도 프레이밍이 기본**” 이라는 감각을 잡는 것이 중요하다.

---

### 4.4 지연·처리량 직관 수식

네트워크 튜닝에서 자주 쓰이는 직관 수식 두 개를 미리 적어두자.

1) **대역폭–지연곱(BDP, Bandwidth-Delay Product)**

$$
\text{BDP} = \text{Bandwidth} \times \text{RTT}
$$

- 단위 예:
  - Bandwidth: bits/s
  - RTT(Round-Trip Time): s
- BDP는 “파이프에 동시에 들어갈 수 있는 데이터 양” 정도로 이해할 수 있다.
- 송신/수신 버퍼와 윈도우 크기가 BDP보다 너무 작다면:
  - **링크를 가득 채우지 못해 처리량을 손해** 볼 수 있다.

2) **손실 환경에서의 TCP 처리량 근사(매우 거친 직관)**

$$
\text{Throughput} \approx \frac{\text{MSS}}{\text{RTT}\sqrt{p}}
$$

- \( \text{MSS} \): Maximum Segment Size
- \( p \): 패킷 손실 확률

이 식은 이론적 배경을 단순화한 근사지만:

- 손실이 늘거나 RTT가 커질수록 **처리량이 급격히 줄어든다**는 직관을 주기에 좋다.

---

## 5. 실습 환경 준비 — 리눅스 기준(툴체인, 관측 도구)

> 이 시리즈는 **리눅스**를 기준으로 한다. (Debian/Ubuntu/Fedora/RHEL/Arch 등)  
> macOS/BSD도 대부분 개념은 같지만, 일부 명령/옵션은 다를 수 있다.

### 5.1 컴파일러 & 빌드 툴 설치

```bash
# Debian/Ubuntu 예시

sudo apt update
sudo apt install -y build-essential clang clang-format lldb cmake git

# Fedora/RHEL/CentOS Stream

sudo dnf groupinstall -y "Development Tools"
sudo dnf install -y clang-tools-extra lldb cmake git

# 버전 확인

g++ --version
clang++ --version
cmake --version
```

- C++23 기능을 쓰려면:
  - GCC 13+ 또는 Clang 16+ 정도면 충분하다.
- 빌드 시에는:
  - `-std=c++23`
  - `-Wall -Wextra` 같은 경고 옵션을 권장.

### 5.2 패킷 관측 도구 설치

```bash
sudo apt install -y tcpdump wireshark
sudo usermod -aG wireshark $USER   # wireshark 캡처 권한 (재로그인 필요)
```

- **tcpdump**: CLI 패킷 캡처.
- **Wireshark**: GUI 패킷 분석.
- **추천 사용법**:
  - tcpdump로 먼저 `.pcap` 을 캡처 → Wireshark로 열어서 분석.

### 5.3 소켓/프로세스 관측 도구

```bash
sudo apt install -y iproute2 net-tools lsof strace
```

- `ss`: 소켓 상태/큐 길이/프로세스 관계를 보기 위해 필수.
- `lsof`: 포트를 잡고 있는 프로세스를 찾을 때.
- `strace`: 시스템 콜 단위로 `send`, `recv`, `accept`, `connect` 흐름을 추적.

### 5.4 기타 REPL/유틸

```bash
sudo apt install -y netcat-openbsd hexdump
```

- `nc`(netcat): 간단한 TCP/UDP 테스트에 유용.
- `hexdump`: 바이너리 데이터 덤프 확인용.

---

## 6. 초소형 C++23 실습: “보이고 만져지는” 최소 서버/클라이언트

> 목적: **부분 입출력 + 프레이밍**을 직접 코드로 보고,  
> `tcpdump`로 **실제 패킷 흐름**을 확인한다.

여기서는 프레이밍을 단순하게 구현한 **기초 버전**을 보여준다.  
다음 장에서는 이 구조를 **RAII + `std::span<std::byte>` + `std::expected`** 로 정돈한다.

---

### 6.1 서버 — 0.0.0.0:9000 바인드, 1프레임 받았다가 그대로 에코

```cpp
// server.cpp — 0.0.0.0:9000에 바인드, 프레이밍(4B length + payload)으로 1프레임 에코
// 빌드: g++ -std=c++23 -O2 server.cpp -o server

#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>

#include <cstdint>
#include <vector>
#include <span>
#include <cstring>
#include <iostream>

static bool recv_exact(int fd, void* p, size_t n) {
    auto* b = static_cast<std::byte*>(p);
    size_t got=0;
    while (got<n) {
        ssize_t r = ::recv(fd, b+got, n-got, 0);
        if (r <= 0) return false;      // 오류 or 연결 종료
        got += (size_t)r;
    }
    return true;
}

static bool send_all(int fd, const void* p, size_t n) {
    auto* b = static_cast<const std::byte*>(p);
    size_t sent=0;
    while (sent<n) {
        ssize_t w = ::send(fd, b+sent, n-sent, 0);
        if (w <= 0) return false;
        sent += (size_t)w;
    }
    return true;
}

int main() {
    addrinfo hints{}, *res=nullptr;
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    hints.ai_flags    = AI_PASSIVE | AI_ADDRCONFIG;

    if (getaddrinfo(nullptr, "9000", &hints, &res) != 0) {
        std::perror("getaddrinfo");
        return 1;
    }

    int s = -1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;
        int yes = 1;
        ::setsockopt(s, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes));
        if (::bind(s, ai->ai_addr, ai->ai_addrlen) == 0 &&
            ::listen(s, 128) == 0) {
            break;
        }
        ::close(s);
        s = -1;
    }
    freeaddrinfo(res);

    if (s < 0) {
        std::cerr << "listen fail\n";
        return 2;
    }

    std::cout << "[server] listen on 0.0.0.0:9000\n";

    for (;;) {
        int c = ::accept(s, nullptr, nullptr);
        if (c < 0) {
            std::perror("accept");
            continue;
        }

        std::cout << "[server] accepted\n";

        // 1) 길이(4B)
        uint32_t be = 0;
        if (!recv_exact(c, &be, 4)) {
            std::cerr << "[server] failed to read length\n";
            ::close(c);
            continue;
        }
        uint32_t len = ntohl(be);
        std::cout << "[server] length=" << len << "\n";

        // 안전을 위해 간단한 cap 예시 (16MB)
        if (len > 16u * 1024 * 1024) {
            std::cerr << "[server] too large frame, closing\n";
            ::close(c);
            continue;
        }

        // 2) payload
        std::vector<std::byte> buf(len);
        if (!recv_exact(c, buf.data(), buf.size())) {
            std::cerr << "[server] failed to read payload\n";
            ::close(c);
            continue;
        }

        // 3) 에코 (다시 length + payload)
        be = htonl(len);
        if (!send_all(c, &be, 4) ||
            !send_all(c, buf.data(), buf.size())) {
            std::cerr << "[server] failed to send echo\n";
            ::close(c);
            continue;
        }

        std::cout << "[server] echo done\n";
        ::close(c);
    }
}
```

---

### 6.2 클라이언트 — 127.0.0.1:9000로 1프레임 보내고 에코 받기

```cpp
// client.cpp — 127.0.0.1:9000로 메시지 1개 전송 후 에코 수신
// 빌드: g++ -std=c++23 -O2 client.cpp -o client

#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>

#include <cstdint>
#include <vector>
#include <string>
#include <iostream>
#include <cstring>

static bool send_all(int fd, const void* p, size_t n) {
    const char* b = static_cast<const char*>(p);
    size_t sent=0;
    while (sent<n) {
        ssize_t w = ::send(fd, b+sent, n-sent, 0);
        if (w <= 0) return false;
        sent += (size_t)w;
    }
    return true;
}

static bool recv_exact(int fd, void* p, size_t n) {
    char* b = static_cast<char*>(p);
    size_t got=0;
    while (got<n) {
        ssize_t r = ::recv(fd, b+got, n-got, 0);
        if (r <= 0) return false;
        got += (size_t)r;
    }
    return true;
}

int main(int argc, char** argv) {
    std::string msg = (argc >= 2) ? argv[1] : "hello-socket";

    addrinfo hints{}, *res=nullptr;
    hints.ai_family   = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    if (getaddrinfo("127.0.0.1", "9000", &hints, &res) != 0) {
        std::perror("getaddrinfo");
        return 1;
    }

    int s = -1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s < 0) continue;
        if (::connect(s, ai->ai_addr, ai->ai_addrlen) == 0) {
            break;
        }
        ::close(s);
        s = -1;
    }
    freeaddrinfo(res);

    if (s < 0) {
        std::cerr << "connect fail\n";
        return 2;
    }

    std::cout << "[client] connected to 127.0.0.1:9000\n";

    uint32_t len = static_cast<uint32_t>(msg.size());
    uint32_t be  = htonl(len);

    // 프레임 전송: length + payload
    if (!send_all(s, &be, 4) ||
        !send_all(s, msg.data(), msg.size())) {
        std::cerr << "[client] send failed\n";
        ::close(s);
        return 3;
    }

    // 에코 프레임 수신
    if (!recv_exact(s, &be, 4)) {
        std::cerr << "[client] failed to read length\n";
        ::close(s);
        return 4;
    }
    uint32_t elen = ntohl(be);
    std::string echo(elen, '\0');
    if (!recv_exact(s, echo.data(), echo.size())) {
        std::cerr << "[client] failed to read payload\n";
        ::close(s);
        return 5;
    }

    std::cout << "echo: " << echo << "\n";
    ::close(s);
    return 0;
}
```

---

### 6.3 실행과 관찰

#### 6.3.1 서버/클라이언트 실행

```bash
# 터미널 1
g++ -std=c++23 -O2 server.cpp -o server
./server

# 터미널 2
g++ -std=c++23 -O2 client.cpp -o client
./client "HELLO-WORLD"
```

예상 출력:

- 클라이언트:

```text
[client] connected to 127.0.0.1:9000
echo: HELLO-WORLD
```

- 서버:

```text
[server] listen on 0.0.0.0:9000
[server] accepted
[server] length=11
[server] echo done
```

여기서 중요한 점:

- TCP는 `"HELLO-WORLD"`를 한 번에 보장하지 않지만,
- **프레이밍 덕분에** 수신자가 **정확히 1메시지**를 복원했다는 것이다.

---

## 7. 패킷을 직접 보자 — tcpdump / Wireshark 실습

### 7.1 패킷 캡처 시작

루프백 인터페이스 이름은 배포판마다 다를 수 있다(`lo`, `lo0` 등).  
Linux에서 보통 `lo`를 쓴다.

```bash
sudo tcpdump -i lo tcp port 9000 -n -vv -w trace.pcap
```

옵션 설명:

- `-i lo` : 루프백 인터페이스
- `tcp port 9000` : 9000/TCP 트래픽만
- `-n` : 호스트/포트 이름 해석 생략
- `-vv` : verbose
- `-w trace.pcap` : 캡처를 파일로 저장

이 상태에서:

1. `./server` 실행
2. `./client "HELLO-WORLD"` 실행
3. 클라이언트 종료 후 tcpdump를 Ctrl+C로 멈춘다.

---

### 7.2 Wireshark에서 볼 포인트

`trace.pcap` 을 Wireshark로 열어 보면:

1. **3-way handshake**

   ```text
   1) Client → Server : SYN
   2) Server → Client : SYN, ACK
   3) Client → Server : ACK
   ```

2. **프레이밍 데이터**

   - 클라이언트 → 서버:
     - 4B 길이 헤더 + 11B "HELLO-WORLD"
       - 이게 한 세그먼트로 보일 수도 있고, 둘로 나뉠 수도 있다.
   - 서버 → 클라이언트:
     - 동일한 형식의 에코.

3. **연결 종료(4-way handshake)**

   ```text
   Client → Server : FIN, ACK
   Server → Client : ACK
   Server → Client : FIN, ACK
   Client → Server : ACK
   ```

상황에 따라 FIN/ACK가 합쳐져서 보일 수도 있고, 지연 ACK/나글 상호작용에 따라 패턴이 조금 달라질 수 있다.

여기서 핵심은:

- 패킷 레벨에서는 **TPDU(TCP 세그먼트)** 단위로 흐르지만,
- 응용 레벨에서는 단지 **“스트림 + 프레이밍”** 으로 처리한다는 것.

---

## 8. ss / lsof / strace로 커널 상태 들여다보기

### 8.1 ss — 소켓 상태 & 큐 길이 관찰

서버/클라가 동작 중일 때, 다른 터미널에서:

```bash
ss -tanp '( sport = :9000 or dport = :9000 )'
```

예시 출력(요지):

```text
State  Recv-Q  Send-Q  Local Address:Port   Peer Address:Port   Process
LISTEN 0       128     0.0.0.0:9000        0.0.0.0:*           users:(("server",pid=...,fd=3))
ESTAB  0       0       127.0.0.1:9000      127.0.0.1:54321     users:(("server",pid=...,fd=4))
ESTAB  0       0       127.0.0.1:54321     127.0.0.1:9000      users:(("client",pid=...,fd=3))
```

- `State`: LISTEN/ESTAB/TIME-WAIT 등.
- `Recv-Q` / `Send-Q`: 해당 소켓의 **수신/송신 큐 길이**(바이트 단위).
- `Process`: 해당 fd를 가진 프로세스.

앞에서 만든 “읽지 않는 서버” 실험에서:

- 서버가 `recv`를 호출하지 않으면:
  - 서버 소켓의 `Recv-Q`가 점점 커지는 것을 볼 수 있다.
- 반대로 클라이언트에서 계속 `send`하면:
  - 어느 순간 클라이언트 소켓의 `Send-Q`가 커지고 더 이상 증가하지 않는 지점에서 `send`가 막힌다.

---

### 8.2 lsof — 누가 포트를 열고 있는지

```bash
sudo lsof -iTCP:9000 -sTCP:LISTEN -n -P
```

예시:

```text
COMMAND  PID   USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
server   1234  user   3u   IPv4  ...   0t0     TCP *:9000 (LISTEN)
```

- 어떤 프로그램이 어떤 PID로 포트를 잡고 있는지 한눈에 볼 수 있다.
- `EADDRINUSE` 에러가 날 때 가장 먼저 확인할 도구다.

---

### 8.3 strace — 시스템 콜 레벨에서 I/O 흐름 보기

서버를 strace로 감싸면:

```bash
strace -f -e trace=network ./server
```

출력 예시(요지):

```text
socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP) = 3
setsockopt(3, SOL_SOCKET, SO_REUSEADDR, [1], 4) = 0
bind(3, ..., ...) = 0
listen(3, 128) = 0
accept(3, ..., ...) = 4
recv(4, ..., 4, 0) = 4
recv(4, ..., 11, 0) = 11
send(4, ..., 4, 0) = 4
send(4, ..., 11, 0) = 11
close(4) = 0
```

- 이를 통해:
  - `accept` → `recv` → `send` → `close` 흐름이 다 드러난다.
- 일부러 큰 메시지를 보냈을 때:
  - `recv`가 여러 번 나오는지,
  - `send`가 여러 번 나뉘는지 등을 관찰할 수 있다.

---

## 9. 프레이밍이 없을 때 터지는 문제 — 반례 실험

### 9.1 “라인 단위”로 처리하는 취약한 예

아주 단순하게:

- 클라이언트가 `"\n"`으로 끝나는 한 줄을 보낸다고 가정하고,
- 서버가 `read()` 또는 `recv()` 한 번으로 한 줄을 읽는다고 생각해 보자.

```cpp
// naive_line_server.cpp — 의도적으로 잘못된 예
#include <sys/socket.h>
#include <netdb.h>
#include <unistd.h>
#include <iostream>
#include <cstring>

int main() {
    // 바인드/리스닝 부분은 생략(앞의 server.cpp와 유사)
    // ...
    int c = ::accept(/*...*/);

    char buf[1024];
    ssize_t n = ::recv(c, buf, sizeof(buf), 0);
    if (n <= 0) {
        ::close(c);
        return 0;
    }

    // "한 번에 한 줄"을 다 받았다고 믿고 처리
    std::string line(buf, buf + n);
    std::cout << "line: " << line << "\n";
}
```

문제점:

1. **부분 수신**:
   - `recv`가 `"\n"` 이전까지 일부만 읽고 반환할 수 있다.
   - 그러면 `line`은 **불완전한 메시지**가 된다.
2. **결합 수신**:
   - 두 줄이 연달아 전송되었을 때,
   - `recv`가 두 줄을 한 번에 읽어버릴 수 있다.
   - 이 때 서버는 “한 줄”이라고 믿고 `line`을 처리하지만 사실은 **두 메시지**가 들어 있다.

이 문제를 해결하려면:

- **프레이밍 또는 스트림 파서**가 필요하다.
  - 예: 줄 단위 프로토콜이라면:
    - 수신 버퍼를 유지하면서
    - `'\n'`이 나올 때까지 반복해서 `recv`하고 조립해야 한다.

프레이밍 없는 TCP 처리 코드는 **언젠가는 경계 문제로 망가진다.**

---

## 10. 지연·처리량·버퍼 감각 더 자세히

### 10.1 BDP 예제로 보는 버퍼 크기 직관

예를 들어:

- 대역폭: 1 Gbps
- RTT: 50 ms

라고 하자.

$$
\text{BDP} = 1\,\text{Gbps} \times 0.05\,\text{s}
           = 50\,\text{Mbit}
           \approx 6.25\,\text{MB}
$$

의미:

- 송신 측에서 **6.25MB 정도**를 파이프에 채워놓을 수 있을 때
  - 링크를 충분히 활용할 수 있다.
- 송신 버퍼/수신 버퍼/윈도우 설정이 합쳐서 BDP보다 너무 작으면:
  - 실제 가능한 처리량에 도달하지 못할 수 있다.

물론 실제 세상에서는:

- 멀티플렉싱, 큐잉, 다른 트래픽, QoS, 중간 라우터의 버퍼 정책 등이 모두 영향을 주므로  
  이 수식은 **직관용**이다.

### 10.2 작은 메시지 딜레마와 Nagle/지연 ACK

수십~수백 바이트짜리 메시지를 매우 자주 보낼 때:

- **Nagle 알고리즘**:
  - 작은 세그먼트를 합쳐서 보내 효율 향상을 꾀한다.
  - 하지만 상호작용 서비스에서는 이 합치는 과정이 **지연**을 유발할 수 있다.
- **Delayed ACK**:
  - ACK를 바로 보내지 않고 약간 지연시켜,
  - 한 번에 묶어서 ACK를 보내도록 하는 메커니즘.
  - 역시 상호작용 지연에 영향을 준다.

두 메커니즘이 서로 상호작용하면:

- 왕복 시간보다 훨씬 큰 지연이 발생할 수 있다.

대응책:

1. **coalescing(배치 전송)**:
   - 애플리케이션 레벨에서 **여러 작은 메시지를 모아서** 한 번에 보내도록 설계.
2. **`TCP_NODELAY`로 Nagle 끄기**:
   - 지연을 줄이는 대신, 패킷 수가 많아질 수 있다(오버헤드 증가).

어느 쪽이든 **측정 기반**으로 결정해야 한다.

---

## 11. 이 프롤로그의 실전 과제

이 섹션은 단순 읽기가 아니라, 실제로 **손으로 실험해보면서** 감을 잡도록 돕기 위한 To-do 목록이다.

### 11.1 패킷 캡처 과제

1. `server.cpp` / `client.cpp` 를 사용하되,  
   클라이언트에서 전송하는 메시지를 다음과 같이 바꿔본다.
   - 10바이트
   - 1KB
   - 64KB
2. 각 경우에 대해:
   - `sudo tcpdump -i lo tcp port 9000 -n -vv -w trace_X.pcap`
   - Wireshark로 열어 패킷 분할 패턴을 비교해본다.
   - 특히:
     - 하나의 애플리케이션 프레임이
       - 한 세그먼트로 보내지는지
       - 여러 세그먼트로 나뉠 수 있는지 관찰.

### 11.2 부분 입출력 관측 과제

1. 서버 루프에서, payload 읽기 직후에 인위 지연을 넣는다.

   ```cpp
   // recv_exact 후
   usleep(20000); // 20ms
   ```

2. 클라이언트에서 여러 프레임을 빠르게 보내도록 수정한다.
3. `ss -tanp '( sport = :9000 or dport = :9000 )'` 를 반복 실행하여:
   - `Recv-Q` / `Send-Q`가 어떻게 변하는지 관찰한다.

### 11.3 라인 기반 반례 과제

1. 프레이밍을 제거한 “라인 기반 서버”를 만들고,
2. 클라이언트 두 개를 뜨워서 **교차로** 메시지를 보낸다.
3. 서버가 **메시지 경계를 어떻게 오해**하는지 직접 재현한다.
   - 예: “A\n”, “B\n” 이 섞여 “AB\nB\n” 처럼 보일 수도 있다.

### 11.4 Nagle 실험 과제

1. 작은 메시지를 고빈도로 전송하는 클라이언트/서버를 구현한다.
2. `setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, ...)` on/off 두 케이스를 비교한다.
3. 왕복 지연/처리량을 간단히 측정해본다(예: 타임스탬프 찍기).
4. 패킷 수와 크기를 `tcpdump`로 함께 관찰한다.

---

## 12. 요약 및 다음 단계 예고

이 프롤로그에서 정리한 핵심 포인트:

1. **저수준 소켓을 알아야 하는 이유**
   - 프레임워크가 감춰준 80% 덕분에 코드가 편해지지만,
   - 실전 문제는 나머지 20% (커널 버퍼, 흐름 제어, 혼잡, 타임아웃, 큐 길이) 에서 터진다.
   - 저수준을 이해하면, 프레임워크/라이브러리도 **안심하고** 쓸 수 있다.

2. **운영체제 관점 큰 그림**
   - User space ↔ syscalls ↔ Kernel ↔ NIC ↔ Network
   - 소켓은 커널이 가진 통신 엔드포인트에 대한 **fd 핸들**이다.

3. **send/recv의 실제 의미**
   - `send()` 성공은 “커널 송신 버퍼에 일부/전부 적재 성공”일 뿐,
   - 상대가 받았다는 뜻이 아니다.
   - 읽지 않는 서버 vs 계속 쓰는 클라이언트 실험에서 **백프레셔**를 직접 확인할 수 있다.

4. **패킷 vs 스트림, 프레이밍**
   - TCP는 **바이트 스트림**. 메시지 경계는 없다.
   - `send` 호출 횟수와 `recv`에서의 끊김은 독립이다.
   - **길이-프리픽스(4B 빅엔디안)** 프레이밍은 가장 단순하고 효과적인 기본 해법이다.

5. **관측 도구**
   - `tcpdump` / Wireshark: 패킷 레벨.
   - `ss` / `lsof`: 소켓 상태와 포트 소유자.
   - `strace`: 시스템 콜 레벨의 I/O 흐름.

6. **지연/처리량 직관**
   - BDP, 손실 기반 처리량 근사로 버퍼와 윈도우 크기의 감을 잡는다.
   - 작은 메시지 빈발 시 Nagle/Delayed ACK 상호작용을 고려해야 한다.

다음 장에서는 이 프롤로그에서 썼던 **simple server/client 코드**를:

- RAII(`unique_fd`),
- `std::span<std::byte>`,
- `std::expected<..., std::error_code>`,
- 안전한 `send_all` / `recv_exact` 구현,

으로 정식화하고, **프레이밍을 재사용 가능한 모듈**로 구조화한다.  
또한, **타임아웃 처리**와 **SIGPIPE 방어**, **에러 모델**을 명확히 정의한 뒤,  
논블로킹/epoll 기반 서버의 기본골로 연결해 나갈 것이다.

---

## 13. 부록 — 퀵 레퍼런스

### 13.1 tcpdump 명령 예시

```bash
sudo tcpdump -i any tcp port 9000 -n -vv
sudo tcpdump -i any "tcp[tcpflags] & (tcp-syn) != 0" -n
sudo tcpdump -i any -w trace.pcap
```

### 13.2 ss / strace / lsof 요약

```bash
# 9000/TCP 관련 소켓 보기
ss -tanp '( sport = :9000 or dport = :9000 )'

# 서버를 네트워크 콜만 strace
strace -f -e trace=network ./server

# 9000 포트를 잡고 있는 프로세스
sudo lsof -iTCP:9000 -sTCP:LISTEN -n -P
```

### 13.3 수식 스니펫

- 대역폭–지연곱(BDP):

  $$
  \text{BDP} = \text{Bandwidth} \times \text{RTT}
  $$

- 손실 환경 처리량(직관):

  $$
  \text{Throughput} \approx \frac{\text{MSS}}{\text{RTT}\sqrt{p}}
  $$

이 수식들은 정확한 예측 도구라기보다는,  
**버퍼·윈도우·손실·RTT가 처리량에 어떤 영향을 주는지**를 생각하기 위한 출발점이다.

---

이로써 **저수준 소켓** 시리즈의 프롤로그를 마친다.  
다음 글부터는 본격적으로 **C++23 코드 구조**와 **프레이밍 라이브러리**,  
그리고 `bind()/listen()/accept()/connect()` 의 의미를 운영체제 관점에서 파고들어갈 것이다.