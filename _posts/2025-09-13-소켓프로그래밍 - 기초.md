---
layout: post
title: 소켓프로그래밍 - 기초
date: 2025-09-13 22:25:23 +0900
category: 소켓프로그래밍
---
## 0. 프롤로그 — 왜 ‘저수준 소켓’인가

> 목표: **C++23 + POSIX 소켓**을 *운영체제 관점*에서 이해하고, **패킷(계층)**과 **스트림(소켓 I/O)**을 구분해 사고하는 습관을 만든다.  

---

### 0.1 블로그 목표와 학습 지도(입문 → 심화 → 운영/보안)

#### 0.1.1 왜 ‘저수준’부터인가
- 고수준 프레임워크(ASIO, gRPC, REST 프레임워크)는 **문제의 80%**를 감춰준다. 그러나 장애/성능/지연/타임아웃/커널 큐/혼잡 제어 같은 **나머지 20%**를 모르면 실전에서 멈춘다.
- **저수준 소켓**은 다음을 스스로 검증하게 한다.
  - “`send()`는 곧바로 **네트워크로** 나가는가?” → **아니다.** 먼저 **커널 송신 버퍼**로 들어간다.
  - “TCP는 메시지 경계를 보장하는가?” → **아니다.** TCP는 **바이트 스트림**이다. **프레이밍**은 애플리케이션 책임이다.
  - “느린 수신자/혼잡 시 어떤 현상이 보이는가?” → **윈도우 축소, 재전송, 지연 증가, 큐 상승**을 관측 도구로 확인해야 한다.

#### 0.1.2 이 시리즈의 학습 지도
- **입문(이 글 + 1~5편)**: 소켓의 본질, 블로킹 I/O, 부분 입출력, 프레이밍(길이-프리픽스), 주소 해석, 최소 에코 서버/클라.
- **심화(6~12편)**: 논블로킹, `poll`/`epoll`(레벨 vs 엣지), 타임아웃/재시도, 소켓 옵션, BDP/RTT 직관, 멀티스레딩/멀티큐.
- **운영/보안(13~18편)**: `tcpdump`/Wireshark, `ss`/`lsof`/`strace`, 장애 재현, TLS 1.3 도입, zero-copy, PMTUD/MSS 튜닝.

> **철학**: “모르면 **관측**한다.” 모든 이론은 **패킷/시스콜/큐 길이**로 검증한다.

---

### 0.2 소켓 = 커널의 통신 끝점(핸들) — 개념과 실험

#### 0.2.1 핵심 개념(그림으로 머릿속에 고정)
- 사용자 공간(User) ↔ **시스템 콜** ↔ 커널(Kernel) ↔ NIC/드라이버 ↔ 네트워크
- **소켓(socket)** 은 커널이 만든 **통신 끝점(endpoint)** 에 대한 **핸들**이다. 유닉스에서는 **파일 디스크립터(fd)** 로 표현되고, 그래서 `read/write/close`가 동작한다.

#### 0.2.2 즉시 실험: `send()`는 왜 “성공”인데 상대가 못 받았을까?
1) **서버**: 아무 일도 하지 않고 **읽지 않는** TCP 서버를 띄운다(수신 버퍼가 가득 차는 상황을 만들기 용도).
2) **클라이언트**: 큰 바이트 배열을 계속 `send()`한다.
3) 관측: 초반에는 `send()`가 잘 되지만, 어느 순간 **블록**(블로킹)되거나 논블로킹이면 `EAGAIN`으로 실패한다. → **커널 송신 버퍼가 가득 참**.

> 이 현상은 **백프레셔(backpressure)** 의 자연스러운 결과다. TCP 흐름 제어/혼잡 제어가 **전송률을 내린다**.

---

### 0.3 “패킷”과 “스트림”의 차이, 그리고 **프레이밍**의 필연성

#### 0.3.1 용어 정리
- **패킷**: 계층에 따라 Frame/Packet/Segment/Datagram 등으로 부르지만, 관측 도구(tcpdump/Wireshark)에서 보이는 **전송 단위**를 총칭해 흔히 “패킷”이라 부른다.
- **스트림(TCP)**: 응용 입장에서는 **경계 없는 바이트 흐름**. OS/네트워크가 상황에 따라 **쪼개거나 합친다**.

#### 0.3.2 예제 시나리오 — 같은 메시지, 서로 다른 수신
- 클라이언트가 `send("HELLO-WORLD")` 11바이트를 보냈는데, 수신자는 다음처럼 받을 수 있다.
  - `recv()` → `"HEL"` (3바이트)
  - 재호출 `recv()` → `"LO-WORLD"` (8바이트)
- 혹은 한 번에 `"HELLO-WORLD"` 전부 받을 수도 있다. **보장은 없다.**  
  → 그러므로 **프레이밍**이 필요하다.

#### 0.3.3 프레이밍의 최소 해법: **길이-프리픽스(4바이트 빅엔디안)**
- **헤더(4B length) + payload(NB)**.  
- 수신자는 먼저 4바이트를 **정확히** 읽고(부분 입출력 주의), 그 길이만큼 **정확히** 다시 읽어 1메시지를 복구한다.
- 길이 한도(cap)도 둔다(예: 16MB). 악의적 입력으로 **메모리 고갈** 방지.

```cpp
// C++23 프레이밍 핵심(요약): 4바이트 길이 + payload
std::expected<void, std::error_code>
send_frame(int fd, std::span<const std::byte> payload);

std::expected<std::vector<std::byte>, std::error_code>
recv_frame(int fd, std::size_t cap = (1u<<20));
```

#### 0.3.4 지연과 처리량 직관(간단 근사)
- 대역폭–지연곱:
  $$
  \text{BDP} = \text{Bandwidth} \times \text{RTT}
  $$
  BDP만큼 **파이프에 바이트를 채우지 못하면** 최대 처리량을 못 낸다.
- 손실이 있을 때 처리량 근사(직관용):
  $$
  \text{Throughput} \approx \frac{\text{MSS}}{\text{RTT}\sqrt{p}}
  $$
  \(p\): 손실 확률, **RTT↑/손실↑** → 처리량↓.  
- **작은 메시지 빈발**은 Nagle/지연 ACK 상호작용으로 **지연**이 커질 수 있다.  
  해결: **coalescing**(배치 전송) 또는 `TCP_NODELAY`(Nagle off). 상황에 맞게 선택.

---

### 0.4 실습 환경 준비(리눅스, 컴파일러, 필수 도구)

> 본 시리즈는 **리눅스**를 기준으로 한다(Ubuntu/Debian/RHEL/Arch 등). macOS/BSD도 명령이 유사하지만 커널/도구 스펙이 다를 수 있다.

#### 0.4.1 컴파일러 & 빌드 툴
```bash
# Debian/Ubuntu
sudo apt update
sudo apt install -y build-essential clang-format clang lldb cmake git

# Fedora/RHEL/CentOS Stream
sudo dnf groupinstall -y "Development Tools"
sudo dnf install -y clang-tools-extra lldb cmake git

# 확인
g++ --version     # or clang++ --version
cmake --version
```
- 본문 코드는 `-std=c++23` 기준. (GCC 13+/Clang 16+ 권장)

#### 0.4.2 패킷 관측 도구
```bash
sudo apt install -y tcpdump wireshark
sudo usermod -aG wireshark $USER   # wireshark 권한(재로그인 필요)
```
- **tcpdump**: CLI 패킷 캡처.  
- **Wireshark**: GUI 분석기.  
- **권장**: 캡처는 `tcpdump -w trace.pcap`로 저장 후 Wireshark로 분석.

#### 0.4.3 소켓/프로세스 관찰 도구
```bash
sudo apt install -y iproute2 net-tools lsof strace
```
- `ss`(iproute2): 소켓 상태/큐 길이 등 확인.
- `lsof`: 어떤 프로세스가 어떤 포트를 여는지.
- `strace`: 시스템 콜 레벨에서 I/O 흐름 추적.

#### 0.4.4 REPL/유틸
```bash
sudo apt install -y netcat-openbsd hexdump
```
- `nc`(netcat): 빠른 TCP/UDP 상호작용 검사.
- `hexdump`: 바이트 레벨 출력 확인.

---

### 0.5 초소형 C++23 실습: “보이고 만져지는” 최소 서버/클라(블로킹)

> 목적: **부분 입출력 + 프레이밍**을 *눈으로* 확인하고, `tcpdump`로 **패킷 흐름**을 본다.  
> (아래 코드는 이후 본문에서 점진적으로 개선할 **기초 버전**이다.)

#### 0.5.1 서버(요지)
```cpp
// server.cpp (요지) — 0.0.0.0:9000 바인드, 프레이밍으로 1프레임 읽어 에코
// 빌드: g++ -std=c++23 -O2 server.cpp -o server
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cstdint>
#include <vector>
#include <span>
#include <cstring>
#include <iostream>

static bool recv_exact(int fd, void* p, size_t n) {
    auto* b = static_cast<std::byte*>(p);
    size_t got=0;
    while (got<n) {
        ssize_t r = ::recv(fd, b+got, n-got, 0);
        if (r<=0) return false;
        got += (size_t)r;
    }
    return true;
}
static bool send_all(int fd, const void* p, size_t n) {
    auto* b = static_cast<const std::byte*>(p);
    size_t sent=0;
    while (sent<n) {
        ssize_t w = ::send(fd, b+sent, n-sent, 0);
        if (w<=0) return false;
        sent += (size_t)w;
    }
    return true;
}
int main() {
    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM; hints.ai_flags=AI_PASSIVE|AI_ADDRCONFIG;
    if (getaddrinfo(nullptr,"9000",&hints,&res)!=0) return 1;

    int s=-1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s = ::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        int yes=1; ::setsockopt(s,SOL_SOCKET,SO_REUSEADDR,&yes,sizeof(yes));
        if (::bind(s, ai->ai_addr, ai->ai_addrlen)==0 && ::listen(s,128)==0) break;
        ::close(s); s=-1;
    }
    if (s<0) return 2;

    for(;;){
        int c = ::accept(s,nullptr,nullptr);
        if (c<0) continue;

        uint32_t be=0;
        if (!recv_exact(c,&be,4)) { ::close(c); continue; }
        uint32_t len = ntohl(be);
        std::vector<std::byte> buf(len);
        if (!recv_exact(c,buf.data(),buf.size())) { ::close(c); continue; }

        // 에코
        be = htonl(len);
        if (!send_all(c,&be,4) || !send_all(c,buf.data(),buf.size())) { ::close(c); continue; }
        ::close(c);
    }
}
```

#### 0.5.2 클라이언트(요지)
```cpp
// client.cpp (요지) — 127.0.0.1:9000로 메시지 1개 전송 후 에코 수신
// 빌드: g++ -std=c++23 -O2 client.cpp -o client
#include <arpa/inet.h>
#include <netdb.h>
#include <sys/socket.h>
#include <unistd.h>
#include <cstdint>
#include <vector>
#include <string>
#include <iostream>

static bool send_all(int fd, const void* p, size_t n) {
    const char* b = (const char*)p; size_t sent=0;
    while (sent<n) {
        ssize_t w = ::send(fd, b+sent, n-sent, 0);
        if (w<=0) return false;
        sent += (size_t)w;
    } return true;
}
static bool recv_exact(int fd, void* p, size_t n) {
    char* b=(char*)p; size_t got=0;
    while (got<n) {
        ssize_t r = ::recv(fd, b+got, n-got, 0);
        if (r<=0) return false;
        got += (size_t)r;
    } return true;
}
int main(int argc, char** argv){
    std::string msg = (argc>=2)? argv[1] : "hello-socket";
    addrinfo hints{}, *res=nullptr;
    hints.ai_family=AF_UNSPEC; hints.ai_socktype=SOCK_STREAM;
    if (getaddrinfo("127.0.0.1","9000",&hints,&res)!=0) return 1;
    int s=-1;
    for (auto* ai=res; ai; ai=ai->ai_next) {
        s=::socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);
        if (s<0) continue;
        if (::connect(s, ai->ai_addr, ai->ai_addrlen)==0) break;
        ::close(s); s=-1;
    }
    if (s<0) return 2;

    uint32_t len = (uint32_t)msg.size(), be = htonl(len);
    if (!send_all(s,&be,4) || !send_all(s,msg.data(),msg.size())) { ::close(s); return 3; }
    if (!recv_exact(s,&be,4)) { ::close(s); return 4; }
    uint32_t elen = ntohl(be);
    std::string echo(elen,'\0');
    if (!recv_exact(s,echo.data(),echo.size())) { ::close(s); return 5; }
    std::cout << "echo: " << echo << "\n";
    ::close(s);
    return 0;
}
```

#### 0.5.3 실행
```bash
# 터미널 1
./server

# 터미널 2
./client "HELLO-WORLD"
```

- 결과: `echo: HELLO-WORLD`  
- 여기서 **중요한 점**은, 11바이트가 **항상 한 번에** 수신된다는 **보장이 없었지만**, **프레이밍** 덕분에 한 메시지로 *정확히* 복원했다는 것.

---

### 0.6 패킷을 “직접” 보자: `tcpdump` & Wireshark

#### 0.6.1 캡처 시작
```bash
# 루프백 캡처 (loopback 인터페이스 이름은 배포판마다 다를 수 있음: lo, lo0 등)
sudo tcpdump -i lo tcp port 9000 -n -vv -w trace.pcap
```
- `-i lo`: 루프백 인터페이스
- `tcp port 9000`: 9000/TCP만
- `-w trace.pcap`: 파일로 저장(나중에 Wireshark로).

#### 0.6.2 실험 순서
1) `tcpdump` 실행
2) `./server` 실행
3) `./client "HELLO-WORLD"` 실행
4) `tcpdump` 종료(Ctrl+C)

#### 0.6.3 Wireshark에서 확인할 포인트
- **3-way handshake**: SYN → SYN/ACK → ACK  
- 애플리케이션 페이로드:  
  - 첫 전송: 4바이트 길이 헤더(`00 00 00 0B`) + `"HELLO-WORLD"`(11바이트)  
  - **한 개 또는 여러 세그먼트**로 보일 수 있다(네트워크/커널 상태에 따라 분할될 수 있으므로).
- **서버의 에코**: 동일한 패턴으로 역방향.  
- **4-way 종료**: FIN/ACK → ACK → FIN/ACK → ACK (상황에 따라 합쳐질 수 있음)

> 관측을 통해 “TCP는 **메시지 경계를 보장하지 않는다**”는 사실이 **시각적으로 확인**된다.

---

### 0.7 `ss`/`lsof`/`strace`로 커널 상태 들여다보기

#### 0.7.1 `ss`로 큐와 상태
```bash
# 수신/송신 큐 길이 포함해서 본다
ss -tanp '( sport = :9000 )'    # 리스너/ESTABLISHED 상태 확인
```
- 출력에서 `Recv-Q`/`Send-Q`가 눈에 들어온다. 수신자가 느리면 `Send-Q`가 **커질 수 있다**.

#### 0.7.2 `lsof`로 포트 보유 프로세스
```bash
sudo lsof -iTCP:9000 -sTCP:LISTEN -n -P
```
- 누가 9000 포트를 리슨하는지 확인(프로세스/경로).

#### 0.7.3 `strace`로 시스템 콜 레벨에서 보기
```bash
# 서버를 strace로 실행(네트워크 관련 콜만)
strace -f -e trace=network ./server
```
- `accept`, `recv`, `send`, `close`, `getsockopt`, `setsockopt` 등 호가 난다.  
- 여기서 **`recv`가 부분적으로 읽히는 모습**, `send`가 반복되는 패턴을 직접 본다.

---

### 0.8 프레이밍 없이는 어떤 문제가 터지는가 — 반례 실험

#### 0.8.1 프레이밍 없는 “라인 기반” 예제(의도적 취약)
- 클라이언트가 한 줄(`\n`)을 보낸다고 가정하고 서버는 `read()` 한 번으로 처리한다고 치자.  
- 실제로는 다음이 벌어진다.
  - `read()`가 `"\n"` 이전까지만 읽고 반환 → 서버는 **불완전한 메시지**를 처리하려 함.
  - 반대로 두 줄이 **합쳐져서** 한 번에 들어오면 → **두 메시지를 한 번에** 처리하려 하다 실패.
- 해결: **프레이밍 또는 스트림 파서**가 필요하다.

#### 0.8.2 간단한 검증 체크리스트
- [ ] `recv()`/`read()` **반환 길이**를 항상 체크하고, 루프를 돌며 **필요한 만큼** 모았는가?
- [ ] 입력 길이(cap)를 정하고 초과 시 **즉시 종료**하는가?
- [ ] 문자열 가정(UTF-8 등) 전에 **바이트**로 먼저 처리했는가?
- [ ] `SIGPIPE`에 안전한가? (`MSG_NOSIGNAL` 또는 `SIGPIPE` 무시)

---

### 0.9 지연·처리량·버퍼의 감(直感)

#### 0.9.1 BDP로 “버퍼 감” 잡기
- 예) 1 Gbps 링크, RTT = 50 ms  
  $$
  \text{BDP} = 1\,\text{Gbps} \times 0.05\,\text{s} = 50\,\text{Mbit} \approx 6.25\,\text{MB}
  $$
- 의미: 파이프를 가득 채우려면 **송신/수신 버퍼 + 애플리케이션 버퍼**가 합쳐 **수 MB** 이상 필요할 수 있다는 뜻.

#### 0.9.2 작은 메시지의 딜레마
- 수십/수백 바이트 메시지를 자주 보낼 때,
  - **Nagle**: 작은 세그먼트를 합쳐 보낸다 → **지연** 발생 가능.
  - **지연 ACK**: 수신 ACK를 지연해 왕복 수를 줄이려 한다 → **상호작용 지연** 가능.
- 대응: **버퍼링(coalescing)** 으로 *의도적으로* 모아서 보내거나, **`TCP_NODELAY`** 로 나글 비활성화.

---

### 0.10 이 챕터의 ‘실전 과제(To-do)’

1) **패킷 캡처 과제**  
   - `HELLO-WORLD` 대신 **여러 길이**(10B, 1KB, 64KB) 메시지를 시도하고, `trace.pcap`에서 **세그먼트 분할** 패턴을 비교하라.
2) **부분 입출력 확인 과제**  
   - 서버 루프에서 `usleep(20000)`(20ms) 같은 **인위 지연**을 넣고, 클라이언트에서 `Send-Q/Recv-Q` 변화를 `ss`로 관측하라.
3) **라인 기반 반례 과제**  
   - 프레이밍을 제거하고, 클라이언트를 2개 띄워 **교차로** 보낸 뒤 서버가 **메시지 경계를 오해**하는 모습을 재현하라.
4) **Nagle 실험 과제**  
   - `setsockopt(TCP_NODELAY)` on/off로 같은 부하를 보내고 **왕복 지연**을 비교하라(작은 패킷 빈발 시 차이 큼).

---

### 0.11 다음 장으로 이어지는 길

- **1장**에서 위의 최소 서버/클라를 **RAII**, `std::expected`, `std::span<std::byte>`로 정돈하고, **에러 모델**과 **타임아웃**의 기본형을 만든다.
- 이후 **프레이밍**을 고정 규격(길이-프리픽스)으로 정식화하고, **테스트 벤치**와 **관측 스크립트**(tcpdump 필터, `ss` 샘플러)를 함께 제공한다.

---

### 0.12 부록 — 퀵 레퍼런스

#### tcpdump 즐겨찾기
```bash
sudo tcpdump -i any tcp port 9000 -n -vv
sudo tcpdump -i any "tcp[tcpflags] & (tcp-syn) != 0" -n   # SYN만
sudo tcpdump -i any -w trace.pcap
```

#### ss/strace/lsof
```bash
ss -tanp '( sport = :9000 )'
strace -f -e trace=network ./server
sudo lsof -iTCP:9000 -sTCP:LISTEN -n -P
```

#### 개념 스니펫(수식)
- BDP:
  $$
  \text{BDP} = \text{Bandwidth} \times \text{RTT}
  $$
- 손실 환경 처리량(직관):
  $$
  \text{Throughput} \approx \frac{\text{MSS}}{\text{RTT}\sqrt{p}}
  $$
