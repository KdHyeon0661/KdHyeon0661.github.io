---
layout: post
title: 파이썬 심화 - 테스팅, 디버깅, 예외 (1)
date: 2025-12-06 23:30:23 +0900
category: 파이썬 심화
---
# 테스팅, 디버깅, 예외 (1)

## 표준 출력(stdout) 테스팅 심화 기법

프로그램의 표준 출력을 테스트하는 것은 콘솔 애플리케이션, 로깅 시스템, CLI 도구의 핵심 검증 요소입니다. 단순한 문자열 비교를 넘어 다양한 시나리오를 포괄하는 완전한 테스팅 솔루션을 구현합니다.

```python
import sys
import io
import contextlib
from typing import Any, Callable, Optional, List, Dict
import unittest
from unittest.mock import patch, MagicMock, call
import re
import json

class OutputAssertions:
    """표준 출력 검증을 위한 고급 어서션 클래스"""
    
    @staticmethod
    def capture_output(func: Callable, *args, **kwargs) -> tuple:
        """
        함수의 stdout/stderr 출력 캡처
        
        Returns:
            (stdout_output, stderr_output) 튜플
        """
        stdout_capture = io.StringIO()
        stderr_capture = io.StringIO()
        
        with contextlib.redirect_stdout(stdout_capture):
            with contextlib.redirect_stderr(stderr_capture):
                func(*args, **kwargs)
        
        return stdout_capture.getvalue(), stderr_capture.getvalue()
    
    @staticmethod
    def assert_output_contains(output: str, expected: str, 
                              case_sensitive: bool = True,
                              msg: Optional[str] = None) -> None:
        """
        출력에 특정 문자열이 포함되어 있는지 검증
        """
        if not case_sensitive:
            output = output.lower()
            expected = expected.lower()
        
        if expected not in output:
            default_msg = f"출력에 '{expected}'이(가) 포함되어 있지 않습니다.\n출력: {output}"
            raise AssertionError(msg or default_msg)
    
    @staticmethod
    def assert_output_not_contains(output: str, unexpected: str,
                                  case_sensitive: bool = True,
                                  msg: Optional[str] = None) -> None:
        """
        출력에 특정 문자열이 포함되어 있지 않은지 검증
        """
        if not case_sensitive:
            output = output.lower()
            unexpected = unexpected.lower()
        
        if unexpected in output:
            default_msg = f"출력에 '{unexpected}'이(가) 포함되어 있습니다.\n출력: {output}"
            raise AssertionError(msg or default_msg)
    
    @staticmethod
    def assert_output_matches(output: str, pattern: str,
                             flags: int = 0,
                             msg: Optional[str] = None) -> None:
        """
        출력이 정규식 패턴과 일치하는지 검증
        """
        if not re.search(pattern, output, flags=flags):
            default_msg = f"출력이 패턴 '{pattern}'과 일치하지 않습니다.\n출력: {output}"
            raise AssertionError(msg or default_msg)
    
    @staticmethod
    def assert_output_lines(output: str, 
                           expected_lines: List[str],
                           ignore_empty: bool = True,
                           strip_lines: bool = True) -> None:
        """
        출력의 각 라인이 예상 라인과 일치하는지 검증
        """
        lines = output.splitlines()
        
        if ignore_empty:
            lines = [line for line in lines if line.strip()]
        
        if strip_lines:
            lines = [line.strip() for line in lines]
            expected_lines = [line.strip() for line in expected_lines]
        
        for i, (actual, expected) in enumerate(zip(lines, expected_lines)):
            if actual != expected:
                raise AssertionError(
                    f"라인 {i+1} 불일치:\n"
                    f"예상: '{expected}'\n"
                    f"실제: '{actual}'"
                )
        
        if len(lines) != len(expected_lines):
            raise AssertionError(
                f"라인 수 불일치: 예상 {len(expected_lines)}줄, 실제 {len(lines)}줄"
            )
    
    @staticmethod
    def assert_output_json(output: str,
                          expected_data: Dict,
                          ignore_order: bool = False) -> None:
        """
        출력이 JSON 형식이고 예상 데이터와 일치하는지 검증
        """
        try:
            data = json.loads(output)
        except json.JSONDecodeError as e:
            raise AssertionError(f"출력이 유효한 JSON이 아닙니다: {e}")
        
        if ignore_order:
            # 딕셔너리 비교 (순서 무시)
            assert data == expected_data, f"JSON 데이터 불일치"
        else:
            # 정확한 비교
            import pprint
            if data != expected_data:
                raise AssertionError(
                    f"JSON 데이터 불일치:\n"
                    f"예상: {pprint.pformat(expected_data)}\n"
                    f"실제: {pprint.pformat(data)}"
                )

class ConsoleApplicationTester:
    """콘솔 애플리케이션 통합 테스터"""
    
    def __init__(self, app_module, app_function: str = "main"):
        self.app_module = app_module
        self.app_function = app_function
        self.test_outputs = []
    
    def run_with_args(self, args: List[str]) -> Dict[str, Any]:
        """
        명령줄 인수를 전달하여 애플리케이션 실행
        """
        original_argv = sys.argv.copy()
        
        try:
            sys.argv = [sys.argv[0]] + args
            
            stdout_capture = io.StringIO()
            stderr_capture = io.StringIO()
            exit_code = 0
            
            with contextlib.redirect_stdout(stdout_capture):
                with contextlib.redirect_stderr(stderr_capture):
                    try:
                        func = getattr(self.app_module, self.app_function)
                        func()
                    except SystemExit as e:
                        exit_code = e.code if isinstance(e.code, int) else 0
            
            result = {
                'stdout': stdout_capture.getvalue(),
                'stderr': stderr_capture.getvalue(),
                'exit_code': exit_code,
                'args': args
            }
            
            self.test_outputs.append(result)
            return result
            
        finally:
            sys.argv = original_argv
    
    def assert_exit_code(self, result: Dict, expected_code: int = 0) -> None:
        """종료 코드 검증"""
        assert result['exit_code'] == expected_code, \
            f"종료 코드 불일치: 예상 {expected_code}, 실제 {result['exit_code']}"
    
    def assert_success(self, result: Dict) -> None:
        """성공적인 실행 검증"""
        self.assert_exit_code(result, 0)
        assert result['stderr'] == '', f"stderr가 비어있지 않습니다: {result['stderr']}"
    
    def assert_failure(self, result: Dict, expected_stderr: str = None) -> None:
        """실패적인 실행 검증"""
        assert result['exit_code'] != 0, "실패 시나리오에서 종료 코드는 0이 아니어야 합니다"
        if expected_stderr:
            assert expected_stderr in result['stderr'], \
                f"stderr에 예상 메시지가 없습니다: {expected_stderr}"

# 실전 예제: CLI 애플리케이션 테스트
class TestCalculatorCLI(unittest.TestCase):
    """계산기 CLI 애플리케이션 테스트"""
    
    def setUp(self):
        self.tester = ConsoleApplicationTester(calculator_app, "main")
        self.assertions = OutputAssertions()
    
    def test_addition(self):
        """덧셈 연산 테스트"""
        result = self.tester.run_with_args(["add", "5", "3"])
        
        self.tester.assert_success(result)
        self.assertions.assert_output_contains(result['stdout'], "결과: 8")
    
    def test_invalid_arguments(self):
        """잘못된 인수 테스트"""
        result = self.tester.run_with_args(["add", "five", "three"])
        
        self.tester.assert_failure(result)
        self.assertions.assert_output_contains(result['stderr'], "숫자를 입력해주세요")
    
    def test_help_output(self):
        """도움말 출력 테스트"""
        result = self.tester.run_with_args(["--help"])
        
        expected_lines = [
            "사용법: calculator [명령] [인수...]",
            "명령:",
            "  add    두 숫자를 더합니다",
            "  sub    두 숫자를 뺍니다"
        ]
        
        self.tester.assert_success(result)
        self.assertions.assert_output_lines(result['stdout'], expected_lines)
    
    def test_json_output_format(self):
        """JSON 출력 형식 테스트"""
        result = self.tester.run_with_args(["add", "10", "20", "--format", "json"])
        
        expected_json = {
            "operation": "add",
            "operands": [10, 20],
            "result": 30,
            "success": True
        }
        
        self.tester.assert_success(result)
        self.assertions.assert_output_json(result['stdout'], expected_json)

# 고급 출력 테스트 데코레이터
def capture_and_assert(stdout_pattern: str = None,
                      stderr_pattern: str = None,
                      exit_code: int = 0):
    """
    출력 캡처와 검증을 위한 데코레이터
    """
    def decorator(test_func):
        def wrapper(self, *args, **kwargs):
            stdout_capture = io.StringIO()
            stderr_capture = io.StringIO()
            
            with contextlib.redirect_stdout(stdout_capture):
                with contextlib.redirect_stderr(stderr_capture):
                    # 테스트 함수 실행
                    test_func(self, *args, **kwargs)
            
            stdout_output = stdout_capture.getvalue()
            stderr_output = stderr_capture.getvalue()
            
            # 검증
            if stdout_pattern:
                self.assertRegex(stdout_output, stdout_pattern)
            if stderr_pattern:
                self.assertRegex(stderr_output, stderr_pattern)
            
        return wrapper
    return decorator

# 사용 예시
class TestWithDecorator(unittest.TestCase):
    
    @capture_and_assert(
        stdout_pattern=r"Hello, .+!",
        exit_code=0
    )
    def test_greeting(self):
        print("Hello, World!")
```

## 유닛 테스트에서 객체 패칭 심화 기법

패칭(Mocking/Stubbing)은 테스트 격리와 의존성 관리를 위한 핵심 기술입니다. 다양한 패칭 시나리오와 모범 사례를 살펴봅니다.

```python
import unittest
from unittest.mock import Mock, MagicMock, patch, PropertyMock, AsyncMock
from typing import Any, Dict, List
import datetime
import asyncio

class DatabaseService:
    """데이터베이스 서비스 예제"""
    
    def __init__(self, connection):
        self.connection = connection
    
    def get_user(self, user_id: int) -> Dict:
        """사용자 정보 조회"""
        # 실제 구현은 데이터베이스 쿼리
        return {"id": user_id, "name": "Test User"}
    
    def update_user(self, user_id: int, data: Dict) -> bool:
        """사용자 정보 업데이트"""
        # 실제 구현은 데이터베이스 업데이트
        return True
    
    @property
    def is_connected(self) -> bool:
        """연결 상태 확인"""
        return self.connection.is_active()

class EmailService:
    """이메일 서비스 예제"""
    
    def send_email(self, to: str, subject: str, body: str) -> bool:
        """이메일 전송"""
        # 실제 구현은 SMTP 서버 연결
        return True
    
    async def send_email_async(self, to: str, subject: str, body: str) -> bool:
        """비동기 이메일 전송"""
        await asyncio.sleep(0.1)
        return True

class UserManager:
    """사용자 관리자 (의존성 주입)"""
    
    def __init__(self, db_service: DatabaseService, email_service: EmailService):
        self.db = db_service
        self.email = email_service
    
    def register_user(self, user_data: Dict) -> Dict:
        """사용자 등록"""
        # 데이터베이스에 사용자 저장
        user_id = self.db.create_user(user_data)
        
        # 환영 이메일 전송
        success = self.email.send_email(
            user_data['email'],
            "환영합니다!",
            f"{user_data['name']}님, 가입을 환영합니다."
        )
        
        if not success:
            # 이메일 전송 실패 시 롤백
            self.db.delete_user(user_id)
            raise RuntimeError("이메일 전송 실패")
        
        return {"id": user_id, "status": "registered"}

# 고급 패칭 테스트 클래스
class TestUserManagerAdvanced(unittest.TestCase):
    """고급 패칭 테스트 예제"""
    
    def setUp(self):
        # 모의 객체 생성
        self.mock_db = Mock(spec=DatabaseService)
        self.mock_email = Mock(spec=EmailService)
        
        # 테스트 대상 객체 생성
        self.user_manager = UserManager(self.mock_db, self.mock_email)
    
    def test_register_user_success(self):
        """사용자 등록 성공 테스트"""
        # 모의 객체 설정
        self.mock_db.create_user.return_value = 123
        self.mock_email.send_email.return_value = True
        self.mock_db.delete_user.return_value = True
        
        # 테스트 실행
        user_data = {
            "name": "홍길동",
            "email": "hong@example.com",
            "password": "secret123"
        }
        
        result = self.user_manager.register_user(user_data)
        
        # 검증
        self.assertEqual(result["id"], 123)
        self.assertEqual(result["status"], "registered")
        
        # 메서드 호출 검증
        self.mock_db.create_user.assert_called_once_with(user_data)
        self.mock_email.send_email.assert_called_once_with(
            "hong@example.com",
            "환영합니다!",
            "홍길동님, 가입을 환영합니다."
        )
        self.mock_db.delete_user.assert_not_called()
    
    def test_register_user_email_failure(self):
        """이메일 전송 실패 테스트"""
        # 모의 객체 설정 (이메일 실패 시나리오)
        self.mock_db.create_user.return_value = 456
        self.mock_email.send_email.return_value = False
        self.mock_db.delete_user.return_value = True
        
        # 테스트 실행 및 예외 검증
        user_data = {"name": "김철수", "email": "kim@example.com"}
        
        with self.assertRaises(RuntimeError) as context:
            self.user_manager.register_user(user_data)
        
        self.assertIn("이메일 전송 실패", str(context.exception))
        
        # 롤백 호출 검증
        self.mock_db.delete_user.assert_called_once_with(456)
    
    def test_method_call_sequence(self):
        """메서드 호출 순서 검증"""
        # 호출 순서 추적을 위한 모의 객체
        self.mock_db.create_user.return_value = 789
        self.mock_email.send_email.return_value = True
        
        user_data = {"name": "이영희", "email": "lee@example.com"}
        
        result = self.user_manager.register_user(user_data)
        
        # 호출 순서 검증
        expected_calls = [
            call.create_user(user_data),
            call.send_email("lee@example.com", "환영합니다!", "이영희님, 가입을 환영합니다.")
        ]
        
        # 실제 호출 순서 확인
        actual_calls = []
        for method_call in [self.mock_db.create_user, self.mock_email.send_email]:
            if method_call.called:
                actual_calls.append(method_call.call_args)
        
        # 호출 횟수와 순서 검증
        self.assertEqual(self.mock_db.create_user.call_count, 1)
        self.assertEqual(self.mock_email.send_email.call_count, 1)
    
    def test_side_effects(self):
        """사이드 이펙트 테스트"""
        # 사이드 이펙트 설정
        user_counter = 0
        
        def create_user_side_effect(user_data):
            nonlocal user_counter
            user_counter += 1
            return user_counter * 100  # ID 생성
        
        self.mock_db.create_user.side_effect = create_user_side_effect
        self.mock_email.send_email.return_value = True
        
        # 여러 번 호출 테스트
        user_data1 = {"name": "유저1", "email": "user1@example.com"}
        user_data2 = {"name": "유저2", "email": "user2@example.com"}
        
        result1 = self.user_manager.register_user(user_data1)
        result2 = self.user_manager.register_user(user_data2)
        
        self.assertEqual(result1["id"], 100)  # 첫 번째 호출
        self.assertEqual(result2["id"], 200)  # 두 번째 호출
        self.assertEqual(user_counter, 2)  # 사이드 이펙트 확인
    
    def test_property_mocking(self):
        """프로퍼티 패칭 테스트"""
        # 프로퍼티 모의 객체 생성
        type(self.mock_db).is_connected = PropertyMock(return_value=True)
        
        # 프로퍼티 접근 테스트
        is_connected = self.mock_db.is_connected
        
        self.assertTrue(is_connected)
        self.mock_db.is_connected.assert_called_once()

class AsyncServiceTester(unittest.TestCase):
    """비동기 서비스 테스트"""
    
    def setUp(self):
        self.mock_email = AsyncMock(spec=EmailService)
        self.loop = asyncio.new_event_loop()
        asyncio.set_event_loop(self.loop)
    
    def tearDown(self):
        self.loop.close()
    
    def test_async_email_send(self):
        """비동기 이메일 전송 테스트"""
        
        async def test_coroutine():
            self.mock_email.send_email_async.return_value = True
            
            result = await self.mock_email.send_email_async(
                "test@example.com",
                "테스트 제목",
                "테스트 본문"
            )
            
            self.assertTrue(result)
            self.mock_email.send_email_async.assert_called_once_with(
                "test@example.com",
                "테스트 제목",
                "테스트 본문"
            )
        
        self.loop.run_until_complete(test_coroutine())

# 컨텍스트 매니저 패칭
class TestExternalAPICalls(unittest.TestCase):
    """외부 API 호출 패칭 테스트"""
    
    @patch('requests.get')
    def test_fetch_data_from_api(self, mock_get):
        """외부 API GET 요청 패칭"""
        # 모의 응답 설정
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {
            "data": [{"id": 1, "name": "Item 1"}],
            "total": 1
        }
        mock_get.return_value = mock_response
        
        # 실제 코드 실행
        import requests
        response = requests.get('https://api.example.com/items')
        data = response.json()
        
        # 검증
        self.assertEqual(response.status_code, 200)
        self.assertEqual(data['total'], 1)
        mock_get.assert_called_once_with('https://api.example.com/items')
    
    @patch('module.ExternalService.connect')
    @patch('module.ExternalService.query')
    @patch('module.ExternalService.disconnect')
    def test_external_service_integration(self, mock_disconnect, mock_query, mock_connect):
        """여러 단계의 외부 서비스 패칭"""
        # 연결 모의 설정
        mock_connect.return_value = "connection_token"
        
        # 쿼리 모의 설정
        mock_query.return_value = {"result": "success", "data": [1, 2, 3]}
        
        # 실제 테스트 로직 (예시)
        from module import ExternalService
        
        service = ExternalService()
        connection = service.connect()
        result = service.query("SELECT * FROM table")
        service.disconnect()
        
        # 검증
        mock_connect.assert_called_once()
        mock_query.assert_called_once_with("SELECT * FROM table")
        mock_disconnect.assert_called_once()
        self.assertEqual(result["result"], "success")

# 객체 생성자 패칭
class TestFactoryPattern(unittest.TestCase):
    """팩토리 패턴 테스트"""
    
    @patch.object(DatabaseService, '__init__', return_value=None)
    def test_database_service_initialization(self, mock_init):
        """생성자 패칭 테스트"""
        # 생성자 호출 없이 객체 생성
        service = DatabaseService("dummy_connection")
        
        # 생성자가 호출되었는지 확인
        mock_init.assert_called_once_with(service, "dummy_connection")
        
        # 추가 설정
        service.connection = Mock()
        service.connection.is_active.return_value = True
        
        # 메서드 테스트
        self.assertTrue(service.is_connected)

# 동적 패칭
class TestDynamicPatching(unittest.TestCase):
    """동적 패칭 테스트"""
    
    def test_dynamic_patch_with_context_manager(self):
        """컨텍스트 매니저를 이용한 동적 패칭"""
        import random
        
        # 원래 함수 저장
        original_random = random.randint
        
        # 패치 컨텍스트 내에서만 적용
        with patch('random.randint', return_value=42):
            result = random.randint(1, 100)
            self.assertEqual(result, 42)
        
        # 컨텍스트 밖에서는 원래 함수
        result = random.randint(1, 100)
        self.assertNotEqual(result, 42)  # 42가 아닐 가능성이 매우 높음
        self.assertEqual(random.randint, original_random)  # 원래 함수 복원됨
    
    def test_patch_multiple_targets(self):
        """여러 대상 패칭"""
        with patch.multiple(
            'module_to_test',
            function_a=Mock(return_value='mocked_a'),
            function_b=Mock(return_value='mocked_b'),
            CLASS_CONSTANT='mocked_constant'
        ) as mocks:
            # 패칭된 모듈 테스트
            from module_to_test import function_a, function_b, CLASS_CONSTANT
            
            self.assertEqual(function_a(), 'mocked_a')
            self.assertEqual(function_b(), 'mocked_b')
            self.assertEqual(CLASS_CONSTANT, 'mocked_constant')
            
            # 모의 객체 검증
            mocks['function_a'].assert_called_once()
            mocks['function_b'].assert_called_once()

# 실전 패칭 패턴: 설정 파일 패칭
class TestConfigurationDependentCode(unittest.TestCase):
    """설정 의존 코드 테스트"""
    
    @patch.dict('os.environ', {'API_KEY': 'test_key', 'DEBUG_MODE': 'true'})
    def test_environment_variables(self):
        """환경 변수 패칭"""
        import os
        
        self.assertEqual(os.environ['API_KEY'], 'test_key')
        self.assertEqual(os.environ['DEBUG_MODE'], 'true')
        
        # 설정 의존 코드 테스트
        api_key = os.getenv('API_KEY', 'default')
        debug_mode = os.getenv('DEBUG_MODE', 'false').lower() == 'true'
        
        self.assertEqual(api_key, 'test_key')
        self.assertTrue(debug_mode)
```

## 예외 조건 테스트 심화 기법

예외 처리는 애플리케이션의 견고성을 보장하는 핵심 요소입니다. 다양한 예외 시나리오를 체계적으로 테스트하는 방법을 살펴봅니다.

```python
import unittest
from unittest.mock import Mock, patch
import contextlib
from typing import Type, Optional
import logging

class CustomException(Exception):
    """사용자 정의 예외"""
    def __init__(self, message: str, error_code: int = 0):
        super().__init__(message)
        self.error_code = error_code
        self.timestamp = datetime.datetime.now()

class DatabaseException(CustomException):
    """데이터베이스 예외"""
    pass

class NetworkException(CustomException):
    """네트워크 예외"""
    pass

class RobustDataProcessor:
    """견고한 데이터 처리기"""
    
    def __init__(self, db_service, network_service):
        self.db = db_service
        self.network = network_service
        self.logger = logging.getLogger(__name__)
    
    def process_data_with_retry(self, data: dict, max_retries: int = 3) -> dict:
        """
        재시도 로직이 포함된 데이터 처리
        
        Args:
            data: 처리할 데이터
            max_retries: 최대 재시도 횟수
            
        Returns:
            처리된 데이터
            
        Raises:
            DatabaseException: 데이터베이스 오류
            NetworkException: 네트워크 오류
        """
        for attempt in range(max_retries):
            try:
                # 데이터베이스 저장
                record_id = self.db.save_data(data)
                
                # 네트워크 전송
                self.network.send_data(record_id, data)
                
                # 추가 처리
                processed = self._additional_processing(data)
                
                return processed
                
            except DatabaseException as e:
                self.logger.warning(f"데이터베이스 오류 (시도 {attempt+1}/{max_retries}): {e}")
                if attempt == max_retries - 1:
                    self.logger.error(f"최대 재시도 횟수 초과: {e}")
                    raise
                
            except NetworkException as e:
                self.logger.warning(f"네트워크 오류 (시도 {attempt+1}/{max_retries}): {e}")
                if attempt == max_retries - 1:
                    self.logger.error(f"최대 재시도 횟수 초과: {e}")
                    raise
                
            except Exception as e:
                self.logger.error(f"예상치 못한 오류: {e}")
                raise RuntimeError(f"처리 실패: {e}") from e
            
            # 재시도 전 대기
            import time
            time.sleep(1 * (attempt + 1))  # 지수 백오프
    
    def _additional_processing(self, data: dict) -> dict:
        """추가 데이터 처리"""
        # 복잡한 처리 로직 (실제 구현 생략)
        data['processed'] = True
        data['timestamp'] = datetime.datetime.now().isoformat()
        return data

class TestExceptionHandling(unittest.TestCase):
    """예외 처리 테스트 클래스"""
    
    def setUp(self):
        self.mock_db = Mock()
        self.mock_network = Mock()
        self.processor = RobustDataProcessor(self.mock_db, self.mock_network)
        
        # 로깅 설정
        logging.basicConfig(level=logging.WARNING)
        self.log_capture = []
        
        class TestHandler(logging.Handler):
            def emit(self, record):
                self.log_capture.append(record.getMessage())
        
        self.handler = TestHandler()
        self.processor.logger.addHandler(self.handler)
    
    def test_successful_processing(self):
        """성공적인 처리 테스트"""
        # 모의 객체 설정
        self.mock_db.save_data.return_value = 123
        self.mock_network.send_data.return_value = None
        
        data = {"id": 1, "value": "test"}
        result = self.processor.process_data_with_retry(data)
        
        # 검증
        self.assertTrue(result['processed'])
        self.mock_db.save_data.assert_called_once_with(data)
        self.mock_network.send_data.assert_called_once_with(123, data)
    
    def test_database_exception_with_retry(self):
        """데이터베이스 예외 재시도 테스트"""
        # 모의 객체 설정 (첫 번째 호출 실패, 두 번째 성공)
        self.mock_db.save_data.side_effect = [
            DatabaseException("Connection failed", 1001),
            lambda x: 456  # 성공
        ]
        self.mock_network.send_data.return_value = None
        
        data = {"id": 2, "value": "retry_test"}
        result = self.processor.process_data_with_retry(data, max_retries=3)
        
        # 검증
        self.assertTrue(result['processed'])
        self.assertEqual(self.mock_db.save_data.call_count, 2)
        
        # 로그 확인
        self.assertIn("데이터베이스 오류", self.handler.log_capture[0])
    
    def test_max_retries_exceeded(self):
        """최대 재시도 횟수 초과 테스트"""
        # 모의 객체 설정 (항상 실패)
        self.mock_db.save_data.side_effect = DatabaseException("Permanent failure", 1002)
        
        data = {"id": 3, "value": "failure_test"}
        
        # 예외 발생 검증
        with self.assertRaises(DatabaseException) as context:
            self.processor.process_data_with_retry(data, max_retries=2)
        
        # 예외 상세 정보 검증
        self.assertEqual(context.exception.error_code, 1002)
        self.assertIn("Permanent failure", str(context.exception))
        
        # 호출 횟수 검증
        self.assertEqual(self.mock_db.save_data.call_count, 2)
        
        # 로그 확인
        self.assertIn("최대 재시도 횟수 초과", self.handler.log_capture[-1])
    
    def test_unexpected_exception(self):
        """예상치 못한 예외 테스트"""
        # 모의 객체 설정 (일반 예외 발생)
        self.mock_db.save_data.side_effect = ValueError("Invalid data format")
        
        data = {"id": 4, "value": "unexpected_test"}
        
        # RuntimeError로 변환되어 발생하는지 검증
        with self.assertRaises(RuntimeError) as context:
            self.processor.process_data_with_retry(data)
        
        self.assertIn("처리 실패", str(context.exception))
        self.assertIsInstance(context.exception.__cause__, ValueError)
    
    def test_multiple_exception_types(self):
        """다양한 예외 타입 테스트"""
        test_cases = [
            (DatabaseException("DB Error", 1001), DatabaseException),
            (NetworkException("Network Error", 2001), NetworkException),
            (KeyError("Missing key"), RuntimeError),  # 변환됨
        ]
        
        for exception_to_raise, expected_exception_type in test_cases:
            with self.subTest(exception=type(exception_to_raise).__name__):
                self.mock_db.save_data.side_effect = exception_to_raise
                self.mock_network.send_data.return_value = None
                
                data = {"id": 5, "value": "multi_exception_test"}
                
                try:
                    self.processor.process_data_with_retry(data, max_retries=1)
                    self.fail(f"{expected_exception_type.__name__} 예외가 발생해야 합니다")
                except expected_exception_type:
                    pass  # 예상된 예외
                except Exception as e:
                    self.fail(f"예상치 못한 예외 타입: {type(e)}")
    
    def test_exception_context_and_chaining(self):
        """예외 컨텍스트와 체이닝 테스트"""
        # 원본 예외 생성
        original_exception = DatabaseException("Original error", 1003)
        
        # 예외 체이닝 테스트
        try:
            try:
                raise original_exception
            except DatabaseException as e:
                # 새 예외를 이전 예외와 체이닝
                raise RuntimeError("처리 실패") from e
        except RuntimeError as e:
            # 체이닝 검증
            self.assertIsInstance(e.__cause__, DatabaseException)
            self.assertEqual(e.__cause__.error_code, 1003)
    
    def test_exception_assertions(self):
        """다양한 예외 어서션 테스트"""
        
        def function_that_raises():
            raise CustomException("테스트 예외", 999)
        
        def function_that_returns():
            return "성공"
        
        # 기본 예외 발생 검증
        with self.assertRaises(CustomException):
            function_that_raises()
        
        # 예외 메시지 검증
        with self.assertRaises(CustomException) as cm:
            function_that_raises()
        
        self.assertEqual(str(cm.exception), "테스트 예외")
        self.assertEqual(cm.exception.error_code, 999)
        
        # 예외가 발생하지 않아야 하는 경우
        with self.assertRaises(AssertionError):
            with self.assertRaises(CustomException):
                function_that_returns()
        
        # assertRaisesRegex를 이용한 정규식 매칭
        with self.assertRaisesRegex(CustomException, r"테스트.*예외"):
            function_that_raises()
        
        # assertWarns를 이용한 경고 검증
        import warnings
        
        def function_that_warns():
            warnings.warn("이것은 경고입니다", UserWarning)
        
        with self.assertWarns(UserWarning):
            function_that_warns()

# 컨텍스트 매니저 예외 테스트
class TestContextManagerExceptions(unittest.TestCase):
    """컨텍스트 매니저 예외 테스트"""
    
    class ResourceManager:
        """리소스 관리 컨텍스트 매니저"""
        
        def __enter__(self):
            print("리소스 획득")
            return self
        
        def __exit__(self, exc_type, exc_val, exc_tb):
            print("리소스 해제")
            if exc_type is not None:
                print(f"예외 발생: {exc_type.__name__}: {exc_val}")
                # 예외를 처리하고 더 이상 전파하지 않음
                return True
            return False
        
        def operation(self):
            """리소스 작업"""
            print("작업 수행")
    
    def test_context_manager_exception_handling(self):
        """컨텍스트 매니저 내부 예외 처리"""
        
        def operation_that_fails():
            raise ValueError("작업 실패")
        
        manager = self.ResourceManager()
        
        # 컨텍스트 매니저 내부에서 예외 발생
        with manager:
            with self.assertRaises(ValueError):
                operation_that_fails()
        
        # __exit__이 예외를 처리했으므로 외부로 전파되지 않음
    
    def test_nested_context_managers(self):
        """중첩 컨텍스트 매니저 예외 처리"""
        
        class InnerManager:
            def __enter__(self):
                return self
            
            def __exit__(self, exc_type, exc_val, exc_tb):
                if exc_type:
                    print(f"내부 매니저 예외 처리: {exc_type.__name__}")
                    # 예외를 변환
                    raise RuntimeError("내부 오류 발생") from exc_val
        
        with self.assertRaises(RuntimeError) as cm:
            with contextlib.ExitStack() as stack:
                stack.enter_context(self.ResourceManager())
                stack.enter_context(InnerManager())
                raise ValueError("원본 오류")
        
        # 예외 체이닝 검증
        self.assertIsInstance(cm.exception.__cause__, ValueError)

# 데코레이터 예외 테스트
def retry_on_exception(max_attempts: int = 3, exceptions: tuple = (Exception,)):
    """예외 발생 시 재시도 데코레이터"""
    def decorator(func):
        def wrapper(*args, **kwargs):
            last_exception = None
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except exceptions as e:
                    last_exception = e
                    if attempt == max_attempts - 1:
                        break
                    print(f"시도 {attempt+1} 실패: {e}. 재시도 중...")
            raise last_exception
        return wrapper
    return decorator

class TestDecoratorExceptions(unittest.TestCase):
    """데코레이터 예외 테스트"""
    
    @retry_on_exception(max_attempts=2, exceptions=(ValueError,))
    def unreliable_function(self, fail_times: int = 0):
        """신뢰성 없는 함수"""
        if unreliable_function.call_count < fail_times:
            unreliable_function.call_count += 1
            raise ValueError("일시적 오류")
        return "성공"
    
    def test_retry_decorator(self):
        """재시도 데코레이터 테스트"""
        # 호출 카운터 설정
        unreliable_function.call_count = 0
        
        # 처음에는 실패, 두 번째는 성공
        result = self.unreliable_function(fail_times=1)
        self.assertEqual(result, "성공")
        self.assertEqual(unreliable_function.call_count, 1)
        
        # 항상 실패하는 경우
        unreliable_function.call_count = 0
        with self.assertRaises(ValueError):
            self.unreliable_function(fail_times=3)
```

## 테스트 결과 기록과 리포트 생성

테스트 결과를 체계적으로 기록하고 다양한 형식의 리포트를 생성하는 것은 지속적 통합과 품질 관리에 필수적입니다.

```python
import unittest
import json
import csv
import xml.etree.ElementTree as ET
import datetime
import sys
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field, asdict
import html
import statistics

@dataclass
class TestResultRecord:
    """테스트 결과 기록"""
    test_name: str
    test_class: str
    status: str  # PASS, FAIL, ERROR, SKIP
    duration: float
    timestamp: datetime.datetime = field(default_factory=datetime.datetime.now)
    error_message: Optional[str] = None
    stack_trace: Optional[str] = None
    additional_info: Dict[str, Any] = field(default_factory=dict)
    
    def to_dict(self) -> Dict:
        """딕셔너리로 변환"""
        result = asdict(self)
        result['timestamp'] = self.timestamp.isoformat()
        return result

class TestResultCollector:
    """테스트 결과 수집기"""
    
    def __init__(self):
        self.records: List[TestResultRecord] = []
        self.start_time = None
        self.end_time = None
    
    def start_test_run(self):
        """테스트 실행 시작"""
        self.start_time = datetime.datetime.now()
        self.records.clear()
    
    def end_test_run(self):
        """테스트 실행 종료"""
        self.end_time = datetime.datetime.now()
    
    def add_result(self, record: TestResultRecord):
        """결과 추가"""
        self.records.append(record)
    
    def get_summary(self) -> Dict[str, Any]:
        """테스트 실행 요약"""
        if not self.records:
            return {}
        
        total = len(self.records)
        passed = sum(1 for r in self.records if r.status == 'PASS')
        failed = sum(1 for r in self.records if r.status == 'FAIL')
        errors = sum(1 for r in self.records if r.status == 'ERROR')
        skipped = sum(1 for r in self.records if r.status == 'SKIP')
        
        durations = [r.duration for r in self.records]
        
        return {
            'total_tests': total,
            'passed': passed,
            'failed': failed,
            'errors': errors,
            'skipped': skipped,
            'pass_rate': (passed / total) * 100 if total > 0 else 0,
            'start_time': self.start_time.isoformat() if self.start_time else None,
            'end_time': self.end_time.isoformat() if self.end_time else None,
            'duration': (self.end_time - self.start_time).total_seconds() 
                       if self.start_time and self.end_time else 0,
            'avg_duration': statistics.mean(durations) if durations else 0,
            'min_duration': min(durations) if durations else 0,
            'max_duration': max(durations) if durations else 0
        }
    
    def export_json(self, filepath: str) -> None:
        """JSON 형식으로 내보내기"""
        data = {
            'summary': self.get_summary(),
            'results': [r.to_dict() for r in self.records]
        }
        
        with open(filepath, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
    
    def export_csv(self, filepath: str) -> None:
        """CSV 형식으로 내보내기"""
        if not self.records:
            return
        
        fieldnames = list(self.records[0].to_dict().keys())
        
        with open(filepath, 'w', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=fieldnames)
            writer.writeheader()
            for record in self.records:
                writer.writerow(record.to_dict())
    
    def export_xml(self, filepath: str) -> None:
        """JUnit XML 형식으로 내보내기"""
        summary = self.get_summary()
        
        testsuites = ET.Element('testsuites')
        testsuite = ET.SubElement(testsuites, 'testsuite',
                                 name='TestSuite',
                                 tests=str(summary['total_tests']),
                                 failures=str(summary['failed']),
                                 errors=str(summary['errors']),
                                 skipped=str(summary['skipped']),
                                 time=str(summary['duration']))
        
        for record in self.records:
            testcase = ET.SubElement(testsuite, 'testcase',
                                    name=record.test_name,
                                    classname=record.test_class,
                                    time=str(record.duration))
            
            if record.status == 'FAIL':
                failure = ET.SubElement(testcase, 'failure',
                                       message=record.error_message or '')
                if record.stack_trace:
                    failure.text = record.stack_trace
            elif record.status == 'ERROR':
                error = ET.SubElement(testcase, 'error',
                                     message=record.error_message or '')
                if record.stack_trace:
                    error.text = record.stack_trace
            elif record.status == 'SKIP':
                ET.SubElement(testcase, 'skipped')
        
        tree = ET.ElementTree(testsuites)
        tree.write(filepath, encoding='utf-8', xml_declaration=True)
    
    def export_html(self, filepath: str) -> None:
        """HTML 리포트 생성"""
        summary = self.get_summary()
        
        html_content = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>테스트 리포트</title>
            <style>
                body {{ font-family: Arial, sans-serif; margin: 20px; }}
                .summary {{ background: #f5f5f5; padding: 20px; border-radius: 5px; }}
                .stats {{ display: flex; gap: 20px; margin-top: 10px; }}
                .stat-box {{ background: white; padding: 15px; border-radius: 3px; flex: 1; }}
                .passed {{ color: green; }}
                .failed {{ color: red; }}
                .error {{ color: orange; }}
                .skipped {{ color: gray; }}
                table {{ width: 100%; border-collapse: collapse; margin-top: 20px; }}
                th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
                th {{ background-color: #f2f2f2; }}
                tr:hover {{ background-color: #f5f5f5; }}
            </style>
        </head>
        <body>
            <h1>테스트 실행 리포트</h1>
            
            <div class="summary">
                <h2>요약</h2>
                <p>실행 시간: {summary['start_time']} - {summary['end_time']}</p>
                <p>총 실행 시간: {summary['duration']:.2f}초</p>
                
                <div class="stats">
                    <div class="stat-box">
                        <h3 class="passed">✓ 통과</h3>
                        <p>{summary['passed']} / {summary['total_tests']}</p>
                        <p>통과율: {summary['pass_rate']:.1f}%</p>
                    </div>
                    <div class="stat-box">
                        <h3 class="failed">✗ 실패</h3>
                        <p>{summary['failed']}</p>
                    </div>
                    <div class="stat-box">
                        <h3 class="error">⚠ 오류</h3>
                        <p>{summary['errors']}</p>
                    </div>
                    <div class="stat-box">
                        <h3 class="skipped">⏭ 건너뜀</h3>
                        <p>{summary['skipped']}</p>
                    </div>
                </div>
            </div>
            
            <h2>상세 결과</h2>
            <table>
                <tr>
                    <th>테스트 클래스</th>
                    <th>테스트 메서드</th>
                    <th>상태</th>
                    <th>소요 시간 (초)</th>
                    <th>오류 메시지</th>
                </tr>
        """
        
        for record in self.records:
            status_class = record.status.lower()
            html_content += f"""
                <tr>
                    <td>{html.escape(record.test_class)}</td>
                    <td>{html.escape(record.test_name)}</td>
                    <td class="{status_class}">{record.status}</td>
                    <td>{record.duration:.3f}</td>
                    <td>{html.escape(record.error_message or '')}</td>
                </tr>
            """
        
        html_content += """
            </table>
        </body>
        </html>
        """
        
        with open(filepath, 'w', encoding='utf-8') as f:
            f.write(html_content)

# 커스텀 테스트 러너
class CustomTestRunner(unittest.TextTestRunner):
    """커스텀 테스트 러너"""
    
    def __init__(self, result_collector: TestResultCollector, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.collector = result_collector
    
    def run(self, test):
        """테스트 실행"""
        self.collector.start_test_run()
        
        # 원래의 run 메서드 호출
        result = super().run(test)
        
        self.collector.end_test_run()
        return result

# 테스트 결과 후킹
class ResultHookTestResult(unittest.TestResult):
    """결과 후킹 테스트 결과 클래스"""
    
    def __init__(self, result_collector: TestResultCollector, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.collector = result_collector
        self.current_test = None
        self.start_time = None
    
    def startTest(self, test):
        """테스트 시작"""
        super().startTest(test)
        self.current_test = test
        self.start_time = datetime.datetime.now()
    
    def addSuccess(self, test):
        """성공 결과 추가"""
        super().addSuccess(test)
        duration = (datetime.datetime.now() - self.start_time).total_seconds()
        
        record = TestResultRecord(
            test_name=test._testMethodName,
            test_class=test.__class__.__name__,
            status='PASS',
            duration=duration
        )
        self.collector.add_result(record)
    
    def addFailure(self, test, err):
        """실패 결과 추가"""
        super().addFailure(test, err)
        duration = (datetime.datetime.now() - self.start_time).total_seconds()
        
        record = TestResultRecord(
            test_name=test._testMethodName,
            test_class=test.__class__.__name__,
            status='FAIL',
            duration=duration,
            error_message=str(err[1]),
            stack_trace=self._exc_info_to_string(err, test)
        )
        self.collector.add_result(record)
    
    def addError(self, test, err):
        """오류 결과 추가"""
        super().addError(test, err)
        duration = (datetime.datetime.now() - self.start_time).total_seconds()
        
        record = TestResultRecord(
            test_name=test._testMethodName,
            test_class=test.__class__.__name__,
            status='ERROR',
            duration=duration,
            error_message=str(err[1]),
            stack_trace=self._exc_info_to_string(err, test)
        )
        self.collector.add_result(record)
    
    def addSkip(self, test, reason):
        """건너뛰기 결과 추가"""
        super().addSkip(test, reason)
        duration = (datetime.datetime.now() - self.start_time).total_seconds()
        
        record = TestResultRecord(
            test_name=test._testMethodName,
            test_class=test.__class__.__name__,
            status='SKIP',
            duration=duration,
            error_message=reason
        )
        self.collector.add_result(record)

# 통합 테스트 실행 예제
def run_tests_with_reporting(test_modules, output_dir='test_reports'):
    """리포트를 포함한 테스트 실행"""
    import os
    
    # 출력 디렉터리 생성
    os.makedirs(output_dir, exist_ok=True)
    
    # 결과 수집기 생성
    collector = TestResultCollector()
    
    # 테스트 스위트 생성
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    for module in test_modules:
        suite.addTests(loader.loadTestsFromModule(module))
    
    # 커스텀 테스트 러너 생성
    runner = unittest.TextTestRunner(
        resultclass=lambda stream, descriptions, verbosity: 
            ResultHookTestResult(collector, stream, descriptions, verbosity),
        verbosity=2
    )
    
    # 테스트 실행
    print("=" * 60)
    print("테스트 실행 시작")
    print("=" * 60)
    
    result = runner.run(suite)
    
    print("\n" + "=" * 60)
    print("테스트 실행 완료")
    print("=" * 60)
    
    # 리포트 생성
    timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # 다양한 형식으로 리포트 저장
    collector.export_json(os.path.join(output_dir, f'test_report_{timestamp}.json'))
    collector.export_csv(os.path.join(output_dir, f'test_report_{timestamp}.csv'))
    collector.export_xml(os.path.join(output_dir, f'test_report_{timestamp}.xml'))
    collector.export_html(os.path.join(output_dir, f'test_report_{timestamp}.html'))
    
    # 콘솔에 요약 출력
    summary = collector.get_summary()
    print(f"\n테스트 요약:")
    print(f"  총 테스트: {summary['total_tests']}")
    print(f"  통과: {summary['passed']}")
    print(f"  실패: {summary['failed']}")
    print(f"  오류: {summary['errors']}")
    print(f"  건너뜀: {summary['skipped']}")
    print(f"  통과율: {summary['pass_rate']:.1f}%")
    print(f"  평균 실행 시간: {summary['avg_duration']:.3f}초")
    
    return result, collector

# 테스트 모니터링 클래스
class TestMonitor:
    """실시간 테스트 모니터링"""
    
    def __init__(self):
        self.results = []
        self.callbacks = []
    
    def register_callback(self, callback):
        """실시간 콜백 등록"""
        self.callbacks.append(callback)
    
    def notify(self, result_record):
        """결과 알림"""
        self.results.append(result_record)
        for callback in self.callbacks:
            callback(result_record)
    
    def get_realtime_stats(self):
        """실시간 통계"""
        if not self.results:
            return {}
        
        total = len(self.results)
        passed = sum(1 for r in self.results if r.status == 'PASS')
        
        return {
            'completed': total,
            'passed': passed,
            'pass_rate': (passed / total) * 100 if total > 0 else 0,
            'current_status': self.results[-1].status if self.results else 'N/A'
        }

# 실시간 모니터링 예제
def monitor_example():
    """테스트 모니터링 예제"""
    
    def print_progress(record):
        """진행 상황 출력"""
        print(f"[{record.timestamp:%H:%M:%S}] {record.test_class}.{record.test_name}: "
              f"{record.status} ({record.duration:.3f}s)")
    
    monitor = TestMonitor()
    monitor.register_callback(print_progress)
    
    # 테스트 실행 (시뮬레이션)
    test_records = [
        TestResultRecord("test_addition", "TestCalculator", "PASS", 0.123),
        TestResultRecord("test_subtraction", "TestCalculator", "FAIL", 0.456, 
                        error_message="Assertion failed"),
        TestResultRecord("test_multiplication", "TestCalculator", "PASS", 0.789),
    ]
    
    for record in test_records:
        monitor.notify(record)
        # 잠시 대기 (실제 테스트 실행 시뮬레이션)
        import time
        time.sleep(0.5)
    
    stats = monitor.get_realtime_stats()
    print(f"\n실시간 통계: {stats}")
```

## 결론

### 표준 출력 테스팅의 체계적 접근법
1. **출력 캡처 전략**: `contextlib.redirect_stdout/stderr`를 활용한 격리된 출력 캡처가 기본입니다. 데코레이터 패턴으로 테스트 코드를 간결하게 유지하세요.
2. **검증의 다양성**: 단순 문자열 비교를 넘어 정규식 매칭, JSON 구조 검증, 다중 라인 비교 등을 지원하는 풍부한 어서션 메서드를 구현하세요.
3. **CLI 애플리케이션 테스트**: 명령줄 인수, 종료 코드, 사용자 상호작용을 포함한 완전한 CLI 테스트 시나리오를 구성하세요.
4. **성능 고려**: 대용량 출력 테스트 시 메모리 효율성을 고려하고, 필요한 경우 스트리밍 방식의 출력 검증을 구현하세요.

### 객체 패칭의 전략적 활용
1. **의존성 격리**: 외부 시스템(데이터베이스, API, 파일 시스템)에 의존하는 코드는 반드시 패칭을 통해 격리 테스트하세요.
2. **패칭 수준 선택**: 
   - **객체 수준 패칭**: 특정 객체의 메서드만 모의(Mock 객체 생성)
   - **모듈 수준 패칭**: 전체 모듈이나 클래스를 패치(`@patch` 데코레이터)
   - **환경 패칭**: 환경 변수, 설정 파일 등 실행 환경 패치
3. **모의 객체 행동 정의**: 
   - **반환 값 설정**: `return_value`로 고정 값 반환
   - **사이드 이펙트**: `side_effect`로 동적 행동 구현
   - **예외 발생**: `side_effect`에 예외 클래스 할당
4. **호출 검증**: 
   - **호출 여부**: `assert_called`, `assert_not_called`
   - **호출 횟수**: `call_count`, `assert_called_once`
   - **호출 인수**: `assert_called_with`, `assert_called_once_with`
   - **호출 순서**: `assert_has_calls` with `call` 객체

### 예외 조건 테스트의 완전성 보장
1. **예외 유형별 테스트**: 
   - **기대된 예외**: 정상적인 오류 처리 흐름 테스트
   - **예상치 못한 예외**: 시스템 복원력 테스트
   - **경계 조건 예외**: 엣지 케이스 테스트
2. **예외 체이닝 검증**: `raise ... from ...` 구문을 사용한 예외 체이닝이 올바르게 동작하는지 검증하세요.
3. **예외 메시지와 속성**: 예외 객체의 메시지, 에러 코드, 타임스탬프 등 추가 속성을 검증하세요.
4. **복합 예외 시나리오**: 재시도 로직, 폴백 메커니즘, 트랜잭션 롤백 등 복잡한 예외 처리 흐름을 테스트하세요.

### 테스트 결과 기록의 산업 표준 준수
1. **다양한 리포트 형식 지원**:
   - **JSON**: 기계 판독용, CI/CD 통합
   - **JUnit XML**: Jenkins, GitLab CI 등과 호환
   - **HTML**: 인간 판독용, 시각적 요약
   - **CSV**: 데이터 분석 및 집계용
2. **포괄적인 결과 정보**:
   - 기본 정보: 테스트명, 상태, 실행 시간
   - 실패 정보: 오류 메시지, 스택 트레이스
   - 메타데이터: 타임스탬프, 추가 속성
3. **실시간 모니터링**: 장시간 실행 테스트의 진행 상황을 실시간으로 모니터링하고 보고하는 시스템을 구축하세요.
4. **통계적 분석**: 성공률, 평균 실행 시간, 실패 패턴 분석 등 품질 메트릭을 수집하고 시각화하세요.

### 통합 테스트 인프라 구축
1. **테스트 러너 커스터마이징**: 프로젝트 요구사항에 맞춘 커스텀 테스트 러너를 개발하세요.
2. **결과 수집 파이프라인**: 테스트 실행 → 결과 수집 → 리포트 생성 → 알림 발송의 완전한 파이프라인을 구축하세요.
3. **성능 기준 설정**: 테스트 실행 시간, 메모리 사용량 등의 성능 기준을 설정하고 모니터링하세요.
4. **테스트 데이터 관리**: 테스트 간 독립성을 보장하는 데이터 관리 전략을 수립하세요.

이러한 고급 테스팅 기법들을 체계적으로 적용하면 안정성과 유지보수성이 뛰어난 소프트웨어를 개발할 수 있습니다. 테스트 코드 자체도 프로덕션 코드와 동일한 품질 기준을 적용하여 지속적인 개선의 대상으로 삼아야 합니다.