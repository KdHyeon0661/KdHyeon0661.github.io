---
layout: post
title: C# - 입출력 및 주석
date: 2024-10-05 18:20:23 +0900
category: Csharp
---
# C# 입출력(I/O)과 주석

## 한눈에 보는 체크리스트

- 콘솔 출력: `Console.Write`, `Console.WriteLine`, 서식/보간
- 콘솔 입력: `Console.ReadLine`, `Console.ReadKey`, 안전한 파싱(`TryParse`)
- 파일 I/O: `File.*`(간편 API), `StreamReader/Writer`, `FileStream`
- 비동기: `ReadAllTextAsync`, `CopyToAsync`, `await using`
- 인코딩: `Encoding.UTF8`(BOM), `new UTF8Encoding(false)`(no BOM), `Encoding.RegisterProvider`
- 경로: `Path.Combine`, `Path.GetFullPath`, `Directory`, `Environment.SpecialFolder`
- 안전한 쓰기: 임시파일 → `File.Replace`(윈도우) / 쓰기 후 `File.Move`(원자적 교체)
- 파일 잠금/공유: `FileShare`, `FileOptions.Asynchronous`, `FileAccess`
- 대용량: 버퍼 크기, `MemoryStream`, `ReadOnlySpan<byte>`, `MemoryMappedFile`
- 압축: `GZipStream`, `ZipArchive`
- 직렬화: `System.Text.Json`, XML(문서화 주석과 구분), CSV(라이브러리 권장)
- 주석: `//`, `/*...*/`, `/// XML`( `<summary> <param> <returns> <exception> <remarks> <example> <inheritdoc/>` )
- 문서 생성: `<GenerateDocumentationFile>`, `NoWarn 1591`, DocFX/VS에서 IntelliSense

---

## 콘솔 입출력

### 출력: `Console.Write`, `Console.WriteLine`

```csharp
Console.Write("Hello ");          // 줄바꿈 없음
Console.WriteLine("World!");      // 줄바꿈 포함
Console.WriteLine(123);           // 기본 타입 ToString()
Console.WriteLine($"{1+2} result"); // 문자열 보간
Console.WriteLine("PI: {0:F3}", Math.PI); // 복합 서식
```

- `Environment.NewLine`로 OS별 개행 문자열을 얻을 수 있습니다.
- 성능 민감 구간에서는 문자열 보간을 빈번히 구성하지 말고, 필요한 경우 `StringBuilder`나 구조적 로깅을 고려합니다.

### 입력: `Console.ReadLine`, `Console.ReadKey`

```csharp
Console.Write("이름을 입력하세요: ");
string? name = Console.ReadLine();               // null 가능 (EOF)
Console.WriteLine($"안녕하세요, {name ?? "손님"}님!");

Console.WriteLine("아무 키나 누르세요...");
ConsoleKeyInfo key = Console.ReadKey(intercept: true); // 화면 표시 차단
Console.WriteLine($"\n입력: {key.Key} / Alt:{key.Modifiers.HasFlag(ConsoleModifiers.Alt)}");
```

- `ReadKey(intercept:true)`는 입력 문자를 **화면에 출력하지 않음**(비밀번호 마스킹 구현에 활용).
- 표준 스트림은 `Console.OpenStandardInput/Output/Error()`로 스트림 형태로도 접근 가능합니다.

---

## 기본 데이터형 입력 처리 — 예외 없이 안전하게

입력 문자열은 `string`이므로 숫자/실수 변환 시 예외를 피하려면 `TryParse` 권장.

```csharp
using System.Globalization;

Console.Write("정수를 입력: ");
if (int.TryParse(Console.ReadLine(), NumberStyles.Integer, CultureInfo.InvariantCulture, out int n))
{
    Console.WriteLine($"입력 OK: {n}");
}
else
{
    Console.WriteLine("정수 변환 실패");
}

Console.Write("실수 입력(예: 3.14): ");
if (double.TryParse(Console.ReadLine(), NumberStyles.Float, CultureInfo.InvariantCulture, out double d))
{
    Console.WriteLine($"입력 OK: {d}");
}
else
{
    Console.WriteLine("실수 변환 실패");
}
```

- **로캘 이슈**: 한국 로캘은 소수점 구분자로 `.` 를 쓰지만, 일부 문화권은 `,` 사용.
  크로스플랫폼/데이터 교환 시 **`CultureInfo.InvariantCulture`**를 명시하여 일관성 확보.
- 반복 입력 루프(검증/재시도)는 사용자 도구에서 흔히 필요.

---

## 파일 I/O — 간편 API vs 스트림

### File.* 간편 API

```csharp
var path = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.Desktop), "note.txt");

// 쓰기(덮어쓰기)
File.WriteAllText(path, "첫 줄\n", new UTF8Encoding(encoderShouldEmitUTF8Identifier:false));

// 추가(Append)
File.AppendAllText(path, "둘째 줄\n");

// 읽기
string all = File.ReadAllText(path);
Console.WriteLine(all);

// 비동기
await File.WriteAllTextAsync(path, "Async Write\n");
string read = await File.ReadAllTextAsync(path);
```

- **UTF-8 BOM**: 기본 `File.WriteAllText`는 플랫폼/런타임 버전에 따라 BOM 포함/미포함이 달라질 수 있습니다.
  명시적으로 `new UTF8Encoding(false)` 를 넘겨 **BOM 없는 UTF-8**을 강제하는 습관을 권장(도구/플랫폼 호환성 ↑).

### StreamReader/StreamWriter (텍스트 스트림)

```csharp
var enc = new UTF8Encoding(encoderShouldEmitUTF8Identifier:false);
using var writer = new StreamWriter(path, append: false, encoding: enc);
writer.WriteLine("A");
writer.Write("B");
writer.WriteLine("C");

using var reader = new StreamReader(path, enc);
string? line;
while ((line = reader.ReadLine()) is not null)
{
    Console.WriteLine(line);
}
```

- 장점: **버퍼링**/인코딩 제어/라인단위 읽기/쓰기
- 대용량에서의 효율은 버퍼 크기(`StreamWriter` 생성자)로 조절 가능.

### + 버퍼

```csharp
byte[] buffer = new byte[81920]; // .NET 권장 크기
using var fsIn = new FileStream("input.bin", FileMode.Open, FileAccess.Read, FileShare.Read, bufferSize: buffer.Length);
using var fsOut = new FileStream("output.bin", FileMode.Create, FileAccess.Write, FileShare.None, bufferSize: buffer.Length);

int read;
while ((read = fsIn.Read(buffer, 0, buffer.Length)) > 0)
{
    fsOut.Write(buffer, 0, read);
}
```

- `CopyTo`/`CopyToAsync`로 단순화 가능:

```csharp
await using var src = File.OpenRead("in.bin");
await using var dst = File.Create("out.bin");
await src.CopyToAsync(dst);
```

- **비동기 플래그**: 고빈도 I/O에서 `new FileStream(..., options: FileOptions.Asynchronous)` 고려.

---

## 인코딩/로캘/라인 엔딩

### UTF-8이 기본 — BOM 제어

```csharp
var utf8NoBom = new UTF8Encoding(encoderShouldEmitUTF8Identifier:false);
await File.WriteAllTextAsync("utf8.txt", "가나다", utf8NoBom);
```

- 레거시(예: EUC-KR) 파일을 읽으려면 공급자 등록:

```csharp
Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);
var euckr = Encoding.GetEncoding(51949);
string text = File.ReadAllText("legacy.txt", euckr);
```

### 줄바꿈(Windows=`\r\n`, Unix=`\n`)

- 텍스트 교환 시 **혼합 개행**이 있을 수 있으므로 `ReadLine()` 사용을 권장.
- 바이너리 레벨에서 줄바꿈 조작 시 OS 간 차이를 인지.

---

## 경로/디렉터리 유틸

```csharp
string root = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
string dir  = Path.Combine(root, "Demo", DateTime.UtcNow.ToString("yyyyMMdd"));
Directory.CreateDirectory(dir);        // 중첩 생성 OK

string file = Path.Combine(dir, "data.txt");
File.WriteAllText(file, "hello");

bool exists = File.Exists(file);
string full  = Path.GetFullPath(file);
string? name = Path.GetFileNameWithoutExtension(file);
string ext   = Path.GetExtension(file);
```

- **경로 결합**은 항상 `Path.Combine` 사용(슬래시 하드코딩 금지).
- **경로 정규화**: 사용자 입력 경로는 `Path.GetFullPath`로 정규화하여 상위 디렉터리 탈출(`..`) 공격 방지.

---

## 안전한 파일 쓰기(원자성/경쟁조건)

### 임시 파일 → 교체

```csharp
var target = "config.json";
var temp   = target + ".tmp";

await File.WriteAllTextAsync(temp, "{ \"ok\": true }", new UTF8Encoding(false));

// Windows: 원자적 교체
if (OperatingSystem.IsWindows())
{
    // 백업 파일은 필요시 지정
    File.Replace(temp, target, destinationBackupFileName: null);
}
else
{
    // Linux/macOS: 쓰기 완료 후 이동(대부분 원자적)
    File.Move(temp, target, overwrite: true);
}
```

- 이 방식은 **부분 쓰기/크래시**로 인한 손상 방지.

### FileShare/잠금

```csharp
using var fs = new FileStream(
    "log.txt",
    FileMode.Append,
    FileAccess.Write,
    FileShare.Read); // 읽기는 허용, 쓰기 충돌 방지
```

- 로그/동시 접근 설계 시, 공유 모드와 잠금 전략을 명확히.

---

## 비동기 I/O — UI 멈춤/스레드 블로킹 방지

```csharp
byte[] data = await File.ReadAllBytesAsync("big.bin");
await File.WriteAllBytesAsync("copy.bin", data);

await using var input = File.OpenRead("in.dat");
await using var output = File.Create("out.dat");
await input.CopyToAsync(output);
```

- 서버/CLI에서도 대기 많은 I/O 작업은 `async`를 전파해 **스레드 점유**를 줄입니다.

---

## 바이너리 I/O — BinaryReader/Writer

```csharp
// 쓰기
await using (var fs = File.Create("vec3.bin"))
await using (var bw = new BinaryWriter(fs))
{
    bw.Write(1.0f); // x
    bw.Write(2.0f); // y
    bw.Write(3.0f); // z
}

// 읽기
await using (var fs = File.OpenRead("vec3.bin"))
await using (var br = new BinaryReader(fs))
{
    float x = br.ReadSingle();
    float y = br.ReadSingle();
    float z = br.ReadSingle();
    Console.WriteLine($"{x},{y},{z}");
}
```

- 엔디안(Endianness) 주의(기본은 리틀엔디안). 멀티플랫폼/프로토콜은 명시적 정의 필요.

---

## 직렬화(JSON/XML/CSV)

### System.Text.Json

```csharp
using System.Text.Json;

var obj = new Note { Id = 1, Text = "메모", Created = DateTimeOffset.UtcNow };
var json = JsonSerializer.Serialize(obj, new JsonSerializerOptions { WriteIndented = true });
await File.WriteAllTextAsync("note.json", json);

var obj2 = JsonSerializer.Deserialize<Note>(await File.ReadAllTextAsync("note.json"));

public record Note(int Id, string Text, DateTimeOffset Created);
```

- 고성능/스팬 친화, `JsonSerializerOptions`로 네이밍/날짜 포맷 제어.

### XML 직렬화(문서화 주석과 혼동 주의)

```csharp
using System.Xml.Serialization;

var person = new Person { Name = "Kim", Age = 30 };
var ser = new XmlSerializer(typeof(Person));

await using var fs = File.Create("person.xml");
ser.Serialize(fs, person);

await using var fr = File.OpenRead("person.xml");
var back = (Person)ser.Deserialize(fr)!;

public class Person { public string Name { get; set; } = ""; public int Age { get; set; } }
```

### CSV — 직접 파싱보다 라이브러리 권장

CSV는 인용부호, 이스케이프, 줄바꿈 등 함정이 많습니다. 간단 예시는 가능하지만, **실무에선 CSV 라이브러리** 사용을 추천합니다.

```csharp
// 단순 예: 쉼표 포함/따옴표 처리 등은 불완전
var lines = await File.ReadAllLinesAsync("data.csv");
foreach (var line in lines)
{
    var cells = line.Split(','); // 취약
    // ...
}
```

---

## 압축/아카이브

```csharp
using System.IO.Compression;

// GZip
await using (var src = File.OpenRead("raw.bin"))
await using (var dst = File.Create("raw.bin.gz"))
await using (var gzip = new GZipStream(dst, CompressionLevel.SmallestSize))
{
    await src.CopyToAsync(gzip);
}

// Zip 묶기
using (var zip = ZipFile.Open("bundle.zip", ZipArchiveMode.Create))
{
    zip.CreateEntryFromFile("note.txt", "note.txt");
}
```

---

## 메모리 파일, 대용량 — MemoryStream/MemoryMappedFile

```csharp
// MemoryStream: 메모리에서 가공 후 한 번에 파일로
using var ms = new MemoryStream();
await using (var writer = new StreamWriter(ms, new UTF8Encoding(false), leaveOpen: true))
{
    writer.WriteLine("in-memory");
}
ms.Position = 0;
await File.WriteAllBytesAsync("mem.txt", ms.ToArray());
```

```csharp
// Memory-mapped file: 초대용량 파일 부분 접근
using var mmf = MemoryMappedFile.CreateFromFile("huge.dat", FileMode.Open);
using var accessor = mmf.CreateViewAccessor(0, 1024);
byte value = accessor.ReadByte(0);
```

---

## 파이프라인/스팬 고성능 팁 (요약)

- 문자열 처리 대신 **`Span<T>`/`Memory<T>`**로 슬라이스 조작 → 할당 감소
- 핫패스에서 **string 보간/연결** 최소화
- I/O는 **버퍼 크기** 조절(81920 권장)과 **`CopyToAsync`** 적극 사용
- **`ArrayPool<T>`** 로 대형 버퍼 재사용

```csharp
Span<byte> header = stackalloc byte[8];
using var fs = File.OpenRead("f.bin");
fs.Read(header); // 필요 최소 길이 체크 후 사용
```

---

## 로그/표준 출력 리다이렉션 감지

```csharp
bool isRedirected = Console.IsOutputRedirected;
if (isRedirected)
{
    // 파이프/파일로 리다이렉션됨: 진행표 대신 단순 로그
}
```

- 라이브러리/서비스에서는 `Console` 대신 **ILogger** 추상화 권장.

---

## 예외/에러 처리 — when 필터/재시도/시간초과

```csharp
try
{
    using var fs = new FileStream("target.txt", FileMode.Open, FileAccess.Read);
    // ...
}
catch (IOException ex) when (ex.Message.Contains("being used"))
{
    // 잠금 충돌 → 재시도/백오프
}
catch (UnauthorizedAccessException)
{
    // 권한 오류
}
```

- 파일 접근은 권한/잠금/경로 유효성/존재 여부를 항상 고려합니다.

---

## 단위 테스트/통합 테스트에서의 I/O

- 테스트간 충돌 방지: `Path.GetTempFileName`/GUID 디렉터리 사용
- 테스트 후 정리: `IDisposable`/`IAsyncLifetime`로 정리 루틴 구현

```csharp
public class TempDirFixture : IDisposable
{
    public string Dir { get; } = Path.Combine(Path.GetTempPath(), Guid.NewGuid().ToString("N"));
    public TempDirFixture() => Directory.CreateDirectory(Dir);
    public void Dispose() => Directory.Delete(Dir, recursive: true);
}
```

---

## 성능 측정 — I/O 벤치 마이크로 예시

```csharp
// BenchmarkDotNet 예시 (I/O는 디스크/캐시 영향 주의)
[MemoryDiagnoser]
public class IoBench
{
    private const int N = 1_0000;

    [Benchmark]
    public void WriteLines()
    {
        using var sw = new StreamWriter("bench.txt", append:false, new UTF8Encoding(false), bufferSize: 1<<16);
        for (int i = 0; i < N; i++) sw.WriteLine(i);
    }
}
```

- I/O는 머신/디스크 상태에 따라 변동성이 큼. 반복/워밍업/격리 중요.

---

## 주석 — 한 줄/블록/TODO/전처리

### 한 줄 주석

```csharp
// 한 줄 주석입니다
Console.WriteLine("Hello");
```

### 여러 줄 주석

```csharp
/*
여러 줄 주석입니다
여러 줄에 걸쳐 설명할 수 있습니다.
*/
Console.WriteLine("Hello");
```

### TODO/FIXME 표기(도구 인덱싱 가능)

```csharp
// TODO: 파일 잠금 충돌 시 재시도 로직 추가
// FIXME: Windows 전용 API 분기 제거
```

### 전처리/조건 컴파일(로깅 레벨 제어 등)

```csharp
#if DEBUG

Console.WriteLine("디버그 빌드");
#else

// 릴리스 빌드
#endif

```

---

## XML 주석 — 문서화/IntelliSense

> `///` 시작, `<summary> <param> <returns> <exception> <remarks> <example> <seealso> <inheritdoc/>` 등 태그 지원.

```csharp
/// <summary>
/// 두 숫자를 더합니다.
/// </summary>
/// <param name="a">첫 번째 정수</param>
/// <param name="b">두 번째 정수</param>
/// <returns>두 숫자의 합</returns>
/// <exception cref="OverflowException">오버플로 시 발생</exception>
/// <remarks>32비트 범위 내에서만 안전합니다.</remarks>
/// <example>
/// <code>
/// var s = Add(1, 2); // 3
/// </code>
/// </example>
public static int Add(int a, int b) => checked(a + b);
```

- `<c>`(인라인 코드), `<paramref name="a"/>`, `<typeparamref name="T"/>`, `<see cref="Type.Member"/>` 등으로 풍부한 링크/참조.

### XML 문서 파일 생성/경고 제어

```xml
<!-- csproj -->
<PropertyGroup>
  <GenerateDocumentationFile>true</GenerateDocumentationFile>
  <NoWarn>$(NoWarn);1591</NoWarn> <!-- 공개 API 미주석 경고 완화 -->
</PropertyGroup>
```

- 빌드 시 XML 문서 파일 생성 → IDE가 IntelliSense로 표시.
- 대규모 문서는 DocFX 등으로 HTML 사이트를 생성해 배포 가능.

### `<inheritdoc/>`로 상속 문서화

```csharp
/// <inheritdoc />
public class MyList<T> : IList<T>
{
    // 인터페이스 문서를 상속해 반복 작성 최소화
}
```

---

## 실전 예시 1 — **입력 검증 + CSV 저장 + 안전한 교체**

```csharp
using System.Globalization;
using System.Text;

string file = "users.csv";
var enc = new UTF8Encoding(false);

// 1) 사용자 입력
Console.Write("이름: ");
string? name = Console.ReadLine();

Console.Write("나이: ");
if (!int.TryParse(Console.ReadLine(), NumberStyles.Integer, CultureInfo.InvariantCulture, out int age))
{
    Console.WriteLine("나이 형식 오류");
    return;
}

// 2) CSV 라인 구성(간단 처리 — 실제는 라이브러리 권장)
string Escape(string s) => s.Contains(',') || s.Contains('"') || s.Contains('\n')
    ? "\"" + s.Replace("\"", "\"\"") + "\"" : s;

string line = $"{Escape(name ?? "")},{age}\n";

// 3) 안전한 쓰기: temp → replace/move
string temp = file + ".tmp";
await File.AppendAllTextAsync(temp, line, enc);

if (OperatingSystem.IsWindows())
    File.Replace(temp, file, destinationBackupFileName: null);
else
    File.Move(temp, file, overwrite: true);

Console.WriteLine("저장 완료");
```

---

## + 공유 읽기 허용**

```csharp
static void RotateIfNeeded(string path, long limitBytes = 5_000_000)
{
    if (File.Exists(path) && new FileInfo(path).Length > limitBytes)
    {
        string archive = path + "." + DateTime.UtcNow:yyyyMMddHHmmss" + ".log";
        File.Move(path, archive, overwrite: false);
    }
}

string log = "app.log";
RotateIfNeeded(log);

using var fs = new FileStream(log, FileMode.Append, FileAccess.Write, FileShare.Read); // 읽기 공유 허용
using var sw = new StreamWriter(fs, new UTF8Encoding(false));
sw.WriteLine($"{DateTimeOffset.Now:o}\tStarted");
```

---

## 수식으로 보는 버퍼링 효과(개념적)

대용량 I/O에서 **버퍼 크기**가 너무 작으면 **시스템 호출 횟수**가 증가해 오버헤드가 커진다.
버퍼링 없이 \( n \)바이트를 전송한다고 하면, 호출 횟수 \( k \)는:

$$
k = \left\lceil \frac{n}{B} \right\rceil
$$

여기서 \( B \)는 버퍼 크기. 적절한 \( B \) 선택은 \( k \)를 줄여 문맥 전환/커널 호출 비용을 감소시킨다.

---

## 요약 표

| 구분 | 핵심 API | 비고 |
|---|---|---|
| 콘솔 출력 | `Console.WriteLine` | 보간/복합서식 |
| 콘솔 입력 | `Console.ReadLine`, `Console.ReadKey` | 마스킹/리다이렉션 |
| 텍스트 파일 | `File.ReadAllText`, `StreamWriter` | 인코딩 명시(UTF-8 no BOM 권장) |
| 바이너리 | `FileStream`, `BinaryReader/Writer` | 엔디안 주의 |
| 비동기 | `*Async`, `CopyToAsync` | 스레드 블로킹 방지 |
| 경로/디렉터리 | `Path.*`, `Directory.*` | 결합/정규화/보안 |
| 안전한 쓰기 | temp→`Replace`/`Move` | 부분쓰기 방지 |
| 압축 | `GZipStream`, `ZipArchive` | 로그/백업 |
| 대용량 | 버퍼/Span/MemoryMapped | 할당 감소 |
| 주석 | `//`, `/*...*/`, `///` | IntelliSense/문서화 |

---

## 결론

- C# I/O는 **간편(File.*) ↔ 정교(Stream/Buffer/Async)** 스펙트럼이 명확합니다.
- 텍스트는 **인코딩/개행/로캘**, 파일은 **경로/권한/락/원자성**, 대용량은 **버퍼/비동기/압축/맵**을 핵심 포인트로 삼으세요.
- 주석은 **한 줄/블록**으로 의도를 드러내고, 공개 API는 **XML 문서화**로 팀·사용자 모두의 가독성과 생산성을 높이세요.
